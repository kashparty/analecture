ID: 509d87bd-8d25-4193-8a0a-adeb0101f52a
Title: Advanced Programming - HLists
Category: Haskell
Lecturer: Anthony Field
Date: 25/11/2021
OK, so you're strong. Yeah.
0:06
Welcome aboard. Today we're going to be implementing interesting lists.
0:13
Specifically, we're going to be building up to the data structure supported by everyone's favourite programming language JavaScript.
0:18
So I'm going to start by, you know, kind of playing around a little bit with the JavaScript console.
0:27
So bear with me for a second.
0:34
I don't usually use this very much, but in case you didn't know, if you open a web browser, you can readily use JavaScript console.
0:37
We're not going to be writing much JavaScript.
0:49
They just wanted to give an idea of what's possible in, you know, JavaScript, and then we will build up to this,
0:51
this level of power in Haskell as well, but maybe a little maybe improve it a little bit.
1:00
So, you know, much like Haskell, JavaScript also supports this very sort of they call arrays.
1:05
A very simple beta structure holds a bunch of values.
1:14
You can do things like call this array X and you can become the first element of the list, maybe and tend to it.
1:17
So this is pretty standard stuff so far. Now, something that you can do in JavaScript that you can't do in Haskell, or at least you can easily do it.
1:28
Haskell is have an array of stories, different types of elements.
1:37
And the reason it's possible in JavaScript. What I mean by this you can have an array that's, you know,
1:43
as one follows the string hello and then another array, which let's say that also has everything is always.
1:47
So this is a perfectly fine data structure in JavaScript, of course,
1:58
because it's not really an affordances is more like because JavaScript does not have static type tracking.
2:03
It simply has no means of, you know, checking that the elements of your array are the same.
2:11
And it's kind of up to you to make sure that you use this array in a sane way.
2:19
And and it gets pretty difficult to do that because it's hard to keep track of,
2:24
you know, what your elements look like because we have this after a genius array here,
2:28
which I call wide, you know, you can still look at the first element and add an odd 10 to it.
2:33
You can look up. The next element falls happens to be coerced into zero when interpreting the number, which is interesting.
2:43
The next element? Again, an interesting choice. But then when you go to the OK again.
2:51
So that's what happens when you add it to an array and you can also, because that is the element of the array you looking, look up its first element.
2:59
That's fine. But if you try to look of the first element of Y's first element, then you get undefined,
3:09
which is kind of, you know, JavaScript way, way of saying, OK, enough is enough.
3:17
This is I can't do anything with this. An issue is that this is kind of a run type thing.
3:22
So we have this weird data structure with heterogeneous elements.
3:27
And you know, it looks it looks pretty cool,
3:34
but using it is actually quite annoying and using arrays in general in JavaScript or just using JavaScript
3:37
in general can be quite annoying because it can never be sure what the type type of the thing you get is,
3:45
you know, you have an array, but what are the elements?
3:54
If you know that the first element is in it, you have no guarantee that the next element is also going to be an end cetera, as we've seen here.
3:57
So there are solutions to that.
4:05
You know, TypeScript implements a type system for JavaScript, but that also has some some weird quirks that maybe we can talk about another time.
4:07
But yeah, it's just if you if you look at this little array here is heterogeneous array and think about.
4:18
Can we do something like this in high school, but do it in a safe way?
4:29
And what would do I mean by this? So first of all, of course, if we try to do this in high school because you know, you can have lists,
4:33
so the type of this list would be a list of numbers or a list of integers you can.
4:45
Look of the elements. This is the first index.
4:55
This is the next element, etc. All you can do is you can't say, Oh, I want to put one to and then it falls and then you can hello and you get,
5:00
you know, a psychiatrist saying you couldn't match like psychic type, all with strength.
5:19
And the reason you get the error is because, of course, list in hossler defined to be homogeneous.
5:24
So, so unless this can only hold elements of the same type. That's a very useful feature, because then, you know, looking at the elements of a list,
5:33
you can actually be sure you actually know what the element is that you're going to get.
5:41
So straight out of the gate, this doesn't work.
5:45
But my claim is that using some interesting model features of high school, we can actually emulate or actually implement these heterogeneous lists.
5:51
And that's what we're going to be building up today.
6:01
But before going there, I just want to go through a couple more steps on the way to illustrate these language features,
6:03
perhaps through smaller examples, a little easier to understand.
6:16
So one of the one of the features we're going to be using is Gateses, which we've seen a couple weeks ago.
6:20
But I'm going to give a quick refresher on what they looked like.
6:28
It's, of course, the language GDP's.
6:32
And so with this programme, well, we tell see that in the source file, we want to use the language feature of general algebraic types.
6:39
So a couple of weeks ago, we saw the expression language which had which had this indexed definition.
6:48
It was a G.D.P. and it had, and the EU constructor was an expression of end.
6:56
And I think we had an E string constructor, which was which held a string.
7:06
And we had to be out constructor that took two expressions of ends and return an expression of is right.
7:12
So crucially, the GDP notation allows us to specify the type of the individual constructors.
7:20
So each has a distinct type from each string because each string is an expression that holds the string any into the expression that holds an end.
7:29
And so adding two expressions only makes sense when those expressions are in themselves.
7:39
So in particular, and he adds, each string a string B is using.
7:45
This, of course, does not Typekit because we get this type R.S. expecting a string.
7:55
So that's that's what it gave us a couple of weeks ago now.
8:05
In this particular example. We used the GDP feature in a very particular way,
8:11
which is to say our constructors held a value and then the GDP was indexed by the by the same time that
8:19
the value was so the end of the infrastructure holds an end and then the expression is indexed by an end.
8:30
String holds a string and the expression is indexed by a string. But it's not.
8:40
This is not it doesn't have to be this way. We can index. Our GDP is by types other than what they actually can.
8:44
So to see an example of this, I'm going to implement.
8:53
First, I'm just going to imply that the normal this data structure that we all know and love.
8:58
But using a GDP notation. So so far, this is the standard list.
9:06
Let's use this for the coins. So you take an area with of today's today's surveys and we return a list of.
9:12
OK. And I want to make sure that it has the same sex.
9:23
It is normal coins so we can write things like one, two three.
9:28
OK. To load this, you forgetting to do that?
9:36
And that is what we just constructed the list and it is a list of numbers.
9:42
So. So that's fine. Now, so far, what I what I did here is just implement this.
9:49
This is the same as the built in list, but using a GDP like syntax.
9:56
Now, you know, one issue with built in list is functions like the heads function, for example, is unsafe.
10:01
What do I mean by that? Well, you know, you have some List X cons.
10:10
Actually, it's actually you don't need to tell. And in that case, pattern matching the list return in the heads, that's fine.
10:15
But we get a warning here because of course, we didn't match all the patterns and in particular, the matching would be missing the nil pattern.
10:23
So what do we do when we're given the empty list? Well, the only thing you can do is throw an error, right?
10:33
Because there's no way to Magikarp an element a from an empty list.
10:40
So you.
10:46
So that's this shortcoming of this is actually something that we can improve upon using GTD just to prove to you that it actually does lead to issues.
10:48
You know, the list contains no one we can return it test.
10:59
But the doing the same for the empty list. There was an exception.
11:06
So, so as. Now let's let's tweak this definition of a list a little bit.
11:11
And what I'm going to do is add an index to the constructors that specifies whether the list is empty or not.
11:18
So if you look here in the expression type here where we index the.
11:28
Constructors by the type of the value that the constructor contained, so contained in end E string contained the string.
11:33
What we're going to do here is slightly different and I'll introduce a new index of 40, which represents whether the list is empty or not.
11:43
So what do we put four nil? But we need to put some concrete type here.
11:54
And actually, for this purpose, I'm going to introduce to two types empty and non-policy.
12:00
And the way to think about these data type definitions.
12:08
You notice that there's no right hand side. There's no actual definition.
12:12
I didn't put anything. I didn't put an equal sign.
12:16
So these are just empty data type declarations, which means that they don't actually have any value level inhabitants.
12:18
There's no value type empty, except for undefined, of course,
12:24
but there's no meaningful value of type empty and there's no meaningful value of Typekit on empty.
12:27
These two types exist solely for the purpose of. Being used as type indices now, we can actually I can actually show you what that means.
12:32
So the the Nil constructor constructs a list that is empty.
12:41
OK, so it's a list of that. It's a list that holds elements of type a, but it's an end to this.
12:47
Now the Cons Constructor takes a list and it doesn't care about whether the list is empty or not.
12:57
So we can put a tidy variable there, which means this can be used for lists that are either empty or not empty,
13:03
but because there is an element here actually constructs unknown entities.
13:10
OK. So again, the empty the nil constructor to construct them to list the columns constructor takes an element.
13:16
Some list which may or may not be empty and it constructs are not empty list.
13:25
So as you can see this, this type of indexing is a little bit different from what we have before because the expression,
13:29
language and the element contain was the same as the index.
13:35
But here the element contained is actually or rather empty and have no relation to the type of the elements.
13:40
They have some other semantic meaning that relates to the structure of our lists.
13:49
In particular, the indices represent whether the recipients are also in of waffling.
13:55
Let's see how we can fix up the function. So of course, it doesn't Typekit now because it expects an extra type parameter.
14:02
And if you think about it well, the head function only makes sense, not empty lists.
14:10
So let's say that we only take note empty lists. I load this into GC.
14:15
I get a warning here saying that the pattern much is now redundant.
14:21
The line 20. Why is it redundant? Well, it's redundant because it's impossible.
14:24
For this to be new, because the type says that we're taking known activists and the new construct to construct an empty list,
14:32
so it's impossible to call this function with an empty list and therefore it is too much is
14:40
redundant and Jesse rightfully tells us some greater comment is out and they'll reload.
14:44
Not happy with that.
14:53
So if I call head now on, you know, the same recipe for still works as expected, but calling it on on an empty list is actually a typo or now.
14:56
So this is the kind of the first example of a less data type that supports a little.
15:11
More rich type information than than the big built in one thinks they're using GDP here.
15:18
So we took this known activist stuff guarantees that we cannot use head in an unsafe way.
15:27
But actually, I'm sorry. Can I ask a question? Oh, of course, go for it.
15:38
Okay, so with you encountering that he is either an empty or not A.
15:43
So is there a way we can make a Typekit other two or not to?
15:49
Yes. OK. Yeah. So it's a good question.
15:58
The question was, you know, I said, that is going to be either enter, not empty, but nothing is really stopping us from constructing the type.
16:02
You know, bad list of I don't know.
16:13
Spring is right now, so, so specifically the type variable here is inhabited by.
16:18
By something other than empty or not empty, because, you know, it's just a type variable.
16:31
An empty and not empty archives we can actually put in any time they're not just not just into not empty.
16:36
So that's a little bit unsatisfactory.
16:44
It's actually not possible to construct a value of this type because the only the two constructors that exist construct only empties and nonentities.
16:47
And so there's no constructor that would give us a list of this type, but nevertheless it's possible to write down this type together around this.
16:57
We can actually make this a little bit more safe, safe and and use a new language extension.
17:05
The idea here is that really what we want to restrict. We want to say that this can cannot be any arbitrary type.
17:14
It can only be either internal A. So what we want to do is create a data type is empty and give it to constructors empty or not empty.
17:21
OK, so this is an ordinary data type declaration.
17:34
But now and thanks, and we're going to use another extension, which is called data case.
17:39
So basically, it is a very simple extension, but it is very, very powerful.
17:46
What it allows us to do is go to comment things out.
17:50
What it allows us to do is allows us to use these data,
17:55
these data constructors as types themselves so they can actually come in here and say that this is is empty.
18:00
And in order to be able to write this down,
18:11
I'm going to need all the time signatures and I'm not going to spend too much time talking about the current system of Haskell.
18:13
It's also a very interesting topic. And maybe, maybe we'll talk about the kinds more in depth at a later session.
18:22
But for now, the idea is that using these using this fancy kind system stuff,
18:30
we can see we can restrict what type variables we can restrict the types of type
18:38
variables to now empty and not empty or still fine because the construct is empty type.
18:43
So these are fine, but now we're getting a typewriter here.
18:54
Expecting something of these empty posturing has kind star, and if you haven't seen the kind of star before, it's fine.
18:57
It just stands for an ordinary type and the ordinary high school type and not out, isn't it?
19:03
Not an internal MPR special types because they're constructed in from from these values?
19:08
And so this is no longer valid. So to answer your question, yes, it was bad, but now it's going to be a very good question.
19:17
OK, so. So, so that's cool, but.
19:26
The issue here is that. You know, you haven't gone good at something as well.
19:36
Yeah, I I'm confused, so what happens if you don't write that language, the syntax at the top?
19:44
I feel like I can still do this without without the G.O.A.T. Like I can do this in my programme was the if you if you turn off the 80s.
19:52
Yeah. Well, first of all, you're going to get a bunch of errors saying you have an illegal generalised algebraic subluxation list.
20:02
Specifically, we're constructing a data database here. Who's who's constructors have.
20:12
Specialised our associations for the type index, which is not possible without the 80s extension,
20:21
if you can, if you can do this in your programme with geniuses,
20:31
maybe we can take that offline that question because it might be that you have got to enable somewhere on your global GC icon or something.
20:33
And yet it will.
20:43
What could you just repeat that last line? They enable the.
20:47
No, sorry, I was saying it might be the case that you have some global JCI config on your system that enables duties,
20:53
and that might be way worse for you, I don't know. But it's definitely not possible with it without utilities and writing this data tied down.
20:59
And so I still have questions. So if we use data carriers for us asked, I use two of us to.
21:12
Yes. Yes. Yes. Yeah. So the question was what data kinds can we use?
21:21
Billions instead of this is empty because if you think about it truly is our are defined in this way, maybe what comes first?
21:27
The new keyboard and buttons are slightly different positions.
21:37
OK, so this is how good is the fine. But of course, it's already defined.
21:40
Can we just use bull? And the answer is yes, we can. I'll just say to our list MP is OK.
21:45
So whether it's empty or not, it's I guess it's true for empty and false or not empty.
21:53
And then in head, we just say we want a non end to this and it works in the exact same way as before.
22:00
But the, you know, using Boolean is not that nice because now the error says couldn't match like true with false,
22:12
which doesn't have a lot of you know those are the same meaning. So this is more of a personal choice.
22:18
But when I define these types myself, I tend I like to go with more specialised data science to tell you something about these.
22:24
Some people call this Boolean blindness when you use Boolean for everything and kind of lose track of what the true and false values mean.
22:35
And a good way to avoid that is to use domain specific types.
22:46
Even if you know you have to write out some boilerplate to new type state pays off
22:51
because it's easier to keep track of the semantic meaning of your of your programmes.
22:56
Now. OK, I.
23:03
Any more questions about about this or are you have to move on?
23:10
OK. In which case let's. I'm really glad to.
23:18
I'm really happy about these questions, actually, because it's specifically this in question.
23:25
It's quite quite relevant to what we're going to be doing next because, you know, there are several avenues to take from here.
23:31
We can. You know, if you just pause here for a second and look at this list, they decide it's kind of a.
23:40
You know, it hasn't, as it's a one trick pony. It can do one thing we can do this we've had, but it starts to break down because, you know,
23:51
you only know whether the list is not empty, but when you take it, when you take out the tail end of this, you lose information.
24:01
You know, you no longer know whether the tail is empty or not, and you have no way of recovering that information because the pipe simply.
24:08
It's it's, you know, look at the the type of this list, not A. A.
24:19
You have absolutely no information about whether the thing contained inside is exempt or not.
24:25
And actually, if you try to write the tail function list on a non empty list, what should it be?
24:30
Well, we currently write list. B.
24:41
A because it would mean that in the long term, this can produce a list of an arbitrary emptiness, arbitrary meaning it could be empty, not empty.
24:45
That doesn't work because the the the list contained this side has a specific emptiness.
24:55
So but it's not it's not, you know, you get this cryptic error message saying, Oh,
25:03
could match type e one with it's because X is the list X is is is has some emptiness.
25:15
E one we're saying has to be E and those two things don't match up.
25:21
And it's, you know, you could get into the whole of the unification algorithm works, but it's figured this out.
25:26
But long story short, we can't instantiate this.
25:34
This is the sort of it's called an existential variable. And this is a universal, universally quantified variable.
25:39
So we can't say that this works for all we use when in reality, there's only one specific E, which we don't know.
25:44
In order to write function, you actually have to first write to this function, and this is to list for and to be unrealistic returns.
25:53
The emptiness for non lest we get X on this list axis and then we the tail function can only return irregularly for forget the emptiness information.
26:06
So this is not about satisfactory because now they are trying, you know, it doesn't work on the empty list still.
26:27
So that's good. But in order to extract the tail of another list, we have to resort to going back to regular list territory.
26:33
And you know, it's a little bit unfortunate because as we know, we lost that information of the of emptiness.
26:43
So the next logical step here would be to say, OK, well, instead of tracking whether the list is empty or not,
26:51
we'll actually we'll actually track the length of the list.
26:59
OK, so sometimes it is called the vector.
27:05
Actually, if you just go back and modify the existing data type, I don't have to totally new names.
27:10
So instead of is empty, we'll create a new data type called Map.
27:16
So this is supposed to represent natural numbers. We have a constructor for zero and the constructor for the successor of an actual number.
27:23
All right. So this is sometimes called a serial number.
27:32
So these are numbers zero and then we keep adding want one to another number so we can generate all natural numbers in this way.
27:38
So it will instead index our list by a natural number, then the Nil constructor will be will have range from zero and the columns constructor
27:48
will now take a list of names n and give us back a list of length and +1.
27:59
So remember that X represents the successor of a number, so X of five is six.
28:05
OK, now the head function takes.
28:14
How do we how do we say a list is not empty? Well, we just say that the length of the list must be the successor of some natural number.
28:20
So successor of end for arbitrary end.
28:27
And specifically, the smallest number of this can be zero because sources said is zero.
28:31
Because the successor? Sorry. That is one. OK.
28:38
And the smallest number and can be zero the smallest number of successor and can be one.
28:42
That's what I meant to say. And so that's good now that it's removed this to this function.
28:47
So the tail function now says, OK, give me a list of names and +1, and I'll give you back a list of names and you just do this now.
28:58
So actually works. And the reason this works is because now the type of the list is rich enough to specify that there is
29:10
enough information at the top of the list to tell what the type of the tail of the list is to previously,
29:22
when he was just sort of a Boolean value and not empty that didn't have enough structure
29:28
in it to tell us what the type of the tail is or what the length of the tail is.
29:33
But now we do, because it's because the list, the length of the list is kind of inductively building up, using the the tail of the list at each.
29:38
At each course, constructor. So that's true.
29:51
Yeah, go for it. So, Corey, yes, you need to do that instead of use our natural no representation.
29:58
Can we use it? OK, so the question is because before we could use a type pool and that was fine, we could just use it in a can we use it as well?
30:07
And the unfortunate answer is, no, we can't. And that only has technical reasons.
30:16
So every type can be every type as defined inductively.
30:22
And by inductively, I mean, you know, data pool is defined by a set of constructors, you know,
30:29
etc. So basically, every algebraic slide can be used in the types, but it is not defined in this way.
30:37
It is not defined by enumerating all the possible numbers.
30:44
Actually, you know, you would have to start from many bounds anyway,
30:50
so it is not defined then in this algebraic way, it is a built in primitive number that exists.
30:56
There is actually a way to divide the number of five into types,
31:05
but I'm not going to go into that because Typekit arithmetic is a little bit annoying to deal with,
31:15
and it's something we can maybe look into the next session.
31:22
To how we can do interesting computations on type level numerals and things of that nature, but for now,
31:30
I'm just going to say that we can't use ends, but there is kind of a way to still use it in types.
31:38
Oh, I see. So for data can when must make it look like they take a tool like construct or construct it?
31:44
Yeah. Yes. Even if we used to construct a recount, something like that, remember, it's not.
31:53
No, and we can't walk into it.
31:59
Yeah, exactly. Yeah, yeah. So so yeah.
32:03
So the promotion criteria is applied recursively to the types.
32:07
But what I mean is a data pool can be promoted if it consists of, you know,
32:12
I can put pool here and this constructor because boys promotable, but it can't print because it is not promotable, right?
32:17
So I say thank you. Yeah, it's very good question.
32:25
OK. So let's yeah, let's just use this tale on a couple of examples just to show you that actually works.
32:30
So tail on the empty list is still no way to load this first completely data.
32:38
OK, so prime on the this doesn't work because we expected the list that has a little bit more expected to this.
32:46
That's that has at least one, but we got a list of length zero.
32:55
And you see these text in front of the constructor names. In the other messages, it's, you know, it's a good practise.
33:01
That's how there's a way to signal to GC that actually we really want these.
33:07
This s to mean the promoted constructor s and I could put the tick in front of it, which will mean that.
33:13
But if there's no ambiguity there's no other capital s in scope, then Jason knows what it means.
33:19
So just to read that for now, but OK, so that's that works in some sense.
33:25
That's my favourite example with these, these GDP's, my favourite examples, the ones that don't compile because the ones that do you know,
33:35
who likes, who likes programmes that you can actually run a tail prion one, too?
33:46
Now let's find annoyingly too polymorphic.
33:52
I'll just say I want to do it. OK, so we got a list.
33:57
Of length. Oh, yeah, sorry, the tail on the tail of.
34:05
The list want to nail house type list, end of length one.
34:14
And there's no way to show this to me because it doesn't have a show instance, but I can get the tail of that last one to the head of the tail.
34:21
I want to nail. And that's that works as expected.
34:38
And if I try to do it again, so do another tail.
34:43
Oh, OK, we can't do that because the tail of that tail is an emptiness.
34:53
Right? So it's the it's the list and then zero, so you can no longer access its head virtually.
34:58
Now we did exactly what we set out to do would be non empty lists,
35:06
but I actually promise to you that we'll have lists that can contain elements of
35:14
arbitrary types and specifically different types of elements of different types.
35:23
So that's going to be the next item on our list. OK, so let's think about this for a second, because so far we have homogeneous lists.
35:29
So we only had, you know, list that contained elements of the same type and RJD two indices were used to.
35:43
They used to give us the information about the length of the list and.
35:52
What we want to do in order to support a heterogeneous list is to somehow have our type index.
36:00
Represented not only the length of the list, but also the the types of the elements of the list at each location.
36:07
So what we really need if you if you think about it, what should be the type of the list?
36:18
One falls hello.
36:25
That was the example I used in the JavaScript council and then above the list.
36:30
What should be the type of this? Well, should be a list of.
36:35
And then we, you know. It's a list of length one, two, three four.
36:39
OK. But knowing that the length of this is four is not enough, we actually want to have information about the fact that the first element is an.
36:45
The second element is a ball. So we kind of wanted one to say it.
36:56
So this two were the first element is an end. The second element is a ball.
37:00
The third element is a strange and the fourth element is a list of events.
37:05
Right. This is kind of what we want to say. That's it.
37:10
We want to see a list indexed by another list.
37:15
But this time a tight lipped list and, you know, because lists are written as an algebraic data type,
37:20
so they're defined something like, you know, the empty list or the Coins constructor, which takes a list and the list is something.
37:28
This is kind of how lists are defined. Of course, this is invalid syntax.
37:41
So the actual lists are defined, they're wired into GC, but morally this is how they're defined.
37:45
So because they're defined in this way, it turns out we can actually.
37:53
We can actually write down lists and types using the data kind of data kind of extension.
37:59
So let's do that. And remember what I said, what I said earlier about the type of types.
38:07
So that was the type of end and the type of ball, that type of string. And I said, or specifically, I didn't say that the GHC,
38:15
I said that these things have kind of starts to kind of start is that is the type of of a type of regular type in housekeeping staff,
38:21
full house kind of start. But you know, Coles has it's annoyingly as to enable the extension separately.
38:33
But it forces kind of. OK, so this is kind of the and kind I command is the type level equivalent of the column type command.
38:46
So the the value falls has to. You know, it's like this is the full version.
38:58
So the value falls house type ball. But when you use force in a tight context, then that kind of falls, you're trying.
39:04
So I guess you might want to try quote false. So give the kind of quote false and the type of quote false.
39:16
Oh yeah. Uh, so like I said earlier, you can put the quote to signify that you actually mean the promoted version of false.
39:22
I mean, you could try to do the same, some type of false. It'll be a sin.
39:31
But I think. Yeah, because in the value context, the crow doesn't mean anything owning a Typekit index, so they could be fully honest.
39:35
You want to be saying quote false, which is the promoted version, of course.
39:47
OK, so when I was trying to say about this is we can actually write down.
39:52
So, but so can we use something like a native list of star?
39:58
Uh huh. For to list. Yes. So what's the kind of in the spring and then the list of things in order to make sure that GC knows that?
40:06
I'm talking about the promoted list here. I'm going to put the tick was the kind of box and it says the kind of that is a list of star.
40:23
So this is a type level list now. And to answer your question, yes, we can.
40:31
And now, if you think about it previously, we have these two indices for one, for the length of the list and the other for the element of the list.
40:39
Now you actually only need one index, which is the the list that represents the elements in the in the list.
40:47
So you can replace this whole thing with what's called an ace and it's the list of stars or list of types.
40:56
Now let's rewrite the individual constructors, so the Nail Constructor will now have the index list.
41:05
So I use a pick here. And so this is the first example where we do need to take.
41:13
We could just actually call an disambiguate between the empty list type constructor.
41:19
Sorry, the list type constructor and the promoted empty list constructor.
41:25
So this is a little bit of a technicality, but we have to put the the code here and and through the other case,
41:29
what we do is we take a list of A's, so this can be a list.
41:37
So we take a value of like eight. We take a list of A's and in particular, we know this is going to be a type of a list of types.
41:43
So it's a list of types. And finally, we construct the what comes out of this is a list a second and let me put the quotes in as well.
41:52
Here a conveys. Now, Jesse will be winging here because we need yet another extension cord to tape operators,
42:05
and so we need to add that to the top of the file type operators is a very simple extension.
42:19
It basically allows us to use the operator syntax in types.
42:25
So specifically, it allows us to use things like the colon constructor in a type and arbitrary operators as well.
42:32
So with that out of the way, now we have a data structure that's indexed by the types of the elements that it contains.
42:40
So specifically, the list is a list of types,
42:52
because the Columns Constructor is a list of types where icons on the new elements tied to the the list of the tail,
42:56
the the type, the list of types that represents the types contained in the table, the list.
43:08
OK, so now we only need what we need to this fix of the header function of the.
43:16
So let's let's think about this. What does head look like?
43:21
OK, so we need to take a title of a list. And when we know that because we're extracting an element, we want to take a non empty list.
43:25
So this is some list with a causeways. So this is a non empty list and we extracted the first element.
43:35
And similar to how it is before, of course, the The Nail Constructor is still redundant because it's impossible to call ahead
43:42
with an empty list because we do this pattern much on the type here we say we can,
43:50
we only take a list that has a non empty list of types.
43:56
So it has to be constructed with the icons. And the only way to get that there is by using the columns constructor.
44:01
So the constructor won't. Be accepted in this function, so we don't have to go to safe head function and the tail function.
44:07
There's a little more interesting with take a Acorns AIDS and we return, what do we return here?
44:18
Any anyone wants to guess? Was the type of the table, the list?
44:28
The list of us. Exactly, yeah.
44:40
So we had to list eight of those and we were 10 list of AIDS, and we didn't even have to train the types of or any of the definitions here because,
44:44
you know, the functions do the same exact things as they did before.
44:54
All we did throughout this four of these iterations is refined, the type refined that the type of the structure, the actual values are the same.
44:58
So what does that give us now? Let's, you know, create a list.
45:11
What was the mistake made in JavaScript? I call the list.
45:16
Why? So let's put this in, and of course, we can't use the list syntax.
45:22
So let's say one false hello, and this is going to be another heterogeneous list.
45:32
So one to another strength.
45:43
Then comes the milk and then finally comes the middle. And that's enough for the type of this.
45:48
And that's the type. And let's do some computations on this.
45:55
Let's get the heads up. It's a little bit again.
46:03
Of course, said the head of that list.
46:07
So that is one type of the head is integer.
46:12
So that means we can and tend to it just like before.
46:18
Now what if we take the head of the tail of the list?
46:24
We'll get a Boolean. So now if we try and tend to that we actually get a tighter because there's no known instance for billions.
46:30
If there was, this would be fine.
46:40
But we can actually we we can actually, you know, because the reason you can add in JavaScript when you say force was 10,
46:43
the reason that resource to computing 10 is because we didn't really have any other choice.
46:51
They wanted to reduce the number of times the system throws undefined, so they set it arbitrarily.
46:58
They said, OK, let's interpret false as zero. It's kind of an arbitrary choice that they have to do because they didn't have Spotify checking,
47:03
but we don't have to do it because we know that the our list is safe.
47:10
Well, but we can do we can do Boolean stuff with it.
47:17
So I can say, you know, I'm true because we know it's statically.
47:21
No, it's a Boolean. Look at this and let's keep going the next element.
47:26
What was the next element? It was trying.
47:36
Let's see that it was a string so we can append to it, you know, and then the next element, I think, was another list.
47:39
Yeah. So we can actually take the head of that list and you get the idea.
47:54
And it could be caught in the wrong place.
48:02
And you can keep playing this game. The idea is that with this heterogeneous this structure.
48:07
We have a Typekit way of holding heterogeneous type information, and we can have our cake and eat it too,
48:14
because we didn't give up on type safety just so that we can support,
48:24
like more fancy or heterogeneous the architecture and whether it's useful or not.
48:31
You know, that's a separate question. I have used heterogeneous lists in production Haskell code bases before.
48:36
So there is some use I use for them, and they're particularly useful for representing.
48:43
Kind of. I think when you read of a road from a database, then the database, you know, the individual columns will have different types.
48:52
So heterogeneous lists can be useful for those types of operations because you just want to
49:02
read off a list of things and find them into the kind of just go with the star notation,
49:06
the star part again just quickly. Yeah.
49:11
So actually think the important piece of types is it necessary data about times they there's a synonym for a star,
49:16
which is called tight and it's the same exact thing. And so but of course, that's not what you're asking the question.
49:33
The question I, if I understand correctly, was What's this? What's this thing doing here?
49:44
What's the star? And I think I'll just use the name for it because they're synonymous.
49:48
Actually, Typekit defined to be a synonym for star and star is kind of being deprecated now because it looks odd.
49:52
It looks like it's in. It's an operator and it looks like multiplication, and it's a bit annoying to.
50:00
To explain and to understand as well, because it looks a little bit out of place,
50:11
but if I don't know if your question was about the syntax or about the actual meaning of of that thing, it's again.
50:16
The latter, OK, yeah, so yeah, that's my thought, so what does this mean?
50:28
So, you know, earlier we had the point where the list was indexed by is empty is empty and we said that is empty can be,
50:35
you know, one of these two things. And the reason it was possible to use empty and not empty in caves was because, you know,
50:46
data commons allows us to take an algebraic data type and promote it so that
50:54
the values can be used as indices to type in a GDP constructed specifically.
51:02
So the value empty from.
51:11
And, you know, if I just go back here, so the kind of deconstructed empty is empty and specifically, I'm asking for its kind.
51:16
So when I say pick empty, I don't. I mean, I really mean empty as a type, so I really mean empty as something that can go.
51:28
And as a as a as an investigator, you know, it's not it's not about it's not a runtime value, it's a compile time value, if you like.
51:39
It's a static survey that exists statically in the pipes.
51:49
And so the type of empty or sort of the kind of empty is empty.
51:53
And we saw how we can use or we can ask for the kind of falls and it's all similar in a similar way.
51:59
This is not the this is not the force that exists in a programme at runtime.
52:08
This is a compile time. This is a type level version of falls.
52:13
And so. So empty and falls are in this way types themselves.
52:18
Now we can ask for the kind of runtime things, you know, things that exist at runtime,
52:25
so what's the kind of ball and the kind of bullets star actually fingers extension that will say sorry.
52:30
So, so so you don't want to confuse you too much?
52:37
What this will do is sorry, I need to set it here as well.
52:42
I don't know what the. There's a way to print, actually.
52:50
We know that. No. Sorry. There you go.
52:55
Okay. So so when you ask for the kind of ordinary types they have type, so Bo has,
53:00
you know, five has Typekit, one has typing in has kind type and they can say that.
53:09
But I can ask what's the kind of age and its type?
53:17
So if we can ask what the kind of entries says type,
53:21
then we can just like how we could construct force at the type level and what was the one empty handed the Typekit?
53:24
Well, we can construct a list of these types for the puzzle.
53:33
This is another this is a little bit more.
53:38
It looks a little bit more involved because we're constructing a document defined data structure, but it's it's going to be a little bit.
53:41
This is just an ordinary list that exists at the top level, and it's kind is a list of types and that's what's happening here.
53:48
We're saying the heterogeneous list is a data structure that's indexed by a type of a list of types, specifically Typekit.
53:56
The lists are also polymorphic, so you can have you can't you can put in other things, you know, true or false.
54:06
Specifically, this is the true Boolean, the false Boolean.
54:12
And now this is it because I'm asking for the kind of this. This is a type of a list of Typekit of billions.
54:16
So the kind of that is a list of rules, and the apostrophe just involves those the static static dot.
54:22
Yeah, that's exactly. Yeah, that's exactly right. In this case, I don't have to put s because it's unambiguous.
54:30
GC knows that this is the only way, but there are. There are situations where it's actually ambiguous.
54:35
Like here, this is a list of things the ordinary list of things like the one two one two three four.
54:42
It's that. But I actually what if I want the single turn type of a list that contains the type H that I have to put the tick?
54:53
So this is one of the cases of ambiguity. Yeah.
55:04
I think that's that's it for today. I have to ask this question.
55:11
Yeah, sure. OK, so Kelly, considering the top story in the list,
55:16
so maybe we want to have something like the top of the hour, no different than like you a double or something.
55:22
Can we can we constrain the elements of the West so that there can only be nuns?
55:33
Yes, we can. There are multiple ways of doing this. I think one of them would be to require the nuns here.
55:40
But uh. And then this is giving this address later on.
55:48
Yeah, because yeah, because these all these have money.
55:56
That's one of the ways. But I think what you might be asking about is a more general way of restricting.
56:01
So maybe can we say this list can only contain Google as it ends or something like that?
56:07
So the answer to that as well is yes, that you can strain the lists in arbitrary ways.
56:14
And how to do that is outside of the scope of this lecture.
56:20
But I think we might have another slot in the next coming weeks where we can do more type of programming,
56:25
and they can then show other tricks of how how to achieve those kind of things
56:35
because our school type system actually has a Turing complete language in itself.
56:42
Well, I should say hospital type system is Turing complete, so we can we can encode a whole bunch of interesting computations.
56:49
And do we can we can even construct a list that can whose length must be a prime number and we can,
56:58
like statically verify that that's the only prime number of life lists are accepted and things like that.
57:06
So we can do we can do anything. OK, thank you, very good.
57:13
We get it. Thank you very much.
57:18
Thank you, John. Thanks. That's terrific. So we'll make a decision what to do next week.
57:23
We haven't decided yet. We'll have a chat about, you know? Yeah, yeah.
57:28
Just occurs to me from from today's lecture that there's a test.
57:32
I said a few years ago about decision trees and your comments about using type
57:36
level reasoning to build heterogeneous lists in the context of databases.
57:41
That's exactly what we'd have liked to have done in that exercise, but we obviously we don't cover that in the the vanilla version of the course.
57:45
But there's a little comment on the on my website about that. So there's a little thought experiment.
57:52
If you come to the decision trees, there is a revision exercise. Maybe you'd like to try to implement the database there using age lists.
57:57
All right. You know, thank you very much. So we'll see you again next week.
58:04
Yeah, thanks.
58:08