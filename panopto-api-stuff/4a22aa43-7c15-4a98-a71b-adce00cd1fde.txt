ID: 4a22aa43-7c15-4a98-a71b-adce00cd1fde
Title: Haskell catch-up-20211027_100230-Meeting Recording
Category: Haskell
Lecturer: Anthony Field
Date: 27/10/2021
OK, right, so who's got a question, who would like who would like me to go over something else,
0:11
something we've already covered, sorry, rather than something else? Marty, do you mind going through carrying impartial application again, please?
0:17
Sure. Right, so this is the question.
0:25
The question, this the question, this is how do I get another function?
0:33
How do I get a function to return another function as its result? And one way to do that is by partial application.
0:37
So what did I say? I said that if you look at the type of something like +.
0:45
Which is on the screen here, so we imagine it takes two arguments to introduce and terms a third,
0:52
and that actually what's actually happening is that it's a function that takes its two arguments, one at a time.
0:58
So the way to imagine is this is that plus X gives me the function, which adds X to sum.
1:06
So in other words, if I give the plus just this one in the X, say what I get back is a function of type two.
1:14
So think about that. So the function of intent is a function which given a Y, will add extra Y.
1:23
So if you like, you're kind of freezing to be put this on this on the air.
1:30
Let's just do it on the command line. So I've got plus and I. Not in scope.
1:35
OK, but in. So say plus serve X, Y is X plus Y, so that all right, so so I can say it just by getting it right.
1:40
But here's the idea.
1:59
So if I say plus a force, which is I think the example I had on the slide, that is a perfectly meaningful thing if I'll put brackets round it.
2:00
In fact, I'll tell you what, I'll name it plus four is the function, but I don't need the brackets if I'm going to to name it.
2:11
Let's take the brackets out. So plus four is a function.
2:18
The function plus four without the space is a function which will add four to any given event.
2:21
And I can tell that by well in fact perhaps if I go up here and actually put the tile because I don't want the type classes just yet.
2:27
So also the plus takes the minutes and another end and it generates another hint.
2:33
All right. So I can say so that's a plus four is plus four is the function, which adds four to things.
2:43
So I can take the function plus four and I can give it eight and it will give me 12 plus four plus four.
2:49
I'll give it nine. Maybe let me I should choose a different name because maybe you should call P for just a moment just
2:57
to show you that it's so I can say P four is the function which given a number will add four to it.
3:04
So if you like the the act of partially applying plus the four gives me back a function whether the four is now frozen in time and space.
3:11
So that function is expecting one other end, because I've given it one expecting 100, and it's simply going to add the fourth to the unknown.
3:19
So so what is the type of that maybe we should look at the type of plus for people?
3:28
That's a function that you want it now because the type of plus expected to.
3:34
So I've given it one of the there's only one left.
3:38
So the idea is what actually happens is that although it looks like, you know, when I say plus seven,
3:41
eight, seven, given the function, what's actually happening, it's been given those organs one at a time.
3:46
So the plus seven freezes the seven now. Okay, you give me an eight and I'll add the seven to the eight.
3:52
So so that's the carrying story. Well, that's the part of that story.
3:59
And encouraging while carrying is the act of thinking of multi argument functions is actually being functions to take their arguments one at a time.
4:04
So if I've got a three argument function. Let's much enrich this a little bit, um.
4:13
So that's a three argument function and maybe this adds them all together, right?
4:22
We lowered the bar. So now so just to confirm what is the type of plus well, plus is now a three argument plus.
4:32
So well let's see so I can name the function. Guess do it again.
4:40
P4 is plus four. OK, so that is a function which was.
4:45
Well what's the type of.
4:52
People, the type of people, OK, that's now because I've given it his first and is now a function expecting to Morant's but one at a time,
4:54
and that will finally give me an end. So P4 if you like freesias.
5:02
Well, let's have another one. Let's say sleep for five days.
5:06
That's P for applied to five. So now that's a function which has got both the four and the five if you like.
5:10
And what's its type P for five. That's a function which is not expecting one more and then it will add the four and the five to the given int.
5:19
Give me the results as a P four five seven. Elad the four and five five the seven.
5:27
Give me this. Give me sixteen. So so it doesnt matter how many arguments are given, how many errors have got into and eight B to C to do to have.
5:31
It doesn't matter whether it functions polymorphic or ground,
5:38
it doesn't matter if I can in Haskell you're essentially giving the argument one at a time.
5:40
So once you've got a function like people buy, well, in fact, yeah, let's look at P45, what was its type again?
5:47
People five was a function of two. So I can I can I can I can pass that round.
5:55
So, in fact, I can map it for people five over one, two, three, and that'll add,
6:02
well, P45 is essentially the function that adds nine to things, isn't it?
6:07
Now that we've got both the four and the five. So so don't give me nine plus one.
6:11
Interesting. Number three one. So. So once I've defined these functions, what's what's up?
6:15
Once I've constructed a partial application, it is a function. Therefore I can pass that function around just as if I can pass anything else
6:18
around and I can make them feel to them whatever I whatever I want to do.
6:24
And here's an interesting fact. You might think, well, okay, what about before what was the type of P4?
6:28
Well, that was a function expecting to int's one at a time.
6:34
So you might think, what can I map that function? Over one, two, three.
6:39
And the answer is you can it will object because it can't print that.
6:46
But what is what is actually constructing? Can you see what's happening?
6:51
What is P4? This is the same as if I had written for one.
6:56
He fought to be four, three,
7:03
so that's the application of people to one with the application of people to one will give up for one of its remaining Turin's.
7:07
But that's so what is the type, for example, P4 of one that is a function expecting one more so people one is itself a function,
7:16
expecting one more end, which will add, but when it was four to four, we had nine to that end.
7:26
OK, so this expression here. Is actually going to generate a list of functions.
7:32
And what a terrifying thought, but don't worry, you know, if I can have a list of events,
7:38
you're happy with the booleans, you're happy with that list of chores, you're happy with that list of functions.
7:43
What's the problem? It's just a list of functions mean when you think, what can I do with that list of functions?
7:48
Well, let's have a little play. Supposing I take supposing I name that list of functions so it lists the functions FS say and I name it.
7:54
Well supposing I pull out the first index one which is going to be the.
8:04
What is what is that. That's P four point two isn't it. So because people epso zero is P for applied to one.
8:11
Episode one is before applied to, too, and two people applied to three, so let's just randomly pull out that one.
8:19
So that is P for applied to two. So if I take that function.
8:25
I'll tell you what, let's name it, you just have a little play, let's call that well, imagine what is it?
8:32
This is before I call P for two.
8:40
So now I've named the function, which is the application of P. 42, which is the second element of the list of functions I've just shown you.
8:46
Well, what is the type of that will it should be into and shouldn't it? Because it's now got the four, the two that it's about in one way.
8:52
So I can take people to give it seven and that pops up so well.
8:59
The other work I can do it. I can directly index my list.
9:03
Look, tidy this up on this poster so that we know is a function of time into it.
9:09
So I can give up. It's exactly the same thing that you see is their way of.
9:15
So let's say we don't we don't know why is. But we have that.
9:21
We already put X and Z. Is there any way to, like, skip the.
9:25
The Y oh, that's a good question. So your question is, can I say I've got a function F, X, Y?
9:30
X, Y, Z, say, yeah, and you're saying, oh, yeah, it is it is it is the case, the application you have to go left to right.
9:38
So it's a partial application backed by only a partial application of F to X and Y will bind the court to one to to bind the X and Y.
9:46
So yes, it's a result of what you might say, well is it possible to bind the X in the Z can be a function that is expecting the Y?
9:55
Well, you you can't do that by partial application and.
10:04
But I mean, there, there, there there are ways of doing it.
10:11
So what do we want? We want to function, which given to arguments.
10:14
So I could do I could use a Landro expression type of thing when I can do it here and say,
10:18
let gee, I have a good history, I've got one school plus so I can say let's g- equal plus no.
10:23
So let them start again. So I want to function, which given two arguments, let's say the X and the Z.
10:31
Will partially apply, will apply there, but can do something like this, I can say plus of well I can say no, I don't suppose I can do it.
10:41
Like I say, this is a function of why this is my anonymous function that will do plus of X or Y, Z, so I can do it that way.
10:50
So G is now a function of expecting to arguments that he can play those sorts of games.
11:04
And then I can say, well, I can give you the one in the full name that I say, and then I can say, well OK, give me a straight say.
11:11
So that should. But of course it's my it's the scientific community is not very interesting.
11:21
But nonetheless, the the thing has has is, is it is a partial application of plus which binds the X and the Z.
11:26
But it's missing the water by virtue of this this land here.
11:34
Yeah, there's various ways you can do it, you can have a name, a function, you can use anonymous function.
11:39
So. Good to be.
11:45
I was the to just an anonymous function, so if I say something like Lambda X, R, X plus one, that is that is the successful function.
11:52
It's just so so I can say that and I can give it.
12:04
Nine, and it's just just an unnamed it's an anonymous unnamed function, but it is nonetheless a function.
12:12
So it is an expression actually it's an expression which builds a function.
12:19
And if I got expression, which was a function, then I can apply that by juxtaposing it with an argument.
12:22
So the other way to do that is to name names.
12:27
I can say something like I'm either left or just without the letter and say it's OK to let F or what should I call it, the successor function.
12:28
Successor equal. The success of X equals X plus one, we've seen this before.
12:38
Well, that's a that's that's actually naming a function so I can do nine.
12:44
So the advantage of a lambda expression,
12:49
you can always avoid lambda expressions by defining an auxiliary helper function and naming it the successor of X as X plus one.
12:52
But if you just want a bang, I just want to function as one to think you can just wrap it up and use the expression so lambdas you can generalise.
13:00
It's a lambda, x, y, z to function under X, Y, Z to argument function say.
13:08
So what should we get it to do. X plus Y minus eight or something like that.
13:14
Well that's, it's complaining. It can't print it because it doesn't have a print function, but I can wrap that in brackets for example.
13:20
So that is now a function of two arguments. So I can give it a five and a three for example.
13:27
That would be five plus three minus eight. Which is zero.
13:32
Of course, I can partially apply that function.
13:37
So that is now a function which has got the X because I found the X to the five, but it's now expecting the Y.
13:39
So that's therefore a function of A2A for some some some number type A.
13:46
Yeah. So it's just a way of defining a function without having to name it.
13:52
And you know how difficult it is to come up with good names for things.
13:58
Good, good questions, and he what's the next question to put your hand up, I've got a question.
14:03
Session. Could we go over how to use tax again?
14:11
Yes, tax, yeah, as in the Saxon's to implement like using those as an alternative to like Miccosukee because I'm a bit confused about that.
14:17
Oh, do you mean this week's lab exercise?
14:32
I mean it just like from a completely general point of view, just the basic theory, not like anything specific to it, like it is too specific.
14:35
Then I am happy to ask a different question.
14:46
I suppose the long answer that does anything ask me a different question or it in the back of my head while you ask me the question.
14:50
OK, we quickly go over the basics of triste again from yesterday.
15:01
Yeah, I find the slides.
15:08
So this is something you'll be doing next week.
15:14
So so as I said to you yesterday, trees are just generalisations of lists with a binary branch structure rather than an ordinary branching structure.
15:20
And I guess the thing to understand is why we bother to have trees.
15:31
What's wrong with lists for the top of the list is that if I if, for example,
15:36
I'm using the list as a mechanism for storing things and I want to know I want to,
15:41
for example, is this item an element of this list or if it's a table, is this key is is there a key?
15:47
Is there is there a binding for this key in this table?
15:53
If I represent is a list, I've got to trundle down the list from left to right there to ask the question,
15:56
ask the question so that that is the cost of that in the worst case is, is exactly the length of the list.
16:01
So in the worst case, I may have to travel all the way to the end of the list. And the thing I'm looking for is right at the very end.
16:08
So if there are any items stored in the list, the cost of a lookup is the will of the will remain.
16:13
And on average, it's going to be halfway down the list unless I know something about the list.
16:19
Well, that's still an order in computation, isn't it? Because number two is the dominant factor is the end, even though it's divided by two.
16:23
So people thought about is there a better way to do things, play the sort of game,
16:31
particularly for things like searching, searching and sorting problems.
16:35
And so trees attempt to solve that problem by making the observation that I can store any items in a way
16:40
that the distance between the root of the tree and any one of those items isn't most log in rather than n.
16:49
So if I could provide it, of course I can get a can produce a perfectly balanced tree.
16:55
So here is a perfectly balanced tree with seven nodes and eight leaves.
16:59
So I can store that, I can store items in the nodes just as I do the list,
17:05
or I can store them in the leaves or I can store them in both the nodes and the leaves.
17:09
But the point being that if I if I'm if I have to if if it's possible to search the structure,
17:15
particularly if I've got an auditory, then the most I have to travel from the root to to any item is log in, not end.
17:21
And that's why they're really exciting because they massively speed up problems.
17:29
But you've got very large data sets and you've got lots of searching and sorting.
17:34
Going or sorting is a related problem, lots of searching going on and the searching can happen in log in time rather than linear time.
17:38
So the right path. But of course the trick is to guarantee this log logarithmic property.
17:45
You need to have balanced trees. So what we discussed yesterday, I didn't I didn't attempt to complicate the balanced trees.
17:49
I just was talking about the data type itself. And there are lots of clever algorithms that you'll come across very shortly, in fact,
17:55
which are all about producing balanced trees rather than just arbitrary trees.
18:02
Because the degenerate tree, of course, is just a list chain of chain of nodes with empty trees hanging off one side.
18:07
So I don't know if that's that.
18:14
There's that's the principle of trees that I don't know whether that was your sticking point or what do you want me to go over how they represented?
18:15
Like, we can go through the any bit more quickly if you want to.
18:25
I just want, like a whistle stop tour really. I don't want to take too much time, but just like, you know, it's it's worth it.
18:29
And again, you this will sink in next week, so I won't spend too much time on it.
18:35
So they all you have to remember is that you can define your own data types because data types,
18:39
because clearly this is a recursive data type, because a node in the tree has two arguments.
18:44
Swaptree, the item, it's stored in the tree, the item inside the circle. And of course, two substories.
18:51
Well, those secretaries are themselves tree. So that is implicitly a recursive, inherently recursive data type.
18:55
So you can do things like this, you can say, well, here's a recursive data type. I call it tree because why not?
19:00
And I want to store items of obviously toxo polymorphic. That's what we looked at yesterday.
19:05
I just I know you're doing is copying the diagram. So there's that is little black things which are empty trees.
19:11
So the only to construct is I need to build a tree or empty trees and nodes, say, oh, well, there's an empty tree.
19:15
Constructor doesn't have any parameters, at least in this data type we could do,
19:21
or it's a node what is a no deal and no glues together an item with two separate and there's the recursive bit happening.
19:27
So left and right substories, obviously trees are ways of the tree itself is a tree that and once you've got a data type,
19:34
as we've seen before with Boomin Bill or with what other data types to look at earlier booths and switches and lists and so on.
19:41
Yeah, once you know your constructor's you can write functions.
19:50
Which consume trees and all you've got to do is have a pattern matching move for each constructor, so you give me a tree.
19:54
I know it's only built from one of the either that or that. So when I look at a tree, I will see only either an empty or a.
20:00
When all I do is I write down one rule for the empty case in this case, the size of a tree and size of trees.
20:07
And I would like one rule down for the the nut case. So and of course is a three argument constructor.
20:13
Therefore I have my patent has to conform to that.
20:20
So I've got to have three things in my pattern in this case that just variables left and right and then I guess.
20:22
So it's a simple generalisation of what we know and love from the world of lists.
20:31
Except of course, if I've got to constructors, there would be two pattern matching rules.
20:35
If there are three constructors, there'll be three pattern matching rules in general. And of course, depends on the problem of trying to solve.
20:39
But that's always your first line of thought. Oh, OK.
20:45
I'll write down one rule for each constructor and actually it's pretty much impossible to get the right hand size wrong.
20:48
But, you know, if if you draw if you draw a picture and say, what am I trying to do when I flatten a tree, it's almost impossible to get it right.
20:54
I flattened the left, start reflecting the right subtree. These give me two lists of glue, the tools together using a pen.
21:01
And then I must remember to put the X in the right place with an order traversal the X goes in between the two flattened versions.
21:07
Which is why in that way there are other ways to code this, so and so on and so forth.
21:13
So I don't I think it's actually quite straightforward once it sinks in.
21:18
Just remember, you can define your own data types. This is a use the phone data type.
21:22
You can give it any name you want. And typically you're doing this because you want to build data structures that mirror pictures you might draw,
21:26
which encode structures for storing data and algorithms for manipulating data and so on.
21:35
And so it all starts with getting the right data type and then functions over the data type.
21:40
Just follow. So I think by the time we've done this next week, it'll all be clear.
21:44
So, Richard, what's your question? I'll think about the stack thing.
21:49
I haven't forgotten about the demand going to the DOT, the operator that the composition.
21:52
Composition, yes. OK, yes. Yes, so this one here is it.
22:00
Yeah, so I guess we are kind of covered the types I think it's one of those things that you just have to sort of get used to it.
22:07
So the trick is actually it's all the trick to using. It is actually completely embedded in this rule here.
22:18
You just have to remember that every time you see FFG, which is the thing on the right is FFG of activism,
22:23
if you can optionally replace it with dodgier because that's that's how it's defined.
22:30
Is it back to you? Is it the type signature you're confused about?
22:38
Is it was it what it does or is it how you use it?
22:42
So actually yesterday I was trying to get the last element of a list and I tried to do head not in reverse and then get the last element,
22:45
but is not working out. So do I have to define composition? I don't want no.
22:51
It was throwing up an error, evidently, OK, let's see if I do that right.
23:00
So what you want to do is head of reverse, I'll put the brackets in.
23:06
Had a reverse of that, which is awesome.
23:11
Let me change the element to an X so we know is the last just.
23:15
All right. So what that is, that's that's it. I don't know what you did, but this is clearly had thought maybe maybe they'd get the bracket right.
23:20
So that by definition, that's the same as that. So these brackets, the ballot, this is that you've put in there.
23:30
Yeah, if you if you don't put the brackets in, then Haskell will think that his head dot because of the precedences, it'll it'll bracket it that way.
23:40
And that's not what you mean, because you know that's wrong, because you think, oh, that's got to be wrong,
23:51
because DOT takes to function well, heads a function that's fine and therefore reversed if that should be a function.
23:58
It's not. That's a string. So you can't compose a function with a string.
24:03
So that tells you, oh, I've got the brackets in the wrong place. But that's that's probably what you did wrong.
24:07
Or you left the bracket, probably left the brackets all together. OK, is that clear?
24:11
Yeah, I think. Right. Yes.
24:16
A nice way to solve the problem actually, because it's actually just as efficient as any other method because the time complexity reverse.
24:18
I've got it on the screen looking at the screen above I showed you yesterday, had to write recurse reverse using an accumulation parameter.
24:27
That's, that's, that's all rain. Whereas the naive one is N squared.
24:34
So the one that's built into Haskell is this version, which is order in.
24:37
So so actually your solution is very nice, nice way of doing it because reverse takes over and time and the head is just constant time.
24:41
So it's every bit as efficient as any other method you might think of.
24:49
Very good. I think your next. Right.
24:53
So looking down the sides, I found it hard to understand the insert function as defined.
24:58
The site is not polymorphic. Oh, this is this one here.
25:07
Yeah, I looked at that myself and I thought that's not very well worded.
25:13
What I meant by this statement was that if I commit.
25:19
Let's do it. Let's see if I got it up here. Is the here is that insert function now, I put the type signature in is to prevent trivia.
25:26
Now if I comment that's out. And you just look just look at the definition of just now, just forget the type and just look at the thing you think, Oh.
25:37
Is that is that a is that a purely problem, is it a genuinely polymorphic function you can it work with can it store items of arbitrary type
25:47
and can this be and this anything can this be an arbitrary a for an arbitrary type object type?
25:57
And you think, well, yes. And they think, oh actually no, it can't because of this statement here.
26:07
So what that tells, will we be covering this in more detail next week?
26:13
This says, I can't stop any and I can only store AIDS, which are comparable under these inequalities.
26:17
So if he come back to my what do I draw on the magic wall? So this is the universe of all types.
26:25
We actually say for a an inside, there are those types for which you can imagine.
26:30
There's a sort of set of types, whether this is what this is really what type classes give you.
26:38
There's a set of attributes of some. This set of this is called awed by the way those things that are alterable.
26:41
And that means you've got definitions of less than and less than equals and greater than equals and so on.
26:48
So this is this this inner circle as the set of all types for which these functions, these inequalities are defined.
26:53
And that's that clearly doesn't include all types because you can't you can't say is cause less than or equal to sign.
26:59
So we know outside here we've got function types.
27:04
They can't sit inside and there's a bunch of other things that you might conceive of which are not naturally honourable,
27:07
but then that are eligible, I can put into that tree because that tree only requires with less than recourse.
27:15
If I if I save that and I now reload the programme and I say, what does Haskell think?
27:21
Now I'm going to ask you to work this out. What is Haskell think?
27:28
The type of insect primate, if it were truly polymorphic, it would say a total of eight Treva and it doesn't say that.
27:30
It says a total of eight trebeck subject to a being, something that's alterable like ints and doubles and strings and anything I can do less.
27:38
So you're actually it's a very good point.
27:50
And I spotted this on the slide yesterday and I thought, I'm going to change that slide for next year because it really wasn't clear.
27:52
But that's what I meant. Is that is that okay now? Um, yeah, it's OK.
27:57
Yeah, is there some aspect of the question that's the issue that that's not clear because we can do that now?
28:05
Um, so so moving on to another question.
28:12
So I actually don't understand the mechanism of good function.
28:18
Right. The next slide of oh, sorry, I missed what you said of, um, of the the structure of build function.
28:21
Oh, the built the tree function down here. Yeah. Right, that's right.
28:31
Right. OK, go. I did this, I did this on the whiteboard one more time.
28:37
So supposing um. Let's do it.
28:42
Let's do encode supposing. So what's the type of my bill function?
28:47
So this is you give me an unordered list of integers and I want to board and an audit trail of integers from them,
28:55
so before what you do is you sit there and you think about anything, how would I do that?
29:02
So what I suggest is several ways to do this. What I could do is I could start with an empty tree.
29:07
Supposing I've got let's in fact, let's construct a list. Supposing I've got a list Xs which consist of an unloaded list.
29:13
Something like that. How about that? So you think, how would I build an audit trail from that?
29:22
Well, if you think, well, somehow I've got to how about this?
29:28
I've got the reason that they get the help.
29:31
I'm going to use is this insertion from somebody's got the insert function, which in my script, by the way, I've called insert prime.
29:34
Oh. Hmm, something just occurs to me, I just ask for the type of things to go back to what you just asked me.
29:41
So what was the topic? Oh, it was a television set, so I've got this function names I could insert.
29:50
Oh, that's right, because there's another insert in the script does lineaments list in session.
29:55
So I must remember insert prime here. OK, so how would I build an auditorium in that.
30:00
Well, supposing I start with an empty tree, I could insert Pruyn five into that tree which is this five in here.
30:07
Or I could do the other way around this way around to start. I would be slightly easier so I could put that five into the tree.
30:17
And then all I've got to do is to put the six, the two in the four into the tree in some order in the order in which they're written.
30:24
So supposing I take that tree. And then I insert.
30:29
I say I sit there and I insert from the six into that tree and then I insert the two into that tree.
30:35
And then one more time, I insert prime the four into that tree, can you see that will give me the tree I want.
30:49
So it's got the to the four, the five and let me draw that tree and say I'm drawing it now my magic whiteboard, so that's fine.
31:04
There's a leaf six on this side. I've got a.
31:14
To right, so this is the tree that's. That's not see the No.
31:23
No, because I had to say that's the tree, that's the tree that's constructed by the thing I've just shown here.
31:32
Yeah, so that is an order tree, because at each node, all the items the left is smaller than one to the right is bigger than.
31:39
And that applies everywhere throughout the tree, therefore, by definition, is an order.
31:48
So that solves the problem.
31:53
So so the question is how given four to six, five, how can I construct that chain of insertions here and you look at it and you think,
31:55
well, it's some form, some function of some X, some function of some other X, this is it is a different X bonds.
32:03
X will come next one an X to and that's some other function of X three and this is some other function of X four.
32:11
And then there's some base case or some unit, I actually call it unit.
32:20
And you think where have I seen that before. You think that's a fold.
32:26
That's exactly what in this case exactly what four right does.
32:31
It says you give me the F and you give me the unit and I walk and you give me the X is excellent X to construct exactly that expression.
32:34
So, so I can get the same effect above but just unfold.
32:41
Right. Right, in this case of the function F, which in this case is insert prime.
32:46
With my unit being the empty seat, the empty tree, and I now just give it my list, EXIS.
32:53
And at the same answer. So I now know that.
33:03
To build a list from an arbitrary list is all I've got to do is just that comet.
33:10
And then you think, well, that's so I can I can do that, but let's just do that.
33:18
So talking again or just. Let's come up here.
33:23
Where's my field function? So I'm going to do exactly that.
33:28
I'll just placed it in there and save it.
33:34
So right, right, so now I can do build what's my what was my example, build three from four to six.
33:43
Let me just pull out this. I say build my auditory connexions and I got there.
33:52
It is perfect. So there's nothing wrong with that.
33:56
And that's sort of full marks. But then you just is a little sort of tweak I've done up here is to say that you just lay this out.
34:00
This is I'll leave it on one line. I think like we know the function application in Haskell is left associative.
34:08
So so that term, if I put all the brackets, even if I put all the brackets in that bracket in,
34:14
that gets applied first from what we've just been discussing about, you know, plus and plus, then that gets applied to the empty.
34:22
So we so fold. Right. Takes the insert prime. First, if you like, and then it takes separately the empty thing, the empty unit,
34:31
and then it takes the exit, so that's a bracket it to say exactly that.
34:41
And that is exactly the same function. So if I come back and we load it.
34:45
Oh, I have to yeah, when you reload, you got to keep running with nexuses and I get the same thing.
34:51
So then all I've done is I've come back to this and I said, well, knowing that. And you get to a point where you don't have to put the brackets in,
34:57
you just see it quickly, but I think right now I've got something in the form F of X's.
35:04
Equals. Geewax is. And with me just.
35:10
We're wondering what's going on. There's a large puddle of water just to get on my desk, probably from the sea.
35:21
That's a great mystery. I suddenly find my hand with an enormous puddle of water, diagnose it.
35:57
Yup, right, sorry, where was I?
36:15
Yeah, so now I've just got something in the form picking up his Wetmore.
36:19
Just out of the mouth, right?
36:27
So what I've got here is something of the form F of X equals.
36:31
Jeev EXs and I know that if I see effectors equals Jarvis's, I know that F must be with the G so I can optionally cancel the two two things here.
36:36
And it's one of those things in high school programme, your function, you just get used to seeing, you know,
36:48
when you first see when you first see it, it sort of looks rather terrifying and just completely wrong.
36:54
That bill is a function which is expecting a list of ends. And yet there's no mention of that list of ants on the left hand side.
37:01
But you just automatically just get used. Oh, yes, of course.
37:09
This is just this is just composition. This is just a composition that play exceptionality at play here because you think of being a function.
37:12
So you give me a list of ants, then I will do that.
37:20
To that list event, which basically means you say you give me the list of ents just doing this the other way around, are you?
37:25
Give me a list of. Excuse me, you give me a list events and I will simply give that the same list events and we reconstruct the official definition.
37:30
So if you are happy with that as it shows on the screen, then by all means, just do that.
37:41
The extension of two years is a tweak. Is that OK? Oh, yeah.
37:46
Understood. Thank you. You're welcome, Tiffany. I have a couple of questions about terminology.
37:51
Firstly, if we have a function and you have rules in the function, but you can have multiple gods, I think one of the earlier slide said,
38:01
I want to know whether if you have like a condition, like a work clause, does that define a different room for the same function?
38:11
This is the where clause to find a different rule, like how would you segment out rules in a function?
38:20
Maybe this is a technology question, so perhaps I will just say so if you look at the answer prime function, there are.
38:28
Yeah, I see, yeah, possibly, possibly we're not consistent with this, I would say that there are three rules there,
38:40
but a rule is one way I think of a rule as being one where you say, given this pattern, do this, given this pattern, do that.
38:47
So pattern matching rule, a rule is implicitly comes a pattern matching.
38:54
So that's the pattern. Matching rules on the left hand side of the function is a pattern.
38:58
In this case, variable and empty is a pattern of X two patterns really, isn't it?
39:01
But essentially the thing on the left is a pattern. That's a set of patterns.
39:07
This is a set of patterns. So I see there are three rules. And in those rules there is one.
39:11
There are two gava, two guard sometimes called them clauses. There are two guarded expressions.
39:16
So that's a rule with two guards.
39:23
And I'm not quite sure what the point about the wear was, but I can obviously attach a wear to this and that's a wear clause.
39:26
So in a way it just introduces a set of definitions in the same way that the top level of a programme is a set of function definition,
39:36
sets of definitions. Exactly the same thing applies in a context and in the context like a word, so it can have some other functions in here.
39:43
But that's what I call it. Where clause is clause the right word. I don't know.
39:54
Maybe it isn't. That's what we that's what we tend to call it in our of constant equals know.
39:58
And so so what you get here is a set of definitions, which is a set of definitions.
40:06
And exactly the same way that at the top most level you've got a set of definitions. So these can be pattern matching rules as well.
40:13
So I can this this could be a function which perhaps on lists where this says this says you give me the entry list,
40:19
then I'll give you back to the data.
40:26
And if you give me a non-empty list. Well, I'll give you back to the dirt, whatever that has to be, so it is exactly the same,
40:31
whatever I can right at the top level, I can watch to side the clothes.
40:43
And of course, I can also attach to possibly, arguably should attach type signatures,
40:45
although I tend not to put types of information because they tend to be very much smaller, simpler helper functions.
40:49
And that type is usually usually clear, but so off you go.
40:55
And so, so again, these functions themselves can have multiple rules here.
41:01
The functions got to rules and I could have guards inside those functions and I could
41:06
even have nested nested functions where the same thing applies again and again.
41:12
So I think that's that's the term that will probably be a little bit loose with the terminology.
41:16
But that's what I think I mean by a rule. A rule is a thing with a pattern.
41:20
OK, thank you, Mohammed. He's been all the difference in the outcome.
41:26
I won't be doing that next week,
41:40
so the difference between one type class and another is this is simply the set of members we call the member function.
41:42
So I brought the doctor out now, but for of for me, just got here, OK, I want to justify that action.
41:52
So for a function to be if you say a function of type.
42:04
If I say a function of type EKI A to a to a to say something like that that says
42:10
this function can take anyway so long as it is as it is a member of the class.
42:24
So if you look at the peak, if you tell me some information about E q there's quite a lot of information about
42:28
it because it's got a lot of members of the kids and we'll be doing this next week.
42:40
So I don't spend too much time on this. So look, the key thing in here is there with me.
42:43
Well, this lot here.
42:52
So it says, well, things that are members, types, types that are members of Akir are those talks where I've got equals or not equals defined.
42:53
So these are called the member functions. So if I look at the same, I do the same thing for I do the same thing for [INAUDIBLE].
43:01
It turns out now that the member functions of all the not equal is not specifically these ones.
43:10
Is the comparison operators the less than a week and so on.
43:17
So that is the difference, arguably is the difference is that they have different member functions.
43:21
So they have they imposed different requirements on these AZ.
43:26
And I will come to this next week for something to be alterable, it must also be comparable under equality.
43:31
And that's because of that lesson. So I think we'll probably defer that, if that's OK until next week.
43:37
Humza, that's a new kind of thing. Yeah, in the build function, you called insert train with only one argument.
43:44
How are we able to do that? Seeing as subprime usually deals with two arguments.
43:54
I one argument, where did I do that? It's you're going to go and build.
43:59
In Bill. Yeah, if you look at the code for build.
44:07
But OK, a second, so I need to be over here.
44:11
Not one. Yeah, so it says insert prime empty, whereas the function in subprime usually has two arguments.
44:20
Wait a minute. Whoa, whoa, whoa, whoa. So I'm not I'm not I'm not a plug insert anything here.
44:29
That is just the insert prime function fold. Right. Will apply the function for me.
44:33
So what is this second argument in that case? So this this this is the first argument.
44:41
So this is the first argument that followed, right. So far. Right. Texas function as its first argument.
44:45
Remember, that's what. So that is the first argument to follow. Right. And that is the second argument to follow.
44:50
Right. At this point in time hasn't been applied at all. So what?
44:55
All right, Jerry. We know that was said, all right, f you.
44:59
Let's just keep it simple, x1 x2 x3. What does that do?
45:07
We know that that is the same that will eventually give me the phone to give me the list.
45:11
So the list the [INAUDIBLE] the expression F of X one applied and then to.
45:19
Three applied and then the unit is that you?
45:28
So it's the fold right itself.
45:35
Which applies the F and there so imagine this is in prime, it's now on is as a result of executing the full right function,
45:39
replying to right function that the insert prime gets given its first argument and its second argument.
45:47
You get it. Yes, so this is this is an ARG, this is the first argument of the fall, right.
45:55
Which is the F thing in here. So what is right do with it? OFCS there's the answer from you.
46:00
Give me the first item or give me an item on the list, the first item on the list.
46:05
And then the second argument of the insert will be the result of that lot, which is some Rapido.
46:10
I had it in my house. Where is it? That's the expression I'm trying to construct.
46:17
So that is exactly what I've written here. Are there enough arguments? Not quite.
46:26
This one's got three one four. So there's there's the F this this is the general pattern, what a fellow does.
46:30
And specifically in this case, the follow the F is the insert prime. There's the four, there's the insert.
46:35
The practise is the second argument, which is a recursive invocation that occurs, another invocation of insert prime the to say, can you see that?
46:41
Can you see that this thing in here. Is exactly the same shape as that thing in here, I've just replaced the F with the insert priming the with empty.
46:50
Stunned silence. Yeah, this is this is kind of one of the penny will drop with higher order functions.
47:04
Here's a higher order function. It takes another function as its parameter ping.
47:10
And in this case, it takes a unit as well. Ping. So that is a function of this this inseparate, you must understand not it's emphatically not this.
47:15
The bracketing does not work this way because the brackets function applications left.
47:26
So that's completely wrong. That doesn't make any sense at all. Yeah, completely broken.
47:31
The function applications left associative. So in fact, the bracketing is, you know, by now works that way around.
47:38
Oh, I see. Now. So insert problem is the first argument to fold. Right.
47:43
Correct. And empty is the second argument to fall from.
47:46
And in fact, if I put the X's back to make it even clearer. The axis is the third argument for prime.
47:55
And now now you can see all before you. Yes, there is there is the fold right in prime empty axis.
48:06
And if I use that, I know that far right. Given that that sort of structure will give me that sort of structure.
48:12
And if I substitute the F for the insert and the for the empty out pops exactly what I need.
48:18
But move is just to run.
48:25
A very quick question, because I think you have another question today. Can you go anonymous and lambda functions again, again of lambda function?
48:29
Yeah, it's very simple. So as I said, you know, you can define a function, you can name it.
48:44
All right, it's completely clear what that means, you sort of name the function.
48:52
This is a function of X, which gives me X plus one. I happen to have called it suck.
48:57
So to apply that function, I use the name and I give it an argument.
49:01
But that said, that's the definition of a function.
49:07
Now it turns out there's an expression which were built of the same function for me and I'll put it in brackets, so I'll read it again.
49:09
Such is a function of X, which gives me X plus one. So the function is a function of actually gives me X plus one name said,
49:16
well I can say exactly the same thing using a lambrix a function of X because X plus one, except I've got the arrow right.
49:24
That gives me X plus one. Oh except I don't have to name it.
49:33
Because that is now a function, that expression builds form a function of X, give me X plus one and I can just apply that direct.
49:40
So in fact, yes, guess what? I could in fact, find if I really wanted to.
49:48
I could define sarcasm, a expression. I would say such is the function better because we express one that's the same thing as well.
49:53
So that is exactly the same as that. But of course I wouldn't normally write the thing above just the way I've just written it.
49:59
But the thing is, I don't have to name the beautiful thing about the London Olympics,
50:08
but I don't have to name them because that is indeed the function that I can I could pass that into.
50:11
I can give this to what might I give that to?
50:18
Well, as I said, I think of an example. I can map that function over a list.
50:23
So it's just just a mechanism. It's an expression that generates a function rather than having a named function that generates a function.
50:31
Well, I think should thank you, because I'm supposed to stop at 10 to.
50:42
But we can always pick this up again in the next election or next week.
50:47
OK, thanks. By cranky.
50:51
And.
50:58