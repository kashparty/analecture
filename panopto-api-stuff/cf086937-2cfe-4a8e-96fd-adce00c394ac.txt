ID: cf086937-2cfe-4a8e-96fd-adce00c394ac
Title: Higher-order functions 1
Category: Haskell
Lecturer: Anthony Field
Date: 27/10/2021
OK, so we're good. So welcome back. I left you with much thought, which is an alternative sorting programme which works.
0:12
In fact, if I take you to the algorithm itself, it works like this.
0:21
It says if you have an unordered list exs, then to sort the list,
0:26
what you should do is to split the list in half so you can see that it's midpoint and we
0:31
calculate the midpoint somewhat redundant here by calculating the length repeatedly.
0:36
Of course, you can carry around the length as an extra parameter, which would save you having to do this length function invocation here.
0:41
But actually it doesn't change the complexity of the solution anyway. So we split it in its midpoint, giving us these two sub lists.
0:49
We sought the first.
0:55
And then we saw the second and and we because those are now ordered list or we have to do is to merge them back into one ordered list,
0:57
and that is what the merging function was doing for us.
1:04
And so we did a little bit of convexity analysis and we worked out that the complexity of this was order and log in,
1:08
which is if you compare that to the insertion tool, we discovered the session.
1:17
So it was all transcribed and socially so. So as I drew the graph yesterday, if you plot the time taken to sort a list of like then against in itself,
1:22
then insertion insertions, so then squared and and this one goes, then log in.
1:32
So it it grows much more slowly. So if you've got a very large body of N here,
1:37
this is essentially tractable for four merged sort and it becomes less tractable for insertions or because because of the squared.
1:42
So as I said, when you come to study algorithms properly,
1:51
we were saying what we're trying to do is to is to come up with the best algorithm for solving a problem, which means the algorithm perhaps,
1:54
which consumes the least amount of memory or the algorithm that consumes the least amount of time myself
2:00
was a up could explain why the time taken for merge is proportional to and it's not forced to end log in.
2:06
I mean, the merge, not merge. So the merge.
2:16
I'm so sorry. Let me get to go back. So, so so the merge takes two lists and those two lists came from so supposing the some of the two lists is end,
2:20
the question is how many invocations at this function do we need to merge two lists?
2:32
Well, it does kind of depend, doesn't it? Classify something up on what?
2:38
On the whiteboard and what your whiteboard is? My two lists are so I draw my tools like this.
2:42
So I know they're roaded. Something like that.
2:48
But I've got another list here, two two four seven nine say so the odds of the murders are going to take these two and produce my merged list,
2:55
which is going to be the one that soon, the two and so on. But the question is, how many?
3:04
Essentially, the way I can rephrase the question is how many of these are the elements of these tools?
3:09
Do I need to visit? In other words, how many countries do I need to assemble this list, this list over here?
3:13
Well. It depends, doesn't it? Of course, you know, if all the elements of this list are small and it all ends of that list,
3:18
then I can just get away with walking down this list, but not the second one. So it does depend.
3:25
But in general, you know, you're going to say, well, how am I going to pick this one off than this one.
3:30
Than this one. Than this one than this one. And then this one than this one.
3:33
So the number of countries is going to be, on average, proportional to N.
3:37
There may be some some stragglers left over at the end. In the worst case, what happens is I have to visit the more, you know, nine, nine and 10.
3:42
So that's the question. This one is kind of worst case scenario. The very best case scenario is inevitable, isn't it?
3:48
Because this one's got length and to two. So this one's got like one of the two.
3:55
So the total then I can do no better than walk down at least half year.
3:59
So that's why it's proportions when Daniel. Or else it might be muted.
4:04
Do you have a question? No, I think that's just teams that had an issue.
4:14
Oh, OK. It does the same with you, Daniel. I don't know what it's doing, but you should report this to my city.
4:19
All right, so that's that. So there was a bug in this programme. I'm sure some of you might have had an opportunity to play with it.
4:30
Somebody tell me what the bug is. No, Daniel, your hands up.
4:36
Is that an old hand? We're going to tell me what the bug is. Can you still hear me?
4:46
It's my this. This has gone very quiet, suspiciously quiet. Yeah, we can hear you are you can still hear me.
4:57
Okay, so there's a bug in this. So what if it's outnumbered?
5:03
What if the length of excess is odd? Well, that's okay.
5:07
It doesn't matter because it just means that this is going to split.
5:11
The less, you know, this is going to be one element bigger than the other or smaller than the other.
5:14
That doesn't that's not the problem. It looks perfect, isn't it?
5:17
I think the best case should be one element instead of like the ultimate one.
5:26
Well, I certainly need this base case because you could I could give you an empty list, which is get much function to.
5:31
The merged function merged two ordered lists and produces one list.
5:38
There's nothing wrong with that. This is the problem is in here, you've just said it, someone just said it.
5:45
What if the list has got one element?
5:49
If list has got one element, then either presumably that one's got one element and that one's got no one all the other way around,
5:52
depending on how the split works. Yes, in fact, let's do that, if I say split, at least give you one of them.
5:59
Oh, come on, what's going on here? I'm sorry, splits at position well, the zero one.
6:07
Yeah, so if I supported that position zero, I get an interest in the three in the position one.
6:16
In fact, the list has got. Yeah. I guess I guess in this case because the length is one, one over two is is introduction near zero.
6:21
So I'm actually going to get that case. So I'm going to split that list and I'm going to get into this and this and this straight.
6:28
Oh no. I started with a single this three. I'm going to merge that one.
6:34
That's OK. That gives me the until it's not going to merge The Sims and it's three again. How do I merge.
6:38
How do I do so how do I sort this. The last three I split it, it's position zero.
6:42
So I keep on splitting and getting about these two and this goes on indefinitely.
6:47
So but you can see here, if I do merge, sort of give it a single list.
6:51
Doubt, yeah, so it's not terminating because I haven't the base cases are missing a base case.
6:57
So let's fix it. So how do I fix.
7:07
I've just got to I can't I can't delete this case because it's important that we capture the case where the list is empty.
7:12
That's a perfectly valid list. But what I'm missing is the case where the list is Singleton.
7:18
Now, this is what you don't do that. Let me do it this way.
7:23
Do not under any circumstances do this. Then, you know, dot, dot, dot, whatever.
7:27
Why should you never, ever do that? Because we're doing actually.
7:38
OK, if I if I allowed this if I just set aside the continuing pattern matching, I'm just saying that's a perfectly valid pattern.
7:52
As I said, I do. This is empty. It's not empty. If it's not empty. Count the number of elements.
7:58
And if it's one, then do something special. But you should never do this.
8:02
Because we can't cut that, we can gather from that.
8:09
Well, I guess I could do perhaps, yeah, OK, so what would I do in this case?
8:15
I suppose I'll have a singleton. Well, in fact, what would it be? Would just be access, wouldn't it?
8:21
Because that is already a sorted list. But that's all right.
8:26
Tale. But is it because you're adding more complexity?
8:32
Oh, baby, I'm adding more complexity every single time I try to sort of list, but if I start to list the blank,
8:37
then I'm going to take all the time to count the number of elements in it to see whether it's one.
8:43
And it says how big it is. It's a million elements. So he says, OK, I'll walk down the list, detonated it.
8:49
It's a million. Yes. OK, thank you very much.
8:54
OK, so they're I'm going to recurse down here and I'm going to split this list into two when I come down to split it.
8:56
And I saw this one. This is oh it's not half a million because I've spent the listing to say how long the list is.
9:03
Oh, I can find out. Half a million. So this thing here is taking order any time now.
9:08
In this case, it's actually OK because there's already a linear time cost index.
9:15
I'm competing anyway. We know that doesn't make any difference to the complexity. So in this case, it just so happens that this is OK.
9:22
Right. But in general, you should never do this. Because it fundamentally changes the way it can fundamentally change the complexity of the outcome.
9:29
So here's the question why spend all that time working out whether the list is what length, one or not,
9:39
when I can replace that with a pattern which looks like what what is a pattern only matches a single time list.
9:45
Could do had intel on the terror BMT. No, don't do it.
9:55
Never use had Intel not not as a substitute for putting that up in a square bracket.
9:59
Right. So how about this? So I could write. Oh, I don't know, quite the previous.
10:04
Who did you mean something like that. Yeah, I didn't mean using the function.
10:09
I guess you kind of think I realise what you meant. Yeah. You can say you can match it against the next concept.
10:15
Yup. That's absolutely right. And of course as the shorthand for that which is that so that is a pattern X variable
10:19
squared bracket variable X squared bracket would only match a Singleton list. So in that case, the answer is.
10:26
It's just the same thing, isn't it?
10:32
So I couldn't erm it seemed quite worth and I suppose I could do but I can say I can name it exs which case I can just avoid having to reconstruct.
10:34
Bumbling around this morning. So that will do the trick for us. Yeah, I kind of thing that's ever so slightly obscure.
10:49
This is one of those situations where I'm actually quite happy not to name the whole thing.
10:55
It's actually sort of easier just to do that. I know I'm kind of reconstructing reconstructing the Singleton list at one time, correct.
10:59
This morning. Let's just say that fixes the problem.
11:07
So now if I sort my mother so that oh, well, perhaps if I were allowed to reload the programme, it would help, wouldn't it?
11:11
Oh, it's too early in the morning. Right.
11:19
OK, that's fine. So now I can presume that means I can show absolutely any list.
11:23
Yeah, sure, that sounds good.
11:30
All right, so that was much sought on. So I just want that, so we're going to move on to another topic in a minute, just a just on the way,
11:35
I'm going to introduce you to Renumerated and partly because you need the next
11:43
week and I'm not going to be doing data types properly until the week after.
11:48
So I'm just just a little intially just so you can get started on next week's problem. What are you going to be doing next week?
11:52
Is doing some fractal graphics using hardbody functions, which are going to be studying in just a moment.
11:57
But as part of that exercise, you need to draw some beautiful graphics on your screen and colour them.
12:03
So we need to have data to represent colours. And that's what this side issue is about.
12:08
So like so renumerated types, a special type of user defined data type, which we'll be covering later on.
12:13
So the simplest type of you use that stuff is the numerator type and it goes like this.
12:21
Here's a special piece of syntax data and this is the name of a new type.
12:25
So the types we're familiar with are into the float and double insha and bool and so on and so forth.
12:31
And this is a this is your chance to use your own data type. And so this is the simplest one is an enumerated type.
12:36
And all you do here is you list a bunch of constructors which are just constants, but they are constants of that type.
12:41
So these represent the days of the week, and I've used the word a three letter abbreviation Monday,
12:51
Tuesday, Wednesday, Thursday, Friday and Saturday and Sunday and so on. All right.
12:55
So when Haskell sees any of these constructions having been told at this day to talk, if you say, hey, what is what is Wednesday?
12:58
Wednesday is a day. So I hope. But if I type in Wednesday.
13:06
That's absolutely fine if I said what is the type of weapons they it's making sure the type is in my file.
13:12
Yeah, that's a date. Now, the error message, listen, you're looking at above is to do with the fact it doesn't have to print days.
13:18
But that's another issue will come to you later on. OK, so that's why that introduces a bunch of new constructions with a specified time.
13:25
So you might imagine you've got a I'm not sure it's on the slides, but you might imagine.
13:32
Oh, there is this is this is this is approximately the desktop you'll be using next week.
13:37
So these are the colours that the Haskell Graphics Library knows about it.
13:41
So that when you say, I want to draw a line on the screen, I want to colour magenta or yellow or something like that.
13:47
So these so this isn't exactly what you're going to be given, but it's something like this.
13:51
OK, so we can define any digitiser we want, we can give any name, the type, any name we want these it's up to you to pick the names.
13:56
So if I'm trying to model a switch myself, I need the data type of switch, which is often wrong, which is kind of a bit like a boolean, isn't it?
14:04
Here's one for colours and the names are of elements. You can choose any name you want so you can choose a silly name like Capelle.
14:11
There's some sort of Batman type data type. And again, the same thing applies to the constructors.
14:17
I mean, GHC isn't going to turn around and say, I'm sorry, you've chosen a really silly name.
14:22
I'm not going to compile your programme. It really doesn't care if you type that in.
14:26
It just says, you know, what's the type of what was it plink or something like that.
14:30
So it's a it's a it's something I've talked to people. So high school has absolutely no idea whether your model modelling colours or switches,
14:34
these are just names with types that the constructors with types. That's all Haskell cares about.
14:43
Crucial question. So how is I was wondering,
14:49
how is the data given here different from the time we've been using a lot of questions of the type keyword names and existing type,
14:54
it doesn't introduce a new one. So I'm not sure where on the map I got some.
15:01
With my Twitter and what types example? And.
15:08
I think up here. But we have won't solve this.
15:13
I'm just going back through the slides are just going to try and find it. It's where is it?
15:16
It was some area, yeah, so this is an example of using types, so can you see here?
15:22
You remember back here we know about the type float and float.
15:27
That's a pair of that represents a pair of floats. Yeah. So all this is doing is naming that type.
15:31
So if I say what's a position is, oh, it's just a pair of floats.
15:36
It's not a new type. You see what I mean? I'm just naming an old type.
15:40
Thank you, but.
15:45
So before I type this data thing in these constructor's did not exist, and having typed something like this, they do and I can use them.
15:48
But one thing I can do with them as I can pass them to functions and I can pattern much on them.
15:59
Here's an example of a function which is a bit like the end function. Which will come to an immediate impact.
16:03
And so this says, well, you give me two scriptures and I'll tell you whether or not they're both turned on so well, how would I write that function?
16:09
Well, here's a very simple way and very naive, I can say, both on abortion and on, on and off, off and on.
16:17
So I have to cover all the four cases and then return the book, which is just is essentially just the end function, isn't it?
16:22
Or is it more like so you might say, well, all of these cases here, these last three cases already return false.
16:27
So I can just replace those. And indeed you can you can replace it with that.
16:35
The question is, is it the same function? We'll come back to that. And, you know.
16:40
Right.
16:45
So you don't need to know this, but internally the constructors are just they're just coded as zero one two in just the same way that characters,
16:45
I guess, are encoded with using the ASCII or Unicode standard coding and the is coded 012 and so on.
16:54
So there you'll find if you if you dig deeper into Haskell, you'll discover there are things called an Ingham's in type class in them and you can
17:03
their functions in their actual mapu from the constructor to its integer and back,
17:10
back the other way in a similar way to the old and chieu functions will map back and forth between characters in the representations.
17:14
But you don't need to know for this cause.
17:22
I'm just saying, if you explore this in class, you'll find out there's a few functions in there which will be able to do that mapping.
17:23
So we'll come back to that when we study type classes and in a week or so.
17:31
Right now, as I said, guess what? The Data Bowl is just what the bowl data type is.
17:36
Yes, you've got it. So that quite literally, this is this is the way it's defined.
17:42
Boon is just a data type with two constructs constructors, false and true. And there's no surprises there, because if I can write something like that,
17:45
say what is the type of false and exactly the same way it tells me it's a bowl.
17:54
OK, so let's just have a little another short diversion, so.
17:59
Well, OK, how do we define not on booleans? Well, unsurprisingly, we use pattern matching, so that's how we would define not.
18:03
And he might think how do we define end and or. So let's think about and now this is the way the end is defined in the prelude.
18:11
So it says, well, we know that true and true is true and everything else is false because it means either one of be will be prime, must be false.
18:23
And, you know, the answer is in that case is false. So this is actually the a one of several ways, succinct ways to write the end function.
18:29
Now, I'm going to give you something to think about. Is it the same as if I'd written that essentially Liselotte.
18:38
If I'd written that.
18:45
I where I've written and instead of both on in infix form, in other words, this set of rules down here showing the bottom of the screen,
18:48
if I'd written all those out, is it the same function that I try this out?
18:55
Let's come over here. So what do I got on infix?
18:58
I've gotten in six left with function called and and it's precedences.
19:03
I can't remember. Pick one seven. Oh,
19:11
I rather actually rather than getting a name I'm actually going to call end and end because I think that's that's not named anywhere in the planet.
19:14
Right. So what is the title. And then that was just the end for my end function.
19:22
My end function. Well it's just a boo boo boo boo.
19:26
So I'm going to define my own function using these rules, true and true.
19:35
Oh, come on, concentrate. True my. And true is true.
19:42
I'm going to say true, true, false, it doesn't matter what songs I get for so I want true, false, true, false.
19:51
And on the right hand side, of course, I'm going to align my equals signs up.
20:02
And here I'll go through and all of these are going to be false.
20:08
OK, right now, the question is, is that the same function as the Undun function built into the Prendes?
20:15
So let me just find out this D.C., let's do some checking, do some testing so we know that's true and false is false.
20:23
That's that's the Haskell one. Let me just replace them with my end of the programme.
20:35
It would help. And that's OK, so that's great.
20:42
OK, so we just replace that with true justice and I can go through all or four cases and I can replace that with the Haskell.
20:45
And so are you convinced that this is the same as the Pascaline?
20:53
What if there are more than two million, but. Well, there are only two because I only take to.
21:01
Right. Its type is portable, the ball is exactly the same as the type of the Mianne function, what's the type?
21:07
And it's both. Both, but so is my version the same as the Oscar question myself?
21:15
I think they are the same, but except that your version is left associativity associative.
21:28
But the inbuilt is right. Oh, that's well spotted. I hadn't a lack of concentration that.
21:35
Fixed, is it the same, Alex?
21:44
I think it's not because you could have undefined booga so well, Alex says it's not the same because what if one of those proteins is undefined?
21:50
Can you remember? So let's just get back to what I told you yesterday. Can you remember what order Haskell does, its pattern matching?
22:01
Well, I'll tell you, it's left to right. And if that fails, it's then top to bottom.
22:07
So in other words, given two arguments, the first thing GHC is going to do is going to say, well, this is the first one that's true.
22:13
It how does the second one. That's true. And then it comes down and it tries almost everyone who tries us again tries this again,
22:20
because again, of course, it actually can remember the ox as it competed last time.
22:28
But that's the order in which the PAP is going to happen. So if I got so we know that there's an undefined element.
22:31
Which is a bit like bull, so every type has an undefined element, and if I invoke the undefined elements, I'm going to get an exception.
22:42
It's going to stop there. Oh, no, I found it on the phone. Go.
22:48
So what about this? Supposing I say I use the got a true and undefined.
22:52
So what happens? But I get the undefined error message.
23:02
I think it should be something like force, and right now what happens is instead of true, I get false.
23:07
Whoa, now I'm going to replace it with my own function.
23:16
What's going to happen? Bang, it explodes.
23:21
So this version of the and function short circuits, if it's the case that the first argument is false,
23:27
because if the first argument is false, as soon as I try that much, it fails.
23:35
And I never try the pattern match on the second argument.
23:40
So you remember I told you that all short circuits, when we have a discussion yesterday, you know, in other words,
23:43
what I meant by that is if the first argument of an order of the vertical by vertical bar,
23:49
if that's true, it short circuits and stops because it says it knows the answer is true.
23:52
It doesn't have to calculate the second argument in the same way the end.
23:56
The function can short circuit because at the first argument is false. We know the answer must be false, which is what the second rule tells us.
24:01
Now, unfortunately, in my version here, that is not the case because if the first argument is false, this patent match fails, that's fine.
24:09
So we go to the next one. Well, that's going to fail again now, is it?
24:18
Oh, the first argument is false, but I can't commit to this right hand side because I haven't yet established the second argument is true or false.
24:21
So it goes away and it says, OK, POCs, the second argues, said, what value?
24:29
Because I need your value in order to do the patent. And that's when the thing explodes.
24:34
So this actually is introduce this version here is introducing a lot of testing to pattern matching you don't need.
24:39
So in order in the spirit or in the spirit of lazy, functional programming, you should write it this way.
24:45
And indeed, if you think about it, it's exactly that definition that gives you the short circuiting when you use.
24:52
And then, of course, there's a similar rule for all.
24:57
So the rule for all would say something like, you know, if I've got true or anything, then the answer's true.
24:59
And so that would short circuit straightaway.
25:08
Good. So, yes, I mean, it provided the two arguments to terminate.
25:14
Of course, semantically, the two functions are the same. But if one doesn't, the different Mohammed.
25:18
So the plane would be the capital. I didn't the sound is very poor to be in the would be in the B and B the catch.
25:26
Yes, this is like a catchall because pattern matching works top to bottom.
25:37
So so I can so this person says, you know, if this one is false, the pattern matches.
25:40
So what it does, it skips to the next rule. And of course, this is just a variable. Variables match anything.
25:46
That's the nice thing about variables. They match anything. So that is indeed a capsule. Did it?
25:52
It's a very subtle point, and to be honest, it's not something you have to worry too much about.
25:59
But but, you know, if you're having a discussion with a friend, so just high school short circuit exams and all this,
26:03
it does because of a combination of pattern matching and lazy devaluation.
26:09
Because if this if it has to restrict language,
26:14
it would be too late by now because I would have already evaluated the second argument before I did the patent.
26:17
But because I do the pattern matching and before I evaluate the arguments, this gives me the ability to short circuit.
26:21
So if you like, short circuiting is a special thing, if you like, in a language like C or Python or Java,
26:29
whereas in Haskell it just comes naturally from the evaluation provided you write the functions this way.
26:34
Right. OK. I suggest we have a little break for a couple of minutes because this is the next topic.
26:41
So I'm going to turn off and get a glass of water or something. All right, I'm back, Daniel.
26:46
Your hand is up. I think it's an old one, Alex. Your hand is up. Is that an old one?
29:30
We got on the previous one where we had like and it had like three and four underscores a very important difference.
29:34
Oh, that's a good point. So let me just have a look. Oh, yes, of course.
29:46
So, yes, I should have mentioned this, I can replace these with underscores underscores are just variables.
29:51
It just that there are anonymous variables. So I get the same behaviour.
29:56
If I replace them both with the reason I don't have to name them is because I don't refer to either of them.
30:00
On the right hand side. They just I just know the answer is thank you. I meant to say that just like.
30:04
Right. OK, so higher order functions. So what is a harder function is the function.
30:12
It takes another function as a parameter. Oh, there's a question from Qianjin.
30:18
Yes, so I still have a concern about the Paramatta, and so for the part of Merchant,
30:27
it's that from left to right, I mean, if we have true and false, well, we get well, I mean, undefined.
30:33
And the force. Well, we finally got foreswore undefined.
30:44
Yet the pattern matching is left to right. So when I wrote, if I were undefined, I'm going to use the Haskell and now and anything, you know,
30:49
the answer is going to be it's going to be undefined because the pattern matching has does it has to inspect its leftmost argument.
31:01
There's no way around that. So you think, well, okay, well, supposing I swap them around.
31:07
Supposing I did this way around, so it has two inspectors left my.
31:17
That's true. But now in order to know whether the first one matches, it now has to inspect the second number.
31:20
So this is also going to give me undefined.
31:25
There's no way around it, it's only if the first one is false that it doesn't then need to inspect the second.
31:28
So it's left to right across the rows.
31:33
And then if if that if anything fails at any point, you immediately abort and you get to the next troops left to right, top to bottom.
31:35
Is that clear? Yes. So it's not connected with the left us of war crisis.
31:43
Oh no, no, no. This is just this now that's that's that's a separate issue.
31:51
That's to do with how Haskell brackets the three or more invocations of the of of an operative, for example, Alex.
31:54
Sorry. No. OK. All right, good.
32:05
OK, so how what a function is a function that takes another function as a parameter.
32:11
So in some sense is no surprise that we basically have it goes everything in Haskell is kind of first class.
32:16
You know, if I can put an end to a function, I can pass a character to a function, I can pass a pair, I can pass a list to a function.
32:23
I can pass anything of any type to a function so long as the typed line up.
32:30
So well, a function is just the first system. It's just function type rather than type things, you know.
32:33
So. So what is the successor function that's sort of to endorse num num or something isn't it.
32:39
Number two, I, you can imagine being for example in doing well that's a function.
32:45
I can pass that to another function. There's nothing stopping me doing it so long as the types line up.
32:51
So in Haskell, these higher order functions ubiquitous, there are a number of them which we use again and again a lot.
32:57
So I've listed some of the more commonly used ones here. So for example, the map, the filter was in the folds.
33:04
These are very commonly used and he is going to be using one of the ones you'll use next week.
33:11
In addition to those is a single database. I can do that later on. Right.
33:15
So if the function takes another function, if a function takes another function as a parameter,
33:20
you got to think of what the type of that function is on. How do we write it?
33:24
So the map function, let's start with a simple example.
33:28
This says, you give me a function of type A to be so imagine I've got a function in my hand and I put a list of arrays.
33:30
The idea is I'm going to apply this function to every one of the eyes, so for every eye in the list, I apply the function, I must get back a.
33:38
Therefore, for every I gets turned into a B and there is A there is many B's.
33:47
There are the type of the function must be what the results of the function must be a list of base.
33:52
If the function turns the A's into B's filter is what is filtered.
33:57
Services will give me a list of A's and I am going to remove some of the A's depending on whether or not they pass this predicate,
34:06
whether this is true or false. So the predicate says, you give me one of the A's not to be a boolean,
34:12
and the idea is that it gives you true then the is preserved in the output list.
34:17
Otherwise, the the the the object type is discarded, so I get back a sublist of the one I started with,
34:23
those elements which for which the predicate was true.
34:30
OK, and there are other variations this which we'll come to shortly, I guess so that's the idea.
34:34
So how are the functions as a function takes and other functions that we will discover later?
34:40
There's another variation of how our function, our function, and also return a function as a result.
34:45
And that'll be the topic will come to to next. Right.
34:51
So I think I've simplified some of the types.
34:55
So I have simplified some of the types that if you ask GHC what types of some of these things are, you get a slightly richer type.
34:57
But that's deliberate because I don't want to get too involved type classes just yet.
35:04
You've got a new hand or an old hand. Could you just explain what the higher the function of map like what this E gives B in map.
35:09
Again, I'll show you what it's supposed to do, so it come to the person.
35:17
And so the idea is if I have some function f so if I'm going to get a map.
35:21
Some function F and I, I give you a list X one X to up to X and.
35:29
No comments here, of course, because that's my shorthand notation, right?
35:36
So the idea is that this gives me back a new list where F is applied to X one, F is applied to all the way down the list.
35:40
So I just apply the same function to each element.
35:50
So if I've got a list of a list of people whose birthday is today and I want to increase their age and this is the list of their ages,
35:54
I just want to make a successful function, for example. All right. Let's think about the times.
36:02
So if this is a target list of this list up here, if this is a list of ACE.
36:07
When this function maps, I used to be. Yeah, so here I've given it and I.
36:13
And FERPA to be, therefore, this must be a B, yeah, so I get back, this thing in here must be a list of BS.
36:20
So the function takes that, the map function takes a function type I to be a list of A's and B's, but it.
36:28
Well, let's see how we define it. And several ways I can do it, there is some examples there,
36:38
so this is this is nuts about increments that gives you back a new list, which is every is one big.
36:45
And it was before. And this is an acronym. Bohrer Yeah. You give me a list of strings and I'll pick up the first letter.
36:52
Right. So you might have a function called acronym. Acronym of Axis is Map Head over X's for example.
36:57
Right. So there's a beautiful way to define the map function, which is to use a list comprehension.
37:05
So in fact, if you believe if you've said you should have been practising this comprehensions by now.
37:10
So, you know, if I wanted to add one to every element of a list,
37:15
here's my list and I want to increment so I can say something about map suck the success function.
37:18
That's going to be the same thing. But another way to write is just using a list comprehension, isn't it?
37:25
So I could say something like what I want is X plus one,
37:29
the list of all X plus one where the X is drawn from using a generator for this one, two, three, four.
37:36
And that gives me the same thing. So if I just write the the well I can write it the other way around plus one just in prefix form.
37:43
So is that, what have I got. Oh no. I want the successor function don't I.
37:55
Sorry. It was rather easy for everybody. That's what.
37:58
So looks like what I voted for wasn't wrong, it's just that it's probably easier if I just just so when I say not f over the list,
38:04
it's the same as saying if I say the success of the list, one, two, three,
38:13
four, I could have I could have solved the problem just by putting in place.
38:16
I could written that list comprehension so you can get to choose either.
38:20
I'm not saying anyone is better than the other as there is a malfunction there.
38:23
It's quite often it's actually turns out to be decided to use it. Not always.
38:27
OK, so that's how we can do it using this competition.
38:32
We can also define it using pattern matching. Why?
38:37
Because map is clearly a function which consumes a list and for each element applies to it.
38:41
So obviously, perhaps I should just go back. This is the way in general I can right the map function using this comprehension.
38:48
So if you ask me to map a function at verbalised exs, I can just use a list comprehension.
38:55
Well, I'll just use the generator to pick up each item from the X's and then I'll have to do is apply the effort to it now.
39:00
So the only thing is a little bit scary here is this.
39:06
That is something variable space variable. So whenever you see something juxtaposed with something else in Haskell, it means function application.
39:11
So that is the application of whatever is to whatever access and just to make sure
39:20
that the top hypersaline up F must have time to be a to be for that to be correct,
39:27
then the X must have a. Well, I know that because the type of the X is is this debate.
39:33
Therefore each X I pull off from the list must be a typo. So this is the only unusual thing is that.
39:38
But there's not scary about that. I mean we've been saying like, you know, when I wrote F Space X, you know, the space here, it sort of means.
39:44
Apply apply the apply the F to the X.
39:54
So it doesn't matter whether this is a variable or whether it's something like a concrete function,
40:00
like cause sign or successful or something, the spacer was making it.
40:04
In this case, it is just a variable because it's something passed into the function.
40:09
It's so simple as a variable representing the function of this past week.
40:12
So the other way to define is using pattern matching.
40:20
So let's think about this in sort of in the spirit of what we were studying yesterday, last week.
40:22
So, OK, let's say I've got a phone in which is going to consume a list here, so I'm able to dismantle the list.
40:28
If the list is empty, there's nothing I can do other than give back the empty list if the list is non empty.
40:35
So this remember this thing here, left hand side here is a pattern.
40:41
So if that pattern matches, that must mean that the list that you gave me is non-empty,
40:45
which goes on as a side effect of the naming the head name in the tail.
40:50
Now, what do we do with the head in the tail?
40:55
Well, we apply after the head, which is the X and the juxtapose X X axis, the juxtaposition, which means function application.
40:56
I'm going to join the onto using the common thing, the result of mapping F over the remainder of the list.
41:05
So again, just in case this hasn't fully sunk in yet, I'll just show you a quick example.
41:10
I a map. The success of function over something like lists two one nine seven six, something like that.
41:15
So going back to my role, it doesn't match the first pattern because the argument is empty.
41:25
So this does not apply. So we skip down to the next rule. This does apply.
41:31
This does match. It does match the two is the X, the slot here is matched against the X's.
41:34
Why, because this thing is a short hand for ex cons, that lot, I guess one written out longhand.
41:43
OK, so this is the axis of evil, that's right. So now what it says is the form to form the answer.
41:53
I apply F to X and Cong's that until the result of mapping F over the axis.
41:59
Well, this says this should be what it should do.
42:04
What it will do is to say, I'm going to apply the F, which is the successor to X, which in this case is the two.
42:08
And then it's going to join it onto using the columns, the result of mapping.
42:15
The success, successful function over the exs, which is this thing in here.
42:19
Now, without doing any thinking, you know what Matt does?
42:25
So you say, right? My leap of faith says I know that that is going to give me back at this list exes with each element incremented.
42:30
So this is going to get me back to ten, eight, seven.
42:37
So when I do the successful to answer that, I get back.
42:44
Guess what, three to 10.
42:48
That's the possible answer. I hope three to ten of them.
42:55
Yes. All right. Here's your leap of faith.
43:00
This thing. This thing. Going from going from here to here, so I just know what I just know what matters,
43:04
I don't have to worry about how or why, whether it's lazy doesn't matter what it does matter.
43:11
Does this in it done? Because we just got a constant groundless.
43:16
There you go. So it's almost impossible to make a mistake. Right.
43:21
So that's the man. What about filter? Filter use as a predicate to strike out or leave in, depending on whether it's true or false.
43:26
And elements of a given list. So if I if I've got the list one, two, three, up to 10 and I want the even numbers filter even will only return.
43:38
Give me back with only those elements that satisfy the even Paraka.
43:47
So just the even number so I can define here syntactically defined a function which is this is a function, X is is bigger than six.
43:51
So only those elements bigger than six in this list will get returned, the rest will be filtered out.
44:01
This gives me some time. Just what does this one do? This is oh you give me some character.
44:09
I don't know why I call it X. It's a bad name, minus a thousand marks for that matter of fact.
44:13
Is X not equal to ask since you think you should be F.C. is not equal.
44:18
S So only those elements which are not equal to X will be returned and well if I give it scares then the two S's get removed and I get that.
44:22
So there we go. So how do I define filter. There's another just using this comprehensions.
44:32
Of course this comprehensions can have predicates in them as well.
44:37
So the obvious way to define filter is to say that filter F of X is is simply the list of X where X is drawn from X,
44:40
but where they satisfy the property index. So again, because F because the function is a predicate, a better name might have been P.
44:47
So if someone's reading the programme, they say, oh P, that probably means a predicate.
44:56
When they say P of X, then that's just something triggers in the brain that says,
45:00
ah, there's no harm in calling it that because it's a very simple function.
45:04
And as I keep saying to you, and I'll drill in more and more actually coming up with good names for functions
45:09
and good names for arguments and good names where I was actually really hard on.
45:16
And it will take you, you know,
45:21
you'll get it wrong and you hopefully should be on the ball and they'll pick you up on this and you'll get gradually better at it.
45:22
OK. And yes, so when talking about complexity, using a list comprehension and using recursive or the different.
45:28
Now they turn out to be exactly the same,
45:41
give or take that we'll see later that this comprehensions they're actually it's actually just syntactic sugar.
45:44
And what happens to a list comprehension is it gets converted via the these things components into into just yet another recursive function.
45:53
So so one way of one way of talking about functions like map and filter, you say, well you know.
46:03
Oh I see.
46:09
So map is a very convenient way of taking functions that if I put a recursive function that applies, it does something to every element of the list.
46:09
I can just replace with a map. And look, the recursion is gone.
46:19
You see, when I look at these examples here, where is it these examples here, there's no recursion anywhere in the definition of that.
46:22
There's recursion and braininess comprehension that doesn't appear to be an indication,
46:30
but don't work beneath under the sink, beneath the scenes because.
46:34
All functions in high school have to be executed by recursion, so the only question is what sort of syntactic sugar do I layer on top to to make
46:39
the task of writing recursive functions or using recursive functions easier? Good question.
46:48
Yeah, but the answer is it is the same, even though superficially it isn't.
46:54
Right. So that's a filter. Right.
47:00
Let's do it. But then we'll have another break because the hard one is coming up. So what is it with to say this is right.
47:04
So what zip does ZIP says if you give me two lists.
47:11
They don't have to be the same, you know, that to be the same type. She or those.
47:17
It was simply up was the one guys with to the tune of the folks and the three with the phone and the seal,
47:26
there's all sorts of interesting uses of this thing is not immediately obvious why you might need it, but it often crops up.
47:32
I'll surprise. Right. So what is it with does is rather than just doing the zip, it actually implies a function.
47:39
So rather than just gathering one and true together as a pair and what zip it does is it applies a function to the one in the true.
47:47
So what might be a function in this case? Well, that's probably the slightly better example than I can come up with.
47:57
So supposing I've got to list of numbers to illustrate this, they would have a list of numbers if I zip with plus.
48:05
So let's see what happens. Well, what the zip would normally pair up the one with the nine.
48:13
But what is it with does it takes the one in the nine, applies the function plus to it so that it's as if I've got one two three nine five eight.
48:17
And I guess it's obvious it's going to do something like, OK, but the list,
48:25
the plus function gets applied to the one and the what was it like the one in the nine.
48:31
The second and the second one comes in applying the plus function to the two and the five.
48:40
We've got that right. And the third element comes in applying the plus function to the three and the one five eight was it.
48:46
And I get that. Why, yeah, OK, you get the idea, it's a generalisation of.
48:56
Zip, I guess so you might think, oh, what's the function that we just reconstruct the zip for me wouldn't I would never, never do.
49:06
This was a thought experiment.
49:12
If I zip with I want to zip with some function, one, two, three, maybe four, five, six or four, two, three, four, five, six.
49:13
So so if I did the zip. I get that.
49:25
So can I get the same result, but zip with what is the function I need to put in there?
49:31
Well, of course, life isn't defined yet, but if I say what is supposing I had a function which says,
49:37
OK, you could be an X and Y and I'm going to just pair them up.
49:42
Well, it's just supposing that. So now if I do this, it would have wanted to put.
49:48
What? There were nothing scop.
49:57
I will hide, hide, hide, no.
50:06
Don't you? Was it with his head, I was say, with this hidden but not defined.
50:14
Oh, OK. Yes, I see. And so OK, fair enough. And let me just.
50:18
I just check that out for nothing breaks about you, zip it anywhere else.
50:23
OK, what's happening? So then what happened that let's try again now that OK, no.
50:31
What? Oh, sorry, yes.
50:49
I've got to redefine. I haven't thought about. Remember, I've got to you're thinking what the [INAUDIBLE] happened?
50:52
I've actually got a function F in my high school script, which does something completely different for me.
50:58
So when you read the file, you have to rename. I've been in that position.
51:02
And now what should happen is a few so that reconsider.
51:07
That's a thought. You would never do this. You just use it.
51:12
But as a thought experiment, kind of constructive alternative, which is we just built bullpen's.
51:14
So there's another way of doing this, actually, that if you've come across this just yet.
51:20
I can do that. So in other words, this function here as a function which given two things.
51:25
Well, the problem isn't that lovely. Right.
51:31
So how will I define zip with. Well, it turns out, but I can define Zipp with using a list comprehension.
51:36
It's nothing quite obvious. Quite obvious why how I can do this. But supposing I take the two lists,
51:44
X's and whys and I first zip them up because I've got I've got to align the essentially
51:49
align the X's in the words so that X one gets matched Y one and X Y two and so on.
51:55
Well that's what's it does that will give me back those aligned elements in the form of pairs.
52:00
So all I have to do now is take pairs and that's how they use the pattern matching here.
52:05
So when I when I do the zip. So when I is the zip to generate an element, the elements generated will be pairs.
52:10
So I can irrefutably pattern match against each of those pairs and unpick them to give me the X in the Y.
52:19
The exciting the water, if you like, so I haven't got the axe in the way my handle looking to do, you have to.
52:26
OK, so that is exactly semantically what what does it should do?
52:31
And of course, I can define it recursively. How would you define it repressively?
52:35
Well, let's go here and let's do that and do that.
52:41
Let's put the zip with back. And now let's go down the bottom and see if we can define zipper.
52:49
So how would you define zip with. This is my version of zip right now, not the one I want to.
52:58
I won't put the in because we've only got to type on the screen just as I am typing.
53:06
Right. So is it because as you give me a function on two lists, so is going to be a bit like the zipping function isn't it.
53:09
So I do remember the zipping function we said will be the I think by the time will be factored that we said,
53:17
well, let's look at the case where both lists are non-empty.
53:22
So I've got to perform something like that. What do I do?
53:28
Well, just by the way, let me just come down here. What happens if I haven't reloaded the programme here?
53:33
So I think ZIP with is still find. So what happens if I say zip with plus, for example, and I give you two lists of different sizes?
53:38
As with the zip, unsurprisingly, yet they can only apply the plus to to it to those elements, so the three, four, five, six get discarded.
53:48
So if one of the one of the list runs out, we just stop. And that's exactly the behaviour we have with the Z, if you remember.
53:57
So what do we do here? Well, what we do what we do here is I take the X in the war and apply it to it.
54:03
So to F of X and Y and I doing that on to the left hand side, the result of zip code.
54:09
Here comes the recursion. Guess what, unsurprisingly, but but of course I'm just monitoring both lists at the same time.
54:14
I want to complete lists from left and right now.
54:21
In all other cases, if you think about it,
54:24
it must be the case that it doesn't matter what those two and it doesn't matter what the function is because
54:28
they must get the interest because one of the lists or both of them will have run out by this point.
54:35
Otherwise, I would have matched the rule about. So let's come down here now.
54:40
We like the programme and I should get now this is music with working now and sure enough, it does the right thing.
54:46
OK, very good. Right, let's have a break, because now we're going to be doing the phone.
54:53
This is the this is the this is possibly I don't know if this is the hardest bit of some students find this the hardest.
55:01
So have a break and get yourself a cup of tea. Oh, I think what was said.
55:09
Let's resume at five past 10. OK, we're back.
55:21
Welcome back, Daniel, your hand is Daniel Craig.
1:03:31
Your hand is still up and shows an old hand. But I'm just going to report this to Osity.
1:03:35
Did you just take your hand down or was it. No, I put my hand up right at the start when you asked if anybody could hear you.
1:03:40
But it has been down the whole whole rest of the hour since you just turned your microphone on.
1:03:46
It's now disappeared. Right. OK, great. But you did you didn't take your hand and just didn't like on you.
1:03:51
Yeah, OK, that's all. So I'll report that. Thanks very much. Good writing.
1:03:57
OK, so let's move on to Folden. So what's so, so, so much?
1:04:02
You give me a list of elements, I'll give you back on the list of elements with the functional block filter.
1:04:08
You give me the elements, I'll give you back to those items and so on and so forth.
1:04:12
Folds reduce the list in principle. Well, to a single value.
1:04:16
And the way they do it in the way to imagine it happening is that if if I give you a list of items,
1:04:20
it's going to insert a function application in between each of the items of the list.
1:04:24
So this is not Haskell programmes to show mathematically what should happen.
1:04:29
So in general, if I've got a list of non-empty list consisting of elements and I'm folding some blank, which is, by the way,
1:04:33
call this inset so you can insert the function F in between each element, which is what's happening on the right hand side here.
1:04:40
Yeah. And what's this? This is the unit of F so when we when we're folding a function into a list, we make sure we have to pick the right unit.
1:04:48
And this is a little guy that gets stuck on the end of the line as most of the last function application.
1:04:56
So we'll see how this works in just a moment. So the idea is, what do you do if you have an empty list, you return the unit.
1:05:01
What do you do for noninterest? Even said F between each one. By the way, what do you mean by inserting in between each one?
1:05:08
I've shown you this in prefix form. Here we come to the whiteboard.
1:05:14
Another way you could imagine this if I've got if I'm folding. This is this is the right to when it comes the left, this one.
1:05:19
So if you must know an operator and I'll just just call the operator,
1:05:28
but just to make something something up with some units here and I've got a list I want to explain.
1:05:32
Sometimes it might be easy to think of this if you call an operator here rather than a pretext function.
1:05:38
So what you're literally doing is you're taking the list X one, two, three, and now two X in.
1:05:42
Yeah, and you're literally sticking this approach in between each one.
1:05:52
So this is hence why some language is called insertion by.
1:05:57
And there's one extra thing on the amnestic this year, and the only issue is with this issue,
1:06:02
because it's right associative, the bracketing works like this. So we do that first and then that, too.
1:06:07
So. So that's what when we say it's a right associative fold, you know, we do this thing out here first and then this thing in brackets, if you like.
1:06:14
And that that defines how we define that, specifies how we define the function.
1:06:24
Right. So what about left associative folie works the other way round.
1:06:31
So the first thing that gets bound or the first or the first, the first element of the list gets applied is the X1.
1:06:36
So and just the subtle points to note that the argument is the other way round.
1:06:45
So we apply the act to the unit and the one where is above.
1:06:49
We applied F to the the last element in this case because relies on the unit.
1:06:52
So the item and the unit. Flip when you're doing a left associative, but that's the structure now, so you start with the in the innermost one,
1:06:56
you apply to you next one and then that becomes the leftmost argument of the next application of the right one being the next steps and so on.
1:07:06
So you work your way outwards. So I'm going to draw this a different way.
1:07:17
I should make a little bit clearer, a bit difficult to see when you see it syntactically as a string come to the whiteboard.
1:07:19
So let's think about what fall right does. So in general.
1:07:25
All right, if I were you, there's my unit and I've got some X want to X and.
1:07:30
Along with commas in there, of course, right?
1:07:39
So the way to picture this is what happened so I can draw is as a tree, it was a graph, which is something we've seen before.
1:07:42
So what we actually get is, first of all, the application of F to X1. And what's the rightmost argument about?
1:07:50
Well, that is the application of F text two to the application of F to X three and so on and down
1:07:56
the bottom here we get the last application is an application of X and here comes the unit.
1:08:04
So what about souled left. So left if you want to extend.
1:08:11
Well this is the other way up. So the first thing that happens is that the F.
1:08:19
Down here gets applied to now the other way round,
1:08:24
so the unit is now the leftmost argument and the XPoint appears in here and that becomes the leftmost argument of the next application of this.
1:08:27
So out pops the to that becomes the leftmost and so on.
1:08:36
And that becomes the leftmost argument of the top level f eventually where that gets.
1:08:39
And so you can see graphically that quite just they do seem to think that a different order,
1:08:46
I guess the bottom one on the folder will be X one on one.
1:08:50
Thank you so much. Your. It can keep up.
1:08:56
Yeah, right. So this one you start with the the photograph, you start with the explosion and I feel like you start.
1:09:04
You start with the arm you started, the application of your next one is the bottommost and it's the innermost nested there,
1:09:15
which is which is why when you come to look at the thing and this is reflecting the wide expressions bracketed.
1:09:25
So I could draw something using that live symbol, which is now right.
1:09:32
So this year is the universe. It's probably before, I think of the types that just look at some examples.
1:09:37
So, in fact, if I come back to the magic whiteboard here, supposing I replace this F here, I supposing this in this case,
1:09:42
I was interested in adding up some element so that if I replace that plus can you see what would happen if if each F becomes a plus,
1:09:49
I go it's X one plus two plus X three plus and so on.
1:09:57
And which case, what would the unit have to be the it would have to be if I'm adding things up, the unit would have to be zero wouldn't it.
1:10:01
So if you tell me I'm folding plus in into the list, I'm reducing the list using plus it tells me that the unit should be zero.
1:10:09
And if this is a multiplication, then the unit should be want to get the right answer.
1:10:18
It shouldn't be zero anymore because with a zero.
1:10:24
So this clearly the unit would have to be one. You see what I mean?
1:10:27
So if you told me the operator, each one of the function or the function defines what the unit should be.
1:10:29
So these things are two peas in a pod are I guess it's similar with the with the total left.
1:10:34
Here are some examples, so I give you a list of numbers I want you to reduce or collapse the list of numbers into a single number by adding them up.
1:10:41
And that's one way of doing I can use a phone. Right. But of course, it's associative edition, so it doesn't matter where I go.
1:10:51
So left off. All right. Interestingly, so if I wanted to stumble into this, I've got a choice.
1:10:56
Which one is best? Actually useful. Right. Actually useful. Left.
1:11:01
And if I want to multiply the elements of a list to form a product, then I choose the unit one.
1:11:05
What if I wanted to concatenate night all the elements of a list of lists?
1:11:11
That is a list of list of characters is a list of strengths. So if I wanted to join other strings together, well, again, what should I use to run?
1:11:16
I've got a choice, I guess. So what is the name that goes? Well, that's the list.
1:11:25
So one way to think about the unit is that this is what to do if the list is empty.
1:11:30
So just some an empty list. The answer must be zero. To form a product of an activist, the answer must be one to encapsulate an empty list of lists.
1:11:35
The answer must be the list. So it just kind of tells you what to do when the list is empty.
1:11:44
And if you can think of is the base case of the what's going to be the recursive definition for the function?
1:11:49
Oh, here's an interesting one. So if I hope the Commons function.
1:11:56
Oh, yes, indeed. You can pass the constructors as parameters as well because they are just functions,
1:12:00
yet they don't do anything, they just construct, but they're nonetheless functions with types.
1:12:05
And therefore, if you can pass plussing to function, you can plug into a function.
1:12:09
So if I class, if I fold comes into a into a list giving it to the unit being the empty list, it reconstructs the original list.
1:12:13
What does it do that because we come to the whiteboard. What expressions.
1:12:22
Blindfolding. This function using that unit into this list.
1:12:27
Just keep it simple works, one, two, three, what is that going to do?
1:12:37
Oh, I see. It's going to be all I can draw is a trailer I can draw as a string towards a string.
1:12:41
This time it's X1 or neutze b F of X one, but actually it's an infix.
1:12:45
Operators will actually draw is an X operator. So this time is X one and I'll put the brackets in if you want X two Conn's.
1:12:49
See, I'm inserting the cones in between each element of the list. There's the X three cons and that's my last element.
1:12:58
So now I stick the unit in here with the unit is the empty list. And you can see that's equivalent to just the list I started.
1:13:05
So you'd never do this, but it's just the identity function on the list.
1:13:12
But it's an interesting thought experiment. That's a square bracket.
1:13:17
OK. Right.
1:13:22
So how would we define right and have, oh, Gingin, yes.
1:13:26
So when when you took pick whether we use Ford right or left, well, we can't say about the left or right associativity.
1:13:32
Yeah, we're going to come to that in a minute if we have a choice.
1:13:42
It's quite useful to think about which one we should pick and why we will have to rationalise about why we pick it.
1:13:45
Oh. Right.
1:13:52
So how would how shall we define for. Maybe we should just do it.
1:13:56
And I don't think there's a definition on the on the the notes.
1:14:00
And let's go straight into our magical programme and.
1:14:04
Now, have I got. How about hidden so just me didn't have Good Housekeeping here, have I hidden it?
1:14:11
Do I use it? Should have.
1:14:19
Right. So days in there. So that's OK.
1:14:26
So I think so long as I hide it so GHC can't see it, then I can use the same name so long as like as long as I get the.
1:14:30
Right. So I get it correct, so fold, right, let's just say that she actually going to type the type out again,
1:14:42
because it's quite useful, I think, because because we haven't discussed the type yet.
1:14:49
So I'll do the talking just a minute. Let's just get this get the definition right. So here's my function F.
1:14:53
Here's my unit and here come the list now.
1:14:59
I'm going to use pattern matching. Now, I can't define fold using a list comprehension and you can go and think about why that's not possible.
1:15:04
But I do know that if you give me a list, there are two possibilities that the list is empty, which I've got to work out what to do or.
1:15:11
The list is non-empty, and I imagine that is a pattern that matches, that is something like that,
1:15:19
you can choose any name of one X and X is just fine because it's a polymorphic function.
1:15:25
We'll get to the next nexus in this case. Right.
1:15:31
Here we go. Well, as I said before, if you have a dentist, we know what to do.
1:15:35
That is the unit. That's kind of what the units for, it tells me what to do if I run out of elements.
1:15:39
Well, what about this case? Well, the case of the writer, such twofold, the first thing I did was to apply F to X,
1:15:47
the first element, and then I recurse that generate the rest will generate the rest by recursively.
1:15:53
I don't I don't think I was going to put a bracket and you don't need to put the brackets in there
1:15:59
because the president's economy is very low and the president's application is as high as it gets.
1:16:02
So in this case, I can just fold right now if the same unit and I just push the rejection into the table.
1:16:08
So it is just almost automatic. I just I just simply recurse with the Xs instead of the list I started with, I'm crossing into retirement.
1:16:15
Well, now let's think about the types. Right. So this function takes.
1:16:23
We're all in this function, takes something, so it's most general type is we think of this as taking and that's not right.
1:16:30
That's not right at all. What about God comes in?
1:16:40
When I was typing, I was I wanted to put a bracket in there and I took it out because I wasn't thinking I was I was trying to wipe map out.
1:16:46
Right. So the left argument of the F the first step is the X. The rightmost argument is the result of the recursive call.
1:16:52
Now let's come and think about the times. All right. So what does F do?
1:16:59
It takes two arguments. One, the first argument comes from the list.
1:17:03
So if I scored a and it takes another argument. I can type correctly,
1:17:07
which let's just try that with the system that's got some arbitrary type B. I'm going to think about what what type of thing I'll get back.
1:17:13
Well, the OK, from the construction here, I can see that because if it's been an X, the X must be an egg and therefore this list must be a list.
1:17:21
So that suggests that the list should be the input should be a list of A's.
1:17:29
And what am I going to get out? Well, OK, so there's one more parameter, of course,
1:17:34
which is the unit so that units will let me call that B for the time being and let's see what I get out.
1:17:39
Well, actually, the result here is that you said the result must be if this first rule is correctly typed, the answer must be a B.
1:17:47
So now we're going to do is to finish up just to think about what the type of the effort is.
1:17:54
I'm going to fill this thing in here. What's that? Well, this says you give me an A and you give me something.
1:17:58
Oh, that's the sort of the recursive call to fold. Well, every time I call fold, I get back a V.
1:18:06
So the second argument of the F must be a B what we knew that anyway, because I kind of guessed it, what's the result?
1:18:13
What we know every time you move forward, you must get back a B. So that means that the customer must also be.
1:18:18
OK, there we go. So let's just see that let's go down here and let's hope that loads, OK, doesn't like it.
1:18:25
So you feel like the list of A before B, whereas the older people passing it is B and then A it is.
1:18:37
Is that going to affect? I mean, let me just.
1:18:45
Um. The definition you listed before will be there as well, be before it listing.
1:18:54
Oh, sorry. Yes, of course it is, yes, I've just type things as well.
1:19:03
So the first argument is the function. The second argument is the argument is the list of ways to as I said, it's too early in the morning.
1:19:08
Right. That's better. Right. So let's just try this out.
1:19:18
So he says if I give it the plus function in the unit zero, I should be able to summon some of the numbers.
1:19:20
That's great. And if I give it, let's think of another function. Well, the product function.
1:19:26
And if I give it the one that gives me the twenty four and so on, so forth, just to test it, I suppose if I give it the unit,
1:19:32
which is that and my function I pass in is the constructor, then I reconstruct the original list.
1:19:40
Marvellous. OK, what about foaled left.
1:19:45
So what about Ford left? So let's think about this, so I'll do a little work on the tape in just a second.
1:19:51
This is a leftist bold. Let's do that in just a second, so Faud left is a little bit more a bit more tricky this time.
1:20:00
So here comes my function, here comes my unit in that order must remember, right.
1:20:08
Unsurprisingly, I just get back the unit if I run out of balance.
1:20:13
So that should be straightforward. What about foaled left? What about the recursive case?
1:20:19
Rather supposing I've got a list X Constanta taxes.
1:20:23
What do I do here.
1:20:28
Well, if you go back to the slides and you look at this, you can see but the first thing I do is to apply the F to the you in the X one.
1:20:30
And that becomes the leftmost argument of the next indication of the F.
1:20:42
So that suggests that what I want to do here is to just recall the full function again to get those out to EFS.
1:20:48
What happens to the year? Well, the issue now becomes the application of so imagine this is the next one.
1:20:58
What should I do? What did the EFF of the EU and the ex want you to remember?
1:21:03
The year was the first argument of the EFF and the the excuse of the second argument.
1:21:07
So that in my was in the function and the next time round is replaced by if you like, if you, if you ex.
1:21:12
So if that might be useful, what I'm doing is to come back to the whiteboard.
1:21:20
Remember the what, what do we have with the phone left. We had an application of EFF to you.
1:21:25
And this one and that became the leftmost argument of the next implication of F with X two and so on,
1:21:32
this became to the extreme studied and at the top we had the X in cities back.
1:21:39
So so here we look at this function in the location here they left leftmost argument is the unit and the rightmost argument is the one.
1:21:47
You look at this one here, but draw a circle around that.
1:21:57
It's exactly the same structure as the one underneath it. Look at the same structure as the one underneath it, except the year is now February one.
1:22:01
And if I look at this one,
1:22:10
the leftmost argument is that so can you see how starting with you get a sense you can think of it replacing you with FMV one,
1:22:11
then replacing that with F F A view with X1, x2 and so on.
1:22:19
So we're accumulating an answer as we wander up the tree and eventually when we get up to here.
1:22:23
Yeah, the unit is now all this lot in here.
1:22:28
So that suggests when I come to this thing, that the unit gets replaced by an application of F and I have another go.
1:22:34
So what happens now is I pushed the into the exits, so that's that's that's that's tricky, isn't it?
1:22:45
But when you draw the diagram, it's kind of obvious that it's doing the right thing. So let's get the typewrite.
1:22:49
So the function is going to be something which takes well, if I inspired by what we learnt from the type of flow.
1:22:55
Right. Which is this type signature here can be something similar.
1:23:03
But now the unit is the first argument of the act.
1:23:07
So this should be B to it's been a bad day for B to A.
1:23:11
To presumably be seen just a minute, we'll check it all lines up there is my that's my function.
1:23:19
There's my unit, which is now V here's my list, which is a list of A's.
1:23:26
And I must get back now. And it's not a list of on collapsing the list into a single item type B, so that looks good to me.
1:23:31
So here F is being given a, B and then A and it gives me back a B, so the full function as its second argument should be a B.
1:23:41
Well that's right. That lines up with that. And then of course the list of A's will do just a little bit.
1:23:50
So let me do that. Let me do that. Let me see if that loads up again.
1:23:55
Ah, so I'd forgotten to Heidfeld left and right. So if I also hide the phone, let's say.
1:23:59
Should fix that. Right, good, so now presumably I can do what I did before.
1:24:12
Except instead of all right, if I've got an associative operator, I can just do that.
1:24:21
It's just actually one up the screen so I can do that. And similarly, because multiplication is associative, I can use the same function to multiply.
1:24:26
And as long as I get the unit right and so on and so forth.
1:24:35
Can I do this? Cannot replace the with an owl here.
1:24:38
What's going to happen? But a break?
1:24:44
Oh, yes, it's going to break records, the list. Maybe it's because the the list.
1:24:51
Well, the concept, if it's fold, are that it creates a list of from the right side because it joins the four,
1:24:57
which is the final element in the provided list of A's that you give it.
1:25:04
It adds that to a list. But then if you were to do that from the left hand side, it wouldn't be able to create the list.
1:25:08
So what's the problem with this? Any one word or two words? The arguments are the wrong way round the clock.
1:25:14
Yeah, it's the wrong way. It's a typo. I mean, this is a typo.
1:25:22
Because what you're trying to do, what is left to take a slightly simpler, less what type of what is what is today trying to do here?
1:25:29
It's trying to it's trying to do what it's trying to do.
1:25:37
F of so F is the constructions trying to apply the construction to what did I give it?
1:25:41
I gave it the unit, which is the empty list and the first item, which is the one.
1:25:48
And that became the parameter of the next invocation, which is that one here I guess.
1:25:53
So that gets that is its argument and then the two and that becomes the argument of another one.
1:26:03
And the three and you can see it's just broken because what it comes to, Conn's takes an item on a list of items in there and it's a list of items.
1:26:12
And here I am trying to give it the list of items and that it's the wrong way round.
1:26:21
So and it's not surprising because Condes is not associated,
1:26:27
therefore I shouldn't be able to just simply flip the phone and replace it with the phone.
1:26:30
It should break and it doesn't break, but it breaks because it's a type. Good.
1:26:35
All right. All right, here's a puzzle, supposing I wanted to calculate the smallest element in a list of numbers,
1:26:42
for example, so I'm going to try and use for right.
1:26:52
To do this with just a little bit of space here so we know what mine does mean.
1:26:56
Calculate the smallest of two things as we learn that in the end, your first love exercise.
1:27:01
So let's see. So supposing I wanted to calculate the smallest element.
1:27:08
I'll give you a list of numbers, Somerhalder. I want to know what the smallest element is.
1:27:12
Oh, I've just got to fold mine inside, it hadn't done well.
1:27:20
I got to do is pick the right unit and I'm done. Plus, the customer.
1:27:23
Minus infinity is infinity. Yeah, I guess it's mine and you said, because you happen to know that it's a list of numbers, didn't you?
1:27:32
Yeah, yeah. But supposing it an unlisted number, supposing it's supposing I'm not trying to calculate the minimum a list of numbers,
1:27:41
but supposing I'm saying it's a list of numbers that you kind of guess it's minus impermanency,
1:27:49
but in general what should I pick for undefined with that one.
1:27:54
Oh oh I'm not sure about undefined. The first element of this that's going to just break immediately the first item into the list.
1:27:59
Yeah, I think I can use the first time into this if you had some way of actually folding from the beginning instead of using the initial value.
1:28:09
So in general, what let's go back to this.
1:28:19
Well, I got the question mark in here in general, what should I take?
1:28:23
So if I just give you a list instead of instead about telling you, I've told you that if it ends, you can kind of guess,
1:28:33
but if I go next one and two and I don't know anything about them except that they're just a bunch of objects.
1:28:39
What should I choose for? Could be undisclosed. Like something like a wild card game.
1:28:47
Well, no, this is a unit. So the unit is going to get used in it if I come across here.
1:28:55
You know, this unit gets used if the list is empty.
1:29:02
So I guess what I'm saying is that I guess you're saying because we've got to supposing I do that,
1:29:09
what in general is the correct answer to that question? There's no correct answer.
1:29:15
There is no correct answer. You just don't know you cannot come up with an arbitrary result unless you know something about the type of the object.
1:29:20
So if I give you the empty list or I say here's a list of things that of object, you've got no idea what the unit should be.
1:29:29
So you can't you can't use fold right or fold left to do something like calculate a minimum.
1:29:35
But surely I can write something like this because you've done this, this is your very,
1:29:44
very first lab exercise, you can say with I got one, two, three, for example, how do I calculate the minimum?
1:29:48
One, two, three. Well, you calculate the minimum of one and you calculate the minimum two.
1:29:53
And the third one is the minimum of it. I say three and four. Suppose you got four.
1:29:59
And so we know. Well, that's that's that's fine.
1:30:03
So given a list, something like X one, X two, three, four or less, you just keep it extra, just slightly simpler if it wanted the minimum of that.
1:30:05
Yeah. What I would jolly well hopes is to be able to do so. I can, I know I can replace that with the min of X one.
1:30:15
The men of X to. Just do an X-ray and see if I got more elements yet I can do that.
1:30:21
What's missing from that and that's absolutely correct, is unequivocally going to do the right thing.
1:30:29
What's different about is there's no unit and there can't be a unit because we wouldn't know what you did to pick.
1:30:34
So, yes, I can use a phone to do a minimum, but it's a slightly different type bifold, isn't it?
1:30:42
It's a full without a unit. And you think, oh, wait a minute, wait a minute.
1:30:48
If there's no unit, how do I know what to do in the case of an empty list?
1:30:52
And the answer is you don't, because if I'm trying to get a minimum, I'm never going to ask you for the minimum of an empty list.
1:30:58
Because you wouldn't know what to tell me. Because I haven't told you anything about the top of the list.
1:31:06
So it's the same thing, you wouldn't know what answer to give.
1:31:11
All right, so it turns out that there is a full function which enables me to do this sort of thing,
1:31:15
but without a unit, it's called Foaled Unimaginatively, it's called foaled.
1:31:20
Right. While there's two variations left and right, one, the left one.
1:31:25
So they're very similarly structured to the phone left in the phone. Right. Except there's no mention of it.
1:31:29
If I come back to the whiteboard and draw the full picture, let's do the right one. This is an application of so fold right one.
1:31:33
Of some function have been to some list, wanted to X, and this gives me this exactly the same as before,
1:31:41
except when I come down the bottom here, there's no unit. So this must be X and minus one and this must be X.
1:31:51
And so it's just a variation on the same.
1:31:55
Oh, there's a couple of hands up and you've got your hand up.
1:31:59
Yeah, I'm just wondering, you said that we can't really do a minimum using like the fold or like to unfold our full function.
1:32:02
But then can we just, like, not put like that you'd ask like the first element of the list because like that would might be different.
1:32:13
Yeah, that works in that case because, you know, it's a list of numbers.
1:32:20
But the thing is, what do you what would happen if I asked you for the minimum of an empty list?
1:32:24
There isn't a settlement, so you can't do that. Then how about, like, if you put out a special case, like if it's empty,
1:32:29
I'll be like another case, but if there are elements of that we can use, like the first element.
1:32:40
Right. Right. So actually, what you're suggesting I'll give this thing because I'm really this is homework for you and
1:32:44
you're suggesting what you what you've hinted at is actually a way to define this thing.
1:32:50
There's a forward left version of this with a government which does the same sort of thing, said, you know what I like down here, brother?
1:32:57
My unit, I've got X one X sue now.
1:33:03
And then I come up here. The that one does it the other way round, isn't it? It's one up the tree.
1:33:08
And what you've just hinted at is a way to define it left one because it's actually quite tricky.
1:33:13
It's unlikely that suspended in the air for you to contemplate myself.
1:33:18
The question, what was a problem with using, for example, X one as a unit again?
1:33:22
What happens if I give you an empty list, you haven't got the next one. OK, I see, Daniel, is that your old hand reappeared from the other?
1:33:30
No, no, I that was I did. I'm just curious, in one of the exercises on the NHS sheet, we used Max Bound.
1:33:41
Yes. So just curious, like I've tried I've just tried out.
1:33:49
It doesn't work. I'm just curious why wouldn't we be able to use Macs bound in order to calculate the minimum to just say,
1:33:53
why can't Haskell infer what the type of Macs should be based on that we've also passed in another integer?
1:34:01
Well, there's a couple of problems there because the type has to be bounded. So there has to be a constraint right around the constraint.
1:34:07
And secondly, again, what do you do with an empty list? Yeah, you can't calculate the max bound of whatever it has.
1:34:13
It has no what's the what's the type. An emptiness is less of a what's the what's the max boundaryless device.
1:34:20
Don't know. Yeah. Great. Thank you.
1:34:27
I think the answer is, I mean if you tell me the type of the items in the list and you tell me that
1:34:30
it's a non-empty list or maybe there's maybe there's a default or something.
1:34:35
Yes, of course you can control the definition.
1:34:40
But for a completely general polymorphic well, sort of polymorphic minimum or maximum problem, you know, you can't write down a definition.
1:34:41
You can't write down a definition. You can't say what happens. In the case of the emptiness, there is no sensible answer.
1:34:49
Session. You've got a question. Hi, sorry, I didn't quite understand how how we define the type signatures for the Foden photo functions.
1:34:55
Could you explain that if I'll come back to that in just a second.
1:35:07
Sure. OK, Drouth. Oh, yeah, what happens if you fall R1 or fold L1, for that matter, an empty list?
1:35:10
Let's try. Guess what, I think there'll be a tiny bit of.
1:35:22
Because it's expecting, I'm guessing, tonight or some other.
1:35:28
So. Um, if I if I.
1:35:35
Is that a one?
1:35:43
Yes, OK, yes, I find it that one is a runtime error because you've given it there is essentially there is not a rule for the empty case.
1:35:46
Thank you. OK, you're welcome. This is a hold hold hands, Morsell, your hands up still is an old one.
1:35:57
You. It's the old hand, and I think it's ugly and real.
1:36:04
This is an old hand as well. Hakone, you've got your hands up. Oh, yeah, yeah.
1:36:09
Um, what happens if you fall? Well, one of our one men with a list of one item Singleton.
1:36:14
But that's going to help us to define it, isn't it? What do you think should happen?
1:36:23
All right, one minute. That gives us a clue, doesn't it?
1:36:28
That's the base case, isn't it? So you like it in toys?
1:36:35
Yeah. We merged,
1:36:41
so we had a special case with a Singleton list that this is actually the best case for the far right and far left won cases because there is no unit.
1:36:44
So. So you've been kind of hinting at this before? Oh, if I if I got one of I can to head to did it.
1:36:52
Well, actually, this also defines the base case. Arson you got to question.
1:36:58
And so I'm just confused as to why you would use the fold function over the phone one of situations and you have.
1:37:04
The fold, right, rather than the full right one. Well, it's a question of whether I got see whether I could have sensible units so I can write,
1:37:11
I can use full write one to add up the elements of a list.
1:37:19
So why why not use the phone? Right. Well, the question is mathematically that is perfectly well defined.
1:37:24
So I would expect to get zero if I use. Right. One, I don't.
1:37:31
So if I'm just doing things like something or forming products,
1:37:38
I should use the right version because if I use the right version, I can give it the unit and that will now do the right thing.
1:37:41
With that, I'm using do something about minimums and maximums. I can't define the unit.
1:37:49
Therefore I shouldn't be. Shouldn't be. I shouldn't be worrying about Anjali's and I should just be using the phone.
1:37:53
But one barett session. You've got a question. No hard sell.
1:37:56
It was just an old hand. It's a team's hand, we call it a team. All right, very good.
1:38:03
So perhaps. Absolutely come over here.
1:38:09
Do I want to differ it, how do I define full right one? Let's do it.
1:38:16
I suppose I'd better just hide it. Before I come here to find full oh, yes, somebody wants to take, but I'll tell you what,
1:38:22
shall I explain the type of phone right when I come back into the fold? Right. It's not clear from this one.
1:38:33
So let's two fold. Right. One, let's think about it. Type in just a minute.
1:38:36
All right. One says, right. So you give me there's no unit now, but there is a function.
1:38:41
And what was the base, because we hinted at this, that I can't say what to do in this case, they that that rule cannot exist.
1:38:49
It's going to define what sort of partial function. The function is only defined on a subset of its input domain.
1:38:57
But I can say 100 because Singleton list, I've got a Singleton sentence and that's the pattern for a singleton.
1:39:02
So then the answer is just the X. Yeah, we discovered that.
1:39:08
So if I say fold right one of F over a noninterest, it should look pretty much like, in fact exactly like the case.
1:39:12
I've got to button but I can just cut and paste it. Exactly the same as the storm.
1:39:19
So what's the time signature for this now, except the unit shouldn't be there?
1:39:26
Oh, so there shouldn't be an absolutely. About just about, as you said, actually.
1:39:30
So I don't want that there is no unit. So what's the time signature for this?
1:39:34
Let's see, so the let's suppose the the the the lowest elements of type spending.
1:39:40
This debate, as always. So I don't. In the recursive call folder, will it be full of one another?
1:39:48
Oh, well, one, thank you very much. Never cut and paste, just type. It's never worth it.
1:39:57
All right. So what's the take? There's a little arrow here. So what's the type of the function now?
1:40:02
So this is going to be some function in here, right?
1:40:09
So let's see, what does the function do? Well. It's going to take another day because I can see how I have used is this must be an.
1:40:13
It's been high and it takes well, it takes something, whatever I get back from the court to right one, it takes one of those as well.
1:40:24
So let's go to the base case, the base case might help me, so right here we go.
1:40:35
So now this thing. So that's a list of ways, therefore. Oh, the results of the function is same.
1:40:39
So I now know that every time I invoke the function, I get back in a and therefore this F. So when I'm like that function, I must get an A.
1:40:47
That's an F. Must be a way to I mustn't it. So that sort of lines everything up, so straightaway let's debate it right?
1:40:56
So just double check that. That's a list of A's. So X is an.
1:41:09
So that must be in a. Well, that's correct. And that must be a list of A's.
1:41:14
We know that anyway. This that and a the result of each invocation of the fold is a 848 a and the result of course must be a.
1:41:18
So similar reasoning with the these guys here, should we just pick this one just because I've been through this once before,
1:41:29
somebody asked me if I could go through it again. Right.
1:41:35
So we know that that's supposing that we're given a list of.
1:41:39
So this thing in here was a list of A's and this thing is a list of A's.
1:41:45
Therefore, the X must be a. And the axis must be a list of.
1:41:49
So therefore the function takes an.
1:41:54
I do know that that explains that right now I'm just going to try the other two bits of the the functional signature.
1:41:56
Let's look at the base case. So here's my list today. Here's the unit.
1:42:03
Well, let's suppose the it's got some other type B then. In this case, what I'm told, I get back at base.
1:42:07
So the answer must always be a B every time I invoke foaled, right.
1:42:13
I get back in B. So therefore, every time you vote for a vote, right, that must I must get back.
1:42:17
That must be there for Ribhi.
1:42:23
So the function must take in and B, which is explains that, and the result is the implication of F, so every time I look forward, right,
1:42:26
including this thing in here, I must get back a B. So therefore, if you think about it, F must be A to B to B and everything and lines up.
1:42:35
Does that answer the question? I seem to appreciate you've got a hand up with an one.
1:42:43
It was an area that is the threshold, could you could you explain why we don't need a unit in the world?
1:42:50
One is. MBN is.
1:42:57
Well, this one here. Yep.
1:43:05
Because the thing is, when am I going to use fall, right, when I can be using fall, right.
1:43:11
Want to do things like minimums and maximums? And it comes down to this question, what is the matter of an interest?
1:43:16
But normally it's like, oh, I have a unit for that. But you don't know what it is yet.
1:43:22
Thank you. Yeah, cool. Right,
1:43:27
so now a bit of homework for you to think about and you've kind of sort of
1:43:33
painted about this before with maybe all of you can sort of painted about this. How would you how would you define Thode left?
1:43:37
It's going slow on me. How would you define Thode left one?
1:43:46
Justin. Think about that. Well, what we can point out before we stop, we're getting near the end, I think we probably had enough so.
1:43:52
Let's just have a look. So let's look at the structure, let's get to the old left version in here.
1:44:04
So so this kind of gives you a watch. We've got a definition of old left.
1:44:10
Let's just get back to the old left here. Right here, here's opinion of far left and fold, right?
1:44:14
What can you tell me about foaled left?
1:44:24
Particularly looking at that right hand side, Zach tell of its tail recursive, at least in principle, it's tail recursive.
1:44:32
So that's interesting. Foaled left is potentially tel recursive forceful, right?
1:44:41
Absolutely isn't, because here, having invoked the recursive made the precursor called the full right, I don't have to do more work.
1:44:46
I've got to apply to to the result comes back. Whereas with the left I just, I just, I just call the function itself essentially OK.
1:44:52
You can think of this, this second argument here being an accumulator which accumulates the answers.
1:44:59
So starting with you we go f you x1 and then we change it to a few x1 f f x next to and so
1:45:05
the accumulated gets you can think of getting bigger and bigger and bigger and accumulating,
1:45:13
accumulating, accumulating each time I go round the round the loop so to speak.
1:45:16
So this is a key Carmelites, the answer and when everyone out to relevance, this is the answer.
1:45:20
So Altec pops. So you can think of this as a bit like an imperative programme, like a javal potential,
1:45:26
whatever your favourite language is, and what he calls a separate variable. And Keema later and each time round a loop, you update the accumulates.
1:45:31
We know that anyway. That's what tubridy, as it functions, do for us.
1:45:37
They turn recursive functions into loops, essentially.
1:45:41
So why isn't it emphatically recursive and it's because of lazy evaluation on the recursive call,
1:45:45
I've got this few extra the application to you an X, and the question is, when does that happen?
1:45:51
And in this person, as I've written, it happens right at the end.
1:45:57
Say what you end up doing is assembling and your computer's memory a great thumping, great expression, which looks exactly like that.
1:46:01
But that is exactly what will appear in the memory of your computer.
1:46:10
Nothing has happened until the result pops out and somebody says, OK, can you print the result or can you have gone to it or something?
1:46:12
And then suddenly these things get computer so well that in principle, terrible of operation.
1:46:19
It is now, it turns out, as a variations of the design of the language spotted this.
1:46:24
And so this is madness. You know, we've got we've got a lot of celebrities to function.
1:46:28
People should be using it to do efficient style computation, and yet it doesn't because of lazy evaluation.
1:46:32
So there's another function called Thode left one prime, which will do the job for you.
1:46:38
So that one actually forces I mentioned earlier are talk about strictness. So that is essentially a strict version of the Fogler,
1:46:45
where it for us is the evaluation of its its second argument, and that gives me operation to the hybrid.
1:46:53
I want point so around as a question, I think with a new hand.
1:46:59
Yeah, I just going back to the inputs, right. Could you explain why is it a like for the function A to B to B?
1:47:06
I got the B to the list to B, but I didn't get the function.
1:47:14
You're still not convinced. Why is this only to be. To be. Yeah, but are you happy with the.
1:47:18
It takes a nice. Yeah, but what is that?
1:47:25
What's the type of that? Every time I invoke the old right, I get back a.
1:47:32
Yeah. OK, yeah, so that must be a type B, so therefore F must be A to B to something.
1:47:42
Well, every time I fall right, I must get back a B, therefore that must be a B otherwise if that's supposed to be a B and that isn't a typo.
1:47:50
So that thing, that thing must also be in other words, the results of the invocation of F must be A B.
1:48:00
Oh, yes. Yeah, and it kind of joins up, doesn't it?
1:48:07
You kind of have to make some guesses and that's how it all works now. And I can tell you, that's exactly what the inference algorithm does,
1:48:10
will be will be studying this in depth in the new year because it will be one of your practise exercises for the general test.
1:48:16
OK, who was that, was that Ryan Browns got to hand up with an old hand SRN?
1:48:25
No, no, I think you've got an old hand as well. It was just it's a team's hand, I think.
1:48:33
Is it? Yeah, right. Let's just see if we can probably wrap up at this point anyway.
1:48:37
So let's see if you can see if you can define fold, collect one yourselves.
1:48:46
It's actually quite tricky. I'm sure you'll get there in the end, but it kind of hinted at how you might do so.
1:48:53
OK, and the other thing I'm not going to be doing scanning what's going on. That's something you can do.
1:49:00
You can set that to yourselves as an unassessed exercise for you to ponder.
1:49:06
I might just try. I might I might start next time by going through through the phone.
1:49:09
It's a great read the notes. Your job is to read slides. Excuse me.
1:49:14
I'm just going to make. But so your job is to have a read of those lies for skeletons can right and see if the challenge is can you right.
1:49:22
Scan what can can you define scan one. Scan that.
1:49:34
OK, so I think I'll stop because then I'll finish up this next time and then we'll move on to Extension's, so I'll see you on.
1:49:38
Oh, there is a catch up with you before I go. There's a catch up tomorrow, 10 o'clock.
1:49:47
If you're if you're stuck, I'll be here. But it's a Q&A.
1:49:51
So you just come along with questions and if you don't have any questions, I'll pick randomly pick some questions from tutorial sheet too.
1:49:56
So we'll focus for this week on the catch up will be on defining straightforward functions over lists.
1:50:04
And at the end, if you've got questions about how it functions, I'll take them.
1:50:11
And I will tell you today, the first Abath programming will not be this week because we need to finish up the whole of functions first.
1:50:15
So the first advanced programming lecture will be next Thursday. So one of us will give that.
1:50:23
I haven't decided yet. OK, have a nice day. I'll see some of you tomorrow.
1:50:29