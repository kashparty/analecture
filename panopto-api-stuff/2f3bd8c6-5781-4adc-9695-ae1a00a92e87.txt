ID: 2f3bd8c6-5781-4adc-9695-ae1a00a92e87
Title: Haskell XML Exercise-20220110_143056-Meeting Recording
Category: Haskell
Lecturer: Anthony Field
Date: 11/01/2022
Right. OK. Good career stop.
0:23
Go. Oh, God.
0:29
Right, OK, back to square one. Right,
0:45
so I'm going to assume that you've you've read the exercise and it doesn't need explaining other than how perhaps our best to solve the problem.
0:47
So I'm just going to go straight in what people want to see, how we're doing for time.
0:56
We'll have a couple of breaks and see if I can do it tomorrow. We got some two hours.
1:00
I see how fast we can rattle it all. I did a dry run over lunch just now, and I managed to get it to work, so that was.
1:06
That should be should be good. I can reproduce that, so here we go.
1:17
All right. So let's do the easy ones. I won't be too much explaining other than perhaps just to point out what I think is a really nice solution.
1:22
I won't spend too long on these. Well, I think the best way to do this is to just drop as a function for this space, which you should know about.
1:30
You come across this before this tells you whether it works on characters.
1:42
It tells you whether a given character is a white space character or not. So no new lines tabs, all these things are considered to be white space.
1:48
What we've got to do is just to drop. You know what drop well does drop well, throws away items from a list so long as a given product is true.
1:58
What's long is the so long as it's a space white space, then we just keep dropping, dropped or dropped.
2:06
So what we want is that, isn't it? Right?
2:11
It's not spend any more time on that. By the way, this is this is talking about practising horror.
2:16
What a function is this morning.
2:21
And of course, this is this is actually using essentially extinction ality, which is a little optimisation we can do when we're defining functions.
2:23
You can cancel the argument. So I could put in here a string here and the string is here.
2:33
But just remember the fact that function applications left associative.
2:37
So that's the same as that. And then you can cancel the S.
2:41
So I'll cancel the SCA, cancel the that you can get rid of the brackets then so the ship space function is the same as the partial application.
2:46
A drop while to is space good, right?
2:57
What about get out if you get out, she says, well, if you think of the data type,
3:01
so it's worth going back and just reflecting on members, the data Typekit or trying to work out what this know thing was.
3:06
And I think it doesn't appear in this exercise, I think I've got an old version of data Typekit, so I think there's only two constructors in this.
3:13
Thought one is text and one is the element, and we'll see if we need to know later on what I did when I went to the drawing and I didn't need it.
3:21
So I'm assuming it's this is this is the off season to remember. I had to know which I'll remove anyway.
3:28
So when we look at the next meal, at the next meal object, the nice thing about XML and JSON and things like this, these these,
3:34
these are these are ways of building structured data that you can then pass around, you know, HDP messages and so on.
3:43
And it's so Jason, for example, is the standard way of getting data back from a remote function call using something like a rest API.
3:50
You never come across that. So you can call a function across the network somewhere else.
4:00
And how does it give you the answer that really, because you back in some sorts of semi-structured form,
4:04
an X amount is one way of doing that and Jason's another. Jason has some advantages over similar chose X-Mode for this exercise, by the way,
4:08
because you can do things with X amount you can't do straightforwardly and just on.
4:15
One of the things you can do is this This successful transformation trick makes it quite easy to embed quite powerful languages in SML.
4:21
So that's why we do it right. So basically, when you look at the next analogy,
4:30
it's either an element which is basically means it's got potentially got children, which are also X amount of those.
4:35
That's where the semi-structured bit comes in. So it's a bit like a tree, and the base case is just text.
4:42
So sort of perfectly about X and Y is just a texture.
4:48
OK, so down here and see. We've done six, because I get what you think it's going to have only one of two constructors, by the way.
4:54
This is the No. This says get them, get the named attribute will get, so get the named element.
5:04
So I get the name attribute, so when we look at the elements,
5:11
the element has a name which I don't actually care about because I only care about the name of the attributes.
5:15
So they attribute the name.
5:22
There was the name of the attribute I've got, so I've got a list of attributes and I've got some children, but I don't care about the children.
5:23
I just want the semantics. This point is just give me the name attribute of this element.
5:29
So it's the top level set of attributes. Is all I need, right?
5:35
What a beautiful way to define that. Well, let me just before we when we think about that, let's just going to find the other case.
5:39
So if it's not one of them, it must just be a text element.
5:47
And if you read the instructions, it says in that case, we just return the empty string.
5:52
So we've got to get back the string, which is the name of it, which is the text string associated with this with this night.
5:58
Now, if there isn't an attribute with that name, they may just return the empty string.
6:05
So this is simply following the instructions. Right? What do we do?
6:10
Well, the attributes conveniently, this thing in here is a list of pairs, isn't it?
6:13
So you think, Oh, wait a minute, I've got to look up something at a list of pairs?
6:18
So the look up function will do that for me with a small you so I can look the name up in the attributes.
6:22
And that's one of those maybe things. So I'm either going to get back and nothing will adjust.
6:28
Now, if I get back to nothing, in other words, if I can't find the named attributes that they say,
6:33
the element does have attributes, but there isn't one with that name.
6:38
Examples very forgiving in that sense is just, don't worry, just just give me back the empty string.
6:42
Otherwise, if it comes back up wrapped up in just me, I did find it just for some attributes in which case we just want the eye.
6:48
Well, there's a magic function call from maybe. Which one which does that for us, so having done to look up, if it's just it gives you back?
6:57
Yeah. And if it's nothing, it gives you back in this case, the empty strength and from this is exactly the same.
7:07
By the way, if you don't want to use that function, you can use this one in which case the extra parameter is a function.
7:11
You apply to the argument of the just which case we should be the identity function.
7:18
When you see maybe something, it is the same as you can just get rid of that and just use the from maybe instead one.
7:24
OK. So that's that we'll test them all in a minute. Get children.
7:32
Owe me a question. Yeah, I was just wondering when it says X element, does that also include the children?
7:37
Because when I wrote this, I then like request on all of the light children to check if that element was there.
7:45
Well, that was in the solution as well, but I'm not sure if that is what you mean.
7:52
Don't you think so? I'm I could be wrong, but it says. You quite clearly do the task.
7:56
I can't remember what's written early on in the exercise.
8:13
No, this definitely means we just want the attribute of this element, not not not the children as well.
8:17
What did you do? You must have concatenated all the. Yeah, I then measure the function onto all of the children.
8:21
Right. The question is what's? What's six three?
8:30
So. Let me see, I've got element.
8:39
So what was the test case? The test case was. Get out TV execs to, wasn't it?
8:46
Well, I haven't quite got my. So it's not the fight.
8:57
Oh, it is, yes. Did I say that I must have saved it? Where am I?
9:02
So, OK. Remember saving the foil? Just just based on it, then we do a soundcheck.
9:12
Hmm. Just so bear with me.
9:24
Good, because what I was just making sure I've got, I'm staring at and I've got two screens,
9:50
I'm making sure and then the right directory, that's all I think I am. So I was I just might say that one, there is two.
9:54
So if I look at X two. Right.
10:04
So, you know, it should it should just be this element.
10:13
I'm just trying to think that there's no there's no there's no there's no Attribute X in the in any of the children here, so we wouldn't expose that.
10:17
But no, this is this is supposed to be. I'm just making sure.
10:26
Got this right. Yeah, it should just apply to the top level.
10:31
That's absolutely. That's definitely right. Yeah. So I don't know whether there was something in the spec that misled you there.
10:41
Did anybody else do that? You are looks through for every single step sub elements as well.
10:50
So. So some of did you you looked the match on the children here as well, and then you did a concrete map or something in there?
11:00
Yeah. I'm just wondering, I'm just curious notice to see what the.
11:09
Yeah. And there might have been other tests, but there's certainly been more test cases than the ones you see here,
11:28
which would probably certainly would have told you,
11:36
I'm just too, I have probably I've got time to go back and find the relevant thing, and it should be clear I must have it.
11:38
It's not absolutely crystal clear. Is it that you shouldn't do occurs?
11:44
But anyway, I'm telling you, you shouldn't because it probably doesn't do any harm because I just so I suspect you.
11:48
I mean, certainly you get, but you wouldn't. Probably wouldn't. Well, wait a minute.
11:56
Whoa, whoa, whoa, hang on. It generates a string.
12:03
So if you've got those attributes in the children, you have to concatenate the strings, wouldn't you not make a right old mess?
12:08
Anyway, the test case is almost certainly is the case that the children don't have attributes of the same name as the parent,
12:17
in which case you would just end up with the right string. But you definitely shouldn't recur.
12:21
So maybe that is a good point. Maybe I should check the somewhere earlier on the spec makes it clear.
12:26
Let's move on. So don't reoccurs. Don't recur.
12:32
This is supposed to be the easy bit, right? So what about get children right?
12:36
So now you're given the.
12:42
So there could be more than one, I guess, goodness, so let's supposing I've got I'm looking for this name and I've got an element, say.
12:47
And again, I don't know, I don't care about the name of the album to the name of the app. It's do care about the children.
12:55
So this is different and now down here or to get children.
13:00
So in that case, I don't care, I'm just going to get back the emptiness, I'm going to get back a list of small things.
13:09
Alex, this tobacco smells in this case. So what do I do here?
13:16
Well, I could use I want to go through each child.
13:23
And look to see whether the name of the child matches this name here, and if it is, then I want that child to be part of the answer.
13:29
So let's do that using a list comprehension just by way variety.
13:37
But it would be a filter. Otherwise you can take your pick will be looked at some of these issues this morning.
13:42
So supposing I take a child from the list of children, seised children's child sees that this is idiomatic has scored.
13:49
So CS means it's a list of something just to a list of something. So a list of six saving child list of child children who was now.
13:57
I don't want all of them. I just want to apply a filter here, so I want those for which the names match.
14:08
So what's the name? Well, what can do that trick we looked at this morning, can't I?
14:17
So I can say I'm only interested in those children, which are elements which with names and I don't care about their attributes or their children.
14:21
I don't care about the grandchild. Just want that. So I want to find all the children with the names.
14:34
So I'm using this trick I use this morning with this. This is the last thing in here, but there are other ways of doing it.
14:37
You can you can define a filter, a filtering function and filter.
14:42
That way, it's absolutely fine, but I think that is exactly the same thing.
14:46
So go through each child. Let's read it out. There are my children, go through each child, pick out the ones which match this pattern.
14:51
So each see which matches the elements, something I just want them, and this is the name of the child.
15:01
And if the name of the child matches the name, I'm looking for that child becomes part of the monster.
15:06
So I think that's fine. Just in a minute. So get child right.
15:11
What I want to do is something like, there's the name of the child, there's the X and I object.
15:16
Now, the function above returns a list of children, because it's the list of examples.
15:23
So what I'd really like to do is just say something like go away, get the children of the year,
15:29
the name the children in the simple things we've been given and just take the heck, right?
15:38
Brilliant. Unfortunately, the list could be empty because we because we may hit this case.
15:43
So there may not be any children with the sudden and mysterious headphones is going to break that we we're not we mustn't have that.
15:55
So he's one way round the problem. What I could do is I could say, Well, let's go away and get those children.
16:00
But just bear in mind, the seeds could be no, so now what I can do is I can do a check and say,
16:12
well, if seas is no, then the answer is the and there's the what is the answer?
16:16
We're told it has to be techs that aren't way. That's right.
16:26
Yeah. So the thing about the thing about X amount of juice on its semi-structured data.
16:31
So you may have attributes in some you you may have named child elements in others.
16:36
So you may have a set of children. Some may have some.
16:41
Some may have a certain attribute. Some may not. Some may have said names. Some may not.
16:44
And so you've got to cater for the fact that when you look for something, you may not get anything back.
16:49
And that's what baseball's happening here, in a nutshell. So it was a very long winded function like this.
16:54
And of course, there's a good reason to line up here because it's only a couple of characters if I can get my.
17:00
Something like that. So otherwise, I want the head of the CS, yeah, so that's that's dead safe.
17:08
Now there's a very beautiful way to solve this problem, which involves one line of code.
17:15
I'm going to show you that. And it's it's one of these little things that is idiomatic.
17:18
Who knows? But it goes like this. It says, No, I'm going to apply the head function and I'm going to do that.
17:23
Come what may? Right? But remember. But that could be empty if it's empty.
17:35
I won't text empty string. So here's a list which could be empty and if it's empty.
17:43
So how about disposing of pens to that? A single singleton, this text? Blah blah?
17:51
Yeah. Now I can get rid of all that because if the get children is the emptiness, then I then the result is this is this list here.
17:56
And the head of that is text empty string, which is what I want.
18:07
And if get children is not empty, I would send the head of the first child, which is what I want.
18:10
So that kills two birds with one stone. So it is a pattern that you do quite often see, so be worth clocking in, it doesn't.
18:15
It's not particularly a high school thing. It can work in any language to look up more at child.
18:23
How do I add a child to? So now I've got to exempt objects and it's a mutual, I call them.
18:30
Now what? What, what? What's crucial here is this precondition.
18:40
So I know the second argument is an element.
18:47
So when I when I call this, I'm going to only going to call it in a context where I know that this second Excel object is an element.
18:49
So I don't need two rules here. Just me. So let's see.
18:56
So if I do this, the name of my. No, I said what I'm going to do is I'm going to add this child to this element.
19:01
So that's the name of the element because I could reconstruct the element because it's a function of programme and there is its list of children.
19:10
So this is dead simple, isn't I just say, well, it's the element with the same name, the same sort of attributes.
19:16
The only difference is that I'm taking the children attending to adding to the rightmost and singleton, they say.
19:21
So this is just really a little tiny online help function, which presumably we're going to use a bit later on and finally get value.
19:27
So what's this? So you have to read the instructions. So the value says that if you've got a text field, the value is the text.
19:38
And if you've got a task, the question? Yeah.
19:48
So you should see recording that are child's a function they've just implemented.
19:53
So we don't need to worry about the other possible cases. No precondition.
19:58
OK, so it's all it's all right to leave that. Yeah. I mean, you don't play.
20:04
Don't be tempted to do this blah.
20:09
But don't do it because the whole point of the preconditions says that you can interpret
20:17
in such a couple of ways that if you call it with anything other than the function, the programme is going to break and tell him, I say don't.
20:23
It will never be called with something other than that element.
20:30
Yeah. So of course, in practise, if you're writing commercial code,
20:35
you really wouldn't want your programme to fall over without catching the error in some way,
20:38
shape or form, or at least telling the user that the compilers crash.
20:44
There's nothing more I can do, of course, than you would do something like this. But actually here we don't want our code littered.
20:48
Well, at this stage of the course, we're trying to get you to write beautiful programmes.
20:55
And later on, you'll be engineering beautiful systems made up of programmes.
20:58
And of course, to do that, you've got to think about the use.
21:02
You've got to think about the user experience and then you have to start thinking about the mess associated with catching errors and
21:04
trapping them and catching exceptions and reporting the back in the workshop and trying your best to recover from situations like this.
21:11
But at this stage, you can just take that out.
21:18
OK, now. So the get value thing is this is a this is where you do want to concatenate strings, isn't it?
21:22
Well, got strings. You want to concatenate, you want, you want to get a single and do you want to get a.
21:31
And. Yeah. So I'm just thinking looking at the result, Typekit has got to be an animal object.
21:38
Right, OK. What it is, it's the concatenation of all the text fields in this object.
21:44
This one here, all of us have it, including reversing into the children.
21:51
So you get the concatenated texturing and then you wrap that in a text object.
21:56
So this is different to the one above where we didn't want to recurs. This time we do want reoccurs.
22:00
So what I want here is something like, well, let me just name this example, and what I want to do is to which I'll get to.
22:05
I'm going to get a helper function to generate the string I want.
22:17
So let's what helped functions generate the streaming call, I imagine, simply get value prime,
22:21
which is going to then do some stuff and then what I'll do here is I will call
22:27
get early prime on the SNL and I will simply wrap that up in the text on it.
22:30
Why isn't it a strength? Because it's got a Generation X amazing. So the you instruction, I think it does make this quite clear.
22:37
When I was looking at it just over lunch, it seemed to make it clear, right?
22:42
So now, well, again, well, let's have a look. It's going to be an exhaustive function, so it's got to be a total function.
22:47
So it's either an element which is gone.
22:53
And I don't care about the name of X, but I do care about children because I got a precursor into the children,
22:56
which I are got to think about what to do. Or it could be a text field, and there's the text in which case I just want the text.
22:59
So what do I do here? Well, there's no text field in an element, but there could be text fields in these children.
23:09
So what I want to do is I want to map. The get value, profile, get value, prime function over the seas and then concatenate the result.
23:17
Well, actually, that's to remember from this morning's discussion as a lovely function, Comcast can get map that will do that in one go me.
23:28
And as a promising down here. OK. Good.
23:38
So when we was setting this exercise, actually,
23:44
it was quite interesting because I did it with a student of mine who doesn't have been in the industry and done a lot of work with Excel.
23:47
And there are these sort of little funny edge cases and you say, what should the behaviour of function?
23:55
Basically what we have to look it up in the in the standard.
23:59
So in this particular case, when you get the value of an example of it's defined to be a text body,
24:03
which is the concatenation of all the strings in the object is a bit of an odd thing, but it is.
24:09
It turns out to be really useful. So one of those things where you just follow the instructions, I think that's it.
24:13
So should we see if that was probably can't believe I haven't made a mistake?
24:18
My goodness me extraordinary. Let's try and let's try some examples then.
24:23
So I'm going to see my skip spaces, right? If that's okay with you, I we've tested but only once to get out.
24:29
Tributes thing. What was the other one I was going to say?
24:38
Let's see, let's try getting the children in X two, which could be so I think one can magically now if I've got it right.
24:39
OK, so that. Looks like it does the right thing getting supermax to.
24:48
If I ask to see there aren't any children called see you next to them, there's the proof.
24:56
There's no, there's no. I've got babies. I've got I've got two children with these in it, but no children with us say so.
25:00
So that makes sense to check more.
25:09
Oh, let's check our child. We've written that function and.
25:13
Right, so that's taken this element here.
25:24
Which has got one child, and it's stuck. Text B on to the end of it.
25:30
So I've got two children, Tex Latex Paint, which is what I want. All right.
25:34
So oh, I suppose we should just check we've got this right to get value x one, and I think I might do that.
25:41
And if I do. But so I guess that's the concatenation happening for you, and you can test, so dummy, you've got a question.
25:52
Can you hear me? Yeah. OK. So we had to write the project could function fulfilled filter.
26:04
You prefer if we write that function separately or we write it in line using lambda notation.
26:12
Oh, I don't mind about London. That's London's fine. That's what they're for.
26:20
Lenders are nice ways of introducing functions without having to think of a name for them.
26:25
That's one of the nice things about, you know, like a map.
26:29
So if I do sort of if I want a map of function over this one two three, what is the function f to?
26:34
Oh, well, if I name the function. X plus 17 in.
26:39
Yeah, of course, they're going to come up with a name for the damn thing. You know how hard it is to come up with names for things, right?
26:48
So the nice thing about London is that, as you said, you can just do London X and then I can say X plus 17 sizing him to name the damn thing.
26:53
And also then I can get rid of this lot. So it gives me the same answer.
27:02
So I don't care. I don't think I don't care. Up to you.
27:06
You know, there's there's maps, there's less comprehension is there is nine functions as anonymous functions.
27:11
I think the most important thing is if it's obviously a map,
27:18
don't watch a recursive function with a base case and then a, you know, they don't don't do the naive way.
27:21
And if it's not obvious what the map should be, then use a list comprehension where it is always obvious.
27:28
Same with the filter, MIA. Yeah, so just about get value, you know how that's non-exhaustive because the Noel type isn't defined.
27:33
Is that okay to do? Like if we know we're writing a function, but we're just not going to use it for a particular time?
27:44
It's a really good thing. Let me just come up here because I I meant to check this when I was looking at it.
27:49
Oops. Oh, I'm going to do it right.
27:57
So there's no mention of Noel anywhere in the spec, and I I have a funny feeling.
28:05
So let's come here and this.
28:13
Did I say something about? Oh, here we are.
28:19
You know, the original suspects may use another volley, but I removed this in favour of text law.
28:23
Yeah, that's what he was. So basically, I'm showing you and I think I'm shooting an old version of the template, which is still got the null thing.
28:28
But when the test was set, when the test was set, there was a no value.
28:35
Yes. So you had to have the extra no cases and I thought. And there was a good reason for using no, but actually in this exercise, you didn't need it.
28:39
And so we got rid of it. Okay, so if you just pretend it's not there, I'll tell you what I'm going to do because it is a bit annoying, isn't it?
28:47
Let's just let's just get rid of it. And I think if I get rid of it.
28:57
Everything should just be fine.
29:03
All will break for a minute and then just one minute and then all let you stretch your legs, then we'll come back and do part two.
29:07
Can you scroll back to get value function, please? So we want.
29:15
Get value, please. There you go. Thank you. OK, I'm back.
29:28
Let's move on to the paparazzi. Now, I just noticed that when I was running rummaging through this, I thought, Oh,
30:42
there's a bit of a mess with parsing names because things can end with all sorts of different characters.
30:49
You've got to catch all the cases. So then I remember looking at this, we'd given you the name pause and then function,
30:53
and you can see it's a bit messy because of because it's just messy.
30:59
So we thought it best to give it to you.
31:05
I think actually, this helped some students who we've basically forgotten or hadn't passed the wrong string into the name piles.
31:08
So I think this turned out to be quite handy. So good.
31:16
All right. So let's just see if we can avoid that by getting it right first time. OK, so so parsing.
31:19
So this takes me. So are so somebody asked the question about the the old systems exercise, and I thought,
31:28
Well, I'll mention in passing here because it kind of it's a related problem, isn't it?
31:34
You've got a string.
31:39
Here is an XML string, and in the same way, in an old system, you had a strange man with that smell, actually with their health systems,
31:41
I'm sorry your string was coming to the left me what it was, but you had square brackets, didn't you?
31:49
And then you had always it left, left, right,
31:55
and then you could have another nested term and then you could have a close bracket and then you could have and then you had this sort of thing.
31:59
So it's a single string, which is actually a tree in the skies, isn't it?
32:10
And it's it's an Oh Matthew, you got you got a hand up and I forgot to ask you what your question was.
32:14
It's OK for the nap function, but is there a way for you to specifically choose something to map over, for example,
32:20
if you had to land in it and you didn't, if if a certain condition is met, then apply the function to it.
32:29
Otherwise, walk off wise, leave it as it is, for example, if you had an update function that say.
32:43
So. You mean something like if then something like this, so so leaving it is means that.
32:55
You get back. What you were given here, would that be, would that be OK to do?
33:13
Yeah, it's fine. Yeah. Sometimes it's what you want. Yeah, OK, cool. Thank you.
33:20
I mean, you've always got to return something. So here's an expression in a condition.
33:24
You've got to return something. It's not like a Java programme.
33:27
You can just say if then full stop in a functional language, you've always got to return something.
33:31
So if you don't want, if you don't change the input in inverted commas, then just give it back.
33:39
But we think we can use this if they close at anywhere in our programme.
33:44
Yes. Yes. Indeed. Yes. I mean, I'm not sure, but you know, depending on the whether that's best practise,
33:50
whether it's better to have a helper function with a guard in there or use some other mechanism.
33:55
But what I've written there is perfectly valid and I tend to people to say, Oh, well, good, why should I do?
33:59
What should we ever use conditional or should be use God's? Well, if you want an expression and you want it now here, then use anything else.
34:05
But it's generally going to be quite short. Something like that would be fine. What you don't really want is anything else that goes over half a page,
34:13
because then it's much better to use God's, because then you can see the structure, the better.
34:21
I think arguably it's not necessarily wrong, it's just I think it's slightly more idiomatic to use God.
34:25
But sometimes, you know, think, Oh, I'm just about to write down the expression for the third argument of this function.
34:30
And dammit, you know, if this property is true, I want it to be one. Otherwise I want it to be zero.
34:36
Well, it's technically conditional in that as long as it doesn't pollute the page with will go or go over your stated 80 characters or something.
34:40
Yeah, you could chuck a conditions, but. So what they're saying above is this thing here.
34:48
You know, you remember you've got a string with the string is a tree, but it's represented as a string.
34:55
So there's a there's a natural recursive structure being encoded in this string at exactly the same way with symbols.
35:00
Wrexham out is a deeply recursive potentially take. It's a precursor, potentially deeper recursive thing, represented initially as a string.
35:04
So somewhere involved in the parsing of that, you need a stack.
35:13
So you remember the the old systems exercise because you were doing this one cards at a time thing.
35:18
There's two ways to try to solve the problem,
35:24
one of which is you have you basically carry around your own stack and you sort of say, Oh, look at this card.
35:26
I was a bracket. I mean, you think, OK, I'll push the current state on the stack and then, oh, there's an element isn't able.
35:32
Then it's an. Oh, here comes another one. So I push them the stack.
35:37
So for as many unmatched open brackets there are you've got something sitting on the stack waiting to be matched.
35:40
And of course, when you get to the Oh, got a close bracket now, therefore, that obviously matches the solo, then pop the stack state.
35:46
You remember how this work, you know, pushing and popping stuff.
35:54
The other way to do it is just to use the Haskell recursion stack and say, you know, at this point.
35:57
But I guess an open bracket here just recurs on what?
36:03
Let's look at this one here. Well, I hate this bracket here.
36:07
You just recurs into the following string the string that follows and just trust the fact that
36:10
Haskell will pop back here and give you the bits that follow the matching closing brackets.
36:16
And that's what we're going to do here. And that's that's actually that's. Really, the way you know, you would know you would normally do it so.
36:23
But anyway, somewhere you have a stack. Now it turns out when you were passing example, you got to assemble this recursive small object bit,
36:32
you know, one cello, one element at a time when one text field at a time.
36:42
And so there's quite a well established strategy for doing that,
36:47
which is what's encoded in the spec and what you're supposed to encode in the solution.
36:51
And that is to carry around a stock.
36:55
It kind of represents the current partially completed state of the XML object.
37:00
And when you finished, the stack will contain exactly one element.
37:04
I thought, gosh, you could tell exactly one child. It's that element that which forms the final result.
37:09
And it's all when I read the spec and actually read the spec last night, and it's actually very well explained in the spec.
37:14
It took us ages to do a commendable poring over the diagrams.
37:21
But if you if you want to go back, if it's not absolutely clear what we're going to be doing, then this is really very nice.
37:26
This this this shows you step by step how how the recursion traverses the string.
37:32
And if you if you just look at this, you look at the new stack and you can see we start we start with the Sentinel,
37:39
which is just thinking this thing at the bottom, this thing in here, right?
37:43
And then lo and behold, step by step, this object on the stack gradually gets all the bits and pieces added to it by using presume the added child,
37:47
and we step through this through the string and eventually we get to the end of the string.
37:58
And here we are. Here we get to the end of the string now.
38:03
And as we go on down, this element gets built up on the stack and there is the last bit of white space had dangling off the end of the ex-militant.
38:06
So this piece of this piece of garbage here actually is just junk, but it starts to look like the motor could be separated leading up to the next.
38:15
And of course, there in the next element. So just stop. But miraculously, the sentinel element this this blah blah blah thing.
38:24
The first child of that sentinel, amazingly, is the very element that we just passed to.
38:30
Where you got to do is to pick up the head, the head of the list of children,
38:36
and that's the thing you want to get back, and that's the standard way of parsing an extra metal object.
38:39
And it's kind of hard to think very carefully about how these things like this, this this white space at the end of the text.
38:44
You know how that gets pause and eventually thrown away. It's extremely clever the way it works.
38:52
So this this this stuff in here ends up ends up getting thrown away and this stuff doesn't because
38:57
this thing here is indeed the very element of the ex-model that you're trying to to build and parse.
39:01
So if you follow the instructions and you do it step by step, you end up with quite an elegant and actually very straightforward.
39:08
But down here, where are we somewhere here? So we're just going to go ahead and do it.
39:19
So let's come here. Let's go here.
39:25
All right. So what does add text do? This is right. So it's another way this stack is one of the things I've just been showing you.
39:30
And on that stack will grow. Eventually, the the ex-model elements I want.
39:37
But anyway, if I if I freeze the computation, probably through,
39:44
there could be a whole bunch of elements sitting on the stack walls of the partially completed bits of XML.
39:46
And by the time I hit all those matching angle brackets, things the way the very last one being me being the little pop back into one element,
39:51
which is the thing I want, and amazingly,
39:59
that the recursive structure exposes itself in this XML data type before your very eyes, and that pops the answer.
40:00
So let's do this bit by bit. So here's a string. And we're given a stack where you've got some elements on it than what the element is here.
40:08
And we don't care because we got some helper functions now to put the bits and pieces together.
40:16
And then particularly here, what we're going to do, we're going to add the child from, well, OK, this is this is a string.
40:20
So I've got a form and actually my XML element from the from the string.
40:27
And all I do is add that to the element on top of the stack and then that gets turned on to the rest of the stuff.
40:30
So in other words, if you want to think of this operation, you take the top of the stack e and modify it by adding text s to to ease children.
40:37
So he may already have lots of children. Are you just going to stick it at the end?
40:46
Good eye popping ad says, well, there are at least two elements on the stack,
40:52
and what we're going to do is we're going to take those elements off and we're going to add the first one as a child of the second.
40:58
Now you think precondition.
41:07
So now I can assume that my stack has got two elements, so this comes back to the basic pattern matching 100-watt up matching one to two.
41:09
And what pattern can pattern can you think of for a stack which matches a stack with
41:17
at least two elements because I know I'm always going to see these two elements, how about this?
41:22
So I know that my stack has got at least any and any apron now. Steve could be empty, could have a million elements.
41:29
We don't know. We know it's got at least two. And all we're going to do just following the instructions is we're going to.
41:34
We're going to have a child eat Prime Day to eat, and that sits on top of the stack.
41:42
So the sort of mental picture they have in your mind as I build up the child and I want to get to when I finish building up the child thing,
41:53
whatever it is, I think I'm done now. So that now becomes the next child of the object sitting under me on the stack.
42:00
And that's the point where I'm going to call that what I'm going to call that child. Right, so now it gets a bit more complicated.
42:06
Now we've got some activists, why don't they turn on the Magic Point board?
42:14
So that seems have attributes, work.
42:18
So I've got I've got to the point where I've got a list of attribute names.
42:22
So it's going to be something like name. One equals and then there's going to be a double quote.
42:28
And then there's going to be some stuff in here and there might be another attribute.
42:35
It was going to be some more stuff in here, and there could be and this could go on and on, there could be many named attributes.
42:42
So what the exercise says, Oh gosh, you've got a question.
42:49
Yeah, I had a question, was that child, so the ad text in the ad functions when you could go back?
42:57
Yeah. So do you know how you'd like cons not add child on?
43:04
So the ad text one, we just. Find them.
43:10
This one? Yeah, that one. So now you've confused on the results of our child.
43:17
Text us on to see how does the is like its function application more like, Oh yeah, yeah, yes, you need to remember that.
43:22
Yes, right at the beginning, I said to you. Function application binds more strongly than anything else.
43:32
So if you if you put spurious brackets saying we're probably going to point them out, we're not going to deduct any marks.
43:38
But you should know that if you're right that it's nothing wrong with that, it's just that.
43:44
Why go to the top in those brackets and someone's going to read the damn things when actually you don't need them?
43:49
It's just you get really used to knowing. It was the first thing that sinks in with, is it well, maybe it doesn't.
43:54
One of the first things sinks in is the fact the function application binds more tightly than operator application.
44:02
So when you start a that you think, well, there's an operator.
44:07
Therefore, I know the thing on the left is going to get bound together and the thing on the right is going to get bound together.
44:09
All right. And if it's not clear, then put the brackets in. But I think in this case it is.
44:15
But you know, you can. You can. If you do, that's OK. Doesn't doesn't hurt.
44:20
All right. Thank you. As you understand something. All right.
44:26
Good. So we've got this structure here. So what the exercise says, you can assume, but a wall that somehow is strings are well formed and in practise.
44:30
You can't do this because people make mistakes. You know, if the X amount is computer generated, then it's it's probably going to be fine.
44:38
But if someone's actually typed the SML themselves, they're going to make mistakes and you should catch the errors.
44:43
But actually, we did think for long and hard, and originally the exercise was a lot more involved in terms of error checking.
44:49
And eventually we decided to throw it all away because what she wanted to focus on the excel,
44:55
not the problem with finding syntax errors in people's academic programmes.
44:59
So the nice thing about that is that what you got to do is to use the parse name function.
45:04
So if I take this, if I see how Paul's name works, I think if you if you give it this lot.
45:10
And you apply Paul's name. To that, it's going to give you a pair, which is name one of the quotes in.
45:19
That's a stream, by the way, yes. Let me let me let me turn this into a string.
45:31
There's a Haskell string. Right. And this thing here is a double quick character, yeah.
45:34
Oh, so you think hard what double quick characters in the exercise makes clear?
45:42
You put it all backslash in there. So what? She is the scapegoat. So the whole thing is a story.
45:45
So what I want to get back is the name, so that should be name one in here.
45:50
And the other thing it returns is all this lot. Which is so this thing, this thing in here, it's telling that string and this lot in here.
45:54
The stuff that isn't associated with the name or is it let me just get this right, I think it's.
46:06
I think someone correct me, I think that is that it's not.
46:14
Is it the character after the equal sign anyway, that not get stuck in there and this is some string?
46:22
S1 as prime straw, whatever we want to call it is basically the remainder of the remainder of the input,
46:30
having extracted the name field in, if we look at the name, the it's including the equals is intriguing.
46:36
Yeah. So. Well, in fact, the way we can test, let's just do it, so I can say pause named and I can say name one because and then I can do that.
46:45
And to do that? And then that.
47:01
Yeah. OK. So I was like the first time, it's all that low.
47:08
It's all of us, look. Each. Good.
47:16
So long as I know that I can cope with it, yeah, you just got to understand that when you invoke the pause, and that's what comes back.
47:20
So this is going to be really helpful function and it's kind of the nice thing about it captures all that,
47:25
all the areas that you would otherwise have to code itself in order to debug your programme.
47:29
So that's why we did it for you. All right. So let's crack on.
47:33
So. Now then you've got to have your wits about you here.
47:38
So attributes end. So what you get is you get the start of an element you get.
47:46
The name of the element. And then you get.
47:56
Well, I should call attribute one equals something, attribute to equals something,
48:03
so perhaps I should have called naturally rather than that, but this is the names of the attribute.
48:08
And the thing about the attribute list is it ends here. So as soon as you hit an angle bracket, a closing angle bracket, you're done.
48:11
So the spec sheet gives you some quite good hints as to how to cope with that.
48:19
So what you do is the following. Right.
48:23
So what I what I had requested. So what I want to do is I want to look at the first character in my input string.
48:30
And in case that first character is that I've got to stop. So that's the basis one of the base cases could cope with.
48:38
So somehow I'm going to extract that character. And if that character is an angle bracket, I'm done.
48:45
So what do I return back over to a list of attributes?
48:51
Well, there aren't any in that case, because if I've just got a closing angle, bracket means there was no other.
48:54
There were no attributes to start with or I've already passed through all the attributes and I've run out of attributes to look at.
48:58
So in both cases, there are no attributes. This is the nice thing about recursion functional programming.
49:04
I don't care how I got there, the right now attributes. So my job is simply to tell the truth.
49:09
There are no attributes here, and the rest of the string is some.
49:14
What shall I call this string that's called that string instrument? And I guess what I'd have to do is return the tail of that string.
49:21
Well, it's called a straw primate reps. And what I'm going to do is to think about and think of a name for this in a minute, so.
49:29
So that's an equal sign here on this thing.
49:42
So in that case, I returned the end and something now let's just start, let's start coding up the web because let's think so.
49:47
What the spec tells you to do is to take the string,
49:54
set the whitespace because this could be there could be there could always be leading white spaces,
49:58
get the space white space or skips placement of it was called in that string.
50:01
And that's going to give me back a modified string. I'll call that one string prime.
50:07
So it's exactly the string I started with movable white space remote. Just remember that strip prime is the original without the white space.
50:11
And now I want to inspect the first element of that.
50:18
I've got to think about what to call this one, let's pull that one. So I want the name that's stripped from that now.
50:23
I've got the same answer this thing here, then that case would have to be this, wouldn't it?
50:29
Because I've now said I've hit the closing angle because I want to throw that away and just give you back the remainder of the text.
50:32
So remember, the trick is the same with the other systems. You're walking through a string and you want to recurs recursive process bits
50:38
and saying what you want to get back is the remaining characters in the string.
50:46
Having hits some two main points in this case, the closing angle brackets.
50:50
We'll see in a minute how this this all falls up very, very beautifully. So you just go remember to do things in the right order.
50:54
So first thing, set the space. Secondly, look at the character. That's the head of the bat.
51:01
Cleaned up this to see whether it's an angle bracket, in which case we can now just we're done now.
51:05
Otherwise, we got to do some more work because it means we're in the middle of a set of attribute name,
51:11
attribute pairs, attribute name, attribute value pairs.
51:16
So what we're going to do now is we're going to take the Stroot, the cleaned up strip prime.
51:21
So it's no, it's not the case that the first character is not.
51:27
That means we've actually got an attribute name here, so we're going to pass the name, but actually giving it that string.
51:30
And what Paul's name does is it gives me back the name that the attribute and it gives me back the remaining string.
51:37
You can see what this is, why I'm going through the names for them.
51:47
The remaining string having passed the so if you like back to my diagram here, this thing in here.
51:50
Let me rename it. Nothing in there.
51:58
My guess is as. Two is it is, too?
52:03
Yeah. So this thing is asked to, in my example.
52:10
Right. So it's like Lego Lego Block programming.
52:16
This is what functional programming is as my leg, my Paul's name Lego brought back comes the attribute name and the rest of the string.
52:19
What do I do with the rest of the string? There's more work to be done to come back here.
52:25
So now I've got to take this as to which is all this lot here. And I know because it's the well string.
52:29
The next interesting thing to look for is this double quotes, because I can assume that all the equals in this white space is all there.
52:37
They're much, much, much as you want. What's important is the attribute value, and that always begins with the double quote.
52:44
So I've got a search for a double quote, pick this thing off here, which which I know is the bit between this double quote, the next double quote.
52:49
And then I get to this point and I just repeat the exercise because there could be arbitrarily many name attribute personnel.
52:57
That's why I'm just going to do the recursion. So I'm going to break it down, find the double quotes, pick out the bit in the middle.
53:04
And then because I'm done, so it goes something like this.
53:09
So I've got to find a way to take the two now and break it.
53:15
I could use drop while let me just stick with one function. We can discuss what was in the minute.
53:19
So I want to break when when I see a double quote cap, double quote character,
53:24
I want to break the S2 string at that point and I want to see all the rubbish to the left I don't care about.
53:36
Because it's things like white space and equals, which are never going to be, though, I just I don't care about that.
53:44
What I care about is the bit between the double quotes. All right.
53:48
So the bit between the double quotes is going to be.
53:52
Let me see. Right, so that's going to be some I call it S3.
53:58
Um, what do I need? I'm just going to show you this. If I say break, let's do it.
54:09
Let's say break, because equals. Correct.
54:14
Double quote, correct. And I give it a string consisting of this stuff here and then some stuff it and then a double quote character.
54:21
And then some more stuff, a b c deeper, right?
54:31
What I'm going to get back is, oh, I put my bracket right.
54:35
What I'm going to get back equals to what's wrong with that?
54:41
No, so I thought it was in brackets.
54:51
Right, so now I get back all the rubbish to the left of the double quote.
54:56
And then do you notice that if this thing is the string, here is and I know this isn't going to be no, because it's a well formed thing.
55:01
The first character of this second element is always the thing that I broken.
55:09
Right. So because it's well formed, I know I'm going to find a double quote,
55:15
I know I'm going to find a string and then a double quote because it's well formed. Therefore,
55:20
I always know it's almost like a post condition because I always know what comes back from the break is going to be a double quote character,
55:23
constant or something else. But I don't want the double quote character, so a little trick I can do later on.
55:33
I can take the tail of a story, but I happen to know that that's going to consist of a double quest character comes down to the string I really want.
55:37
So this is a nice, quick way of throwing away the double quote, right?
55:45
So I do that. Now, what do I do? So now I want to do the same thing again, I want to break the next double quote.
55:49
So I can just copy this over, can't I could have just done this thing here?
56:02
It's the same thing, same thing here, but here I want to pass that has three.
56:06
Oh, now I get that something I do want, which is the attribute value.
56:12
And another string you can see if you remember that if somebody went to Jamie's talk about the statement,
56:18
this is a really nice example of this would be a nice example of how to use the
56:24
statement because I wouldn't need to carry around these strings all the time, which is being hidden away in some state.
56:27
But anyway, as we were not using the state model, they've got to carry these strings around the West.
56:31
One gives me an estimate that I call a bunch, which gives me an ashtray. I call a function because being a sponsor, I've got to change these together.
56:36
All right. So now I've got the attribute valley and the remaining stuff after and once again.
56:42
I know that that's there's always going to be a double quotes, I can do the same trick again,
56:50
Collins, I can do that because there's always going to be a double quick character.
56:53
When I when I perform a break, right, final thing I have to do is solve the rest of the problem,
56:58
which now I've got to do is to parse the attributes, the remaining attributes. There could be many which are all going to be stored in S4.
57:03
And if I do that, I'm going to get back a pair consisting of the attributes to my right up until that closing bracket.
57:09
This thing here and this is where the recursion just does its trick. Yeah.
57:20
This will give you all the actual up to the angle bracket point, and it just does it by recursion. It's simple.
57:24
What could possibly go wrong? What can go wrong is I name these strings and I'd pick up the wrong name.
57:28
That's what can go wrong. All right. So in that case, all I've got to do, otherwise I haven't hit the base case.
57:34
I've just got to pick up the bits and pieces and guess what I've got in my hand and I.
57:43
I've got an attribute value. I've got the remaining attribute value pairs, which is the apps.
57:50
And that's that's the complete list, the name attribute value pairs.
58:00
And finally, what are the remaining characters? That is the.
58:04
That is the case for, I guess, this thing here. All right.
58:10
So let's just make quick sanity check here. I've got input string.
58:19
I skip the white space, give me a string prime. I just pattern much on that, right, so that's that's for the base case.
58:26
If it's not the base case, I want to take the cleaned up string.
58:36
And a moment pause, it gives me a neighbourliness to oppose the US to try to break it, the first character give an three.
58:42
And then I break it, the next character, which gives me I think there's something wrong here.
58:52
That's what's true on my last line gives me as far as I want. That's fine.
58:59
I thought I didn't have enough as it is, is very easy to make a mistake, isn't it?
59:04
But just keep your wits about you, right? So I've got the name not to be, but it was a pair.
59:09
There's the remaining activities by recursion as the recursion and the recursion gives me the remaining text, the S5.
59:13
And though we got kind of question, see if I were to stop while would I get,
59:21
yeah, you know what I was going to say you can use break or drop while here.
59:27
It's absolutely fine if you use drop while in this line, it means you don't have to worry about this thing here.
59:31
I guess just to keep it sort of symmetric and simple, I'm just using the same function again and again and again, but you're absolutely right.
59:37
I could replace this with a drop. While I wouldn't need this, this patent on the left with I c in terms of the efficiency.
59:44
The straw poll, which uplift Brake Auto has like us more is more efficient in terms of executing this.
59:51
It doesn't matter. They both, they both, they both stop in the same place. I suspect if you timed, it dropped while would be two percent faster.
59:57
It's not changing. An order ran into a log or an end square into an and it's just it's a microscope.
1:00:08
So you don't worry about that.
1:00:13
You just pick the one that either gives your programme a nice element of symmetry to or he picked the one that's just feels right.
1:00:15
Thank you, either. No one's going to care, right?
1:00:21
So let's wipe the pausing function. Let me just check that that compiles.
1:00:27
So what's it done now? Hmm.
1:00:35
Very well, not in scope at value. Really? You sure think you should be out of jail?
1:00:43
You might have named it all. Tony, what?
1:00:51
Let's keep it simple, as I call it name. Let's call it Bali.
1:00:55
And we don't have to worry about these stupid kind of crazy things, do it. How about that kind of thing that should be as one of the top?
1:01:01
It's also another. Oh, is it? Yes, thank you so much.
1:01:10
And you see, it's very easy to make this mistake. That is actually unbound, isn't it?
1:01:15
So we were spotted that short. Yes, yes, of course. Yup. Thank you.
1:01:19
Yeah. So I throw away the angle bracket and the remaining characters of the S1.
1:01:23
So. So thank you very much. Like patent matched here to expose the the C and the S1 is the stuff I turn in the base case.
1:01:27
Right. So hopefully now go ahead. And as you know that once your programme Typekit subjects, it must be right.
1:01:38
Yeah, Shenzhen. Bob, no, no, I was doing this test.
1:01:45
I look have and searched for some information and I found out there is actually somehow a standard way
1:01:52
to parse differences like we can define a password data type and we can define several operators.
1:02:00
Oh yes, quite easy. But I don't know why we need to like if we stick to our like structure in a template file, we can only finish this in this way.
1:02:08
But if I try to like use that password data type building block, this was all you do is say this is easier to solve.
1:02:21
Yeah, you're absolutely right. This this is the this is the this is the Pascal 101.
1:02:30
So the nice thing about XML and JSON is that they're really, really easy to parse,
1:02:34
and you can set up these very elaborate frameworks for solving the problem.
1:02:39
Actually, if you just write your own parser, it's only half a dozen months ago. He doesn't want to go.
1:02:43
It's very simple. Now the next next to you be studying compilers, and one of the things you have to do is write,
1:02:47
write poses for a much more sophisticated language is the next HTML.
1:02:53
And one of the things that you you can use as an option if you want to is the think of posse commentators.
1:02:57
And Jamie will be teaching about parsing commodities, which is probably what you found online.
1:03:02
And that's the smart way to solve the problem. If you've got a proper programming language in your head.
1:03:07
Yes. I found it like we can sequence to a passer or we can like slide through to a passer and choose UAVs and to run or something like that.
1:03:14
Yeah, absolutely right. But that's not what I need to kick on.
1:03:24
Brian is a quick question because I want to finish the next five minutes and then we will yet for the exam, right?
1:03:28
You know, can you go back to the workforce for the past such attributes?
1:03:34
Do we need to put all the equals align? Do we need a line? Oh, even even though we should be able to say we have a little?
1:03:39
Yeah. I mean, I don't. It's really weird.
1:03:48
If sometimes the left hand side is too long and one you're absolutely right.
1:03:53
I think this is and also what's going on on the left and what's going on is very different in each case.
1:03:57
I think in this case, it's probably overkill. And then you've got to start messing around like this seventh year and what is it?
1:04:02
So how do we leave it in the exam? Yeah, do it at the end.
1:04:09
I mean, I. But it doesn't somehow make the programme any more readable to me in this sort of context somehow.
1:04:13
If you give me a block, if you've got guards, I think there's something here.
1:04:23
I want the right hand side to start in the same place because I want to say, you know, that's kind of handy.
1:04:28
But again, not absolutely essential. Let's move on, I'm not going to do that anymore because we need to.
1:04:33
I could not guarantee, right? So the past prime function, right?
1:04:40
And so really the question following these tests, but actually, if you think about it, the instructions make complete sense.
1:04:47
So it says. Pausing and element finishes when you see the angle bracket slash pattern.
1:04:53
So the nice thing about Haskell and other languages, too, is you can just use pattern matching just to solve the problem.
1:05:03
So let's do the base, especially the base case.
1:05:08
First, I got past Prime, so I've got a string, I think give me an empty string.
1:05:13
What's the rule?
1:05:17
Well, I can remember what it says if you can an empty string by by construction, the thing on top of your stack is going to be a single element.
1:05:18
In fact, I messed with just a single emoji with square brackets, a single element.
1:05:26
I don't care what its name is because the Sentinel is the thing that sticks at the top.
1:05:30
Most level, the centrum was as a dummy element. What matters is not the sentinel, but its children,
1:05:34
and we're told that the item that the first item in the list of children is the result of the past.
1:05:39
So when you have the empty string, you must have a stack that looks like that, in which case the answer is just a.
1:05:46
And we're done right. So if it's not an empty stack, then I've got a call-back to see what we call the stack.
1:05:52
So I've got no, I'm sorry if it's not an empty string. What are we doing?
1:06:01
It's not an empty string. We've got to go through the cases. And fortunately, the parsing is so simple it's only actually three cases to worry about.
1:06:05
I think I can see an angle bracket, followed by a slash, followed by some other gulf, which is the rest of the presumed.
1:06:11
It's the rest of this label in this. This angle bracket thing is like the end of token thing you like.
1:06:22
And that's my stack. And what I have to do in that case is to do what?
1:06:27
Oh gosh. Right.
1:06:31
So now at hit the end, if you imagine all the all the text to the left represented an element that I've been in the process of parsing,
1:06:33
I've finally hit the end of that element by virtue of this string here.
1:06:42
So I now know that the top thing on the stack is the child element, which simply has to be added to the elements underneath it.
1:06:47
And if you follow the instructions, you'll see that all I have to do here is to do pop, which is a cool pop and add and I need to do.
1:06:57
But yeah, so already on the stack at the top of the stack is the child.
1:07:10
Underneath that is the parent and the pope are not just going to do is out the child to the parent, which with the functionary rights earlier.
1:07:16
So that's my new stake. What about the string?
1:07:22
I give that. Well, what I've got to do now? Like by way of variety, because somebody asked about growth while perhaps I'll use drop well.
1:07:26
So why don't I drop while so, so back to if I come back to the magic whiteboard?
1:07:34
So I've got stuff here, I've just spotted this.
1:07:41
The name of my element is blah, so I'm just at this point here, and this is the string,
1:07:46
this the string I've got in my so I want to get, I want to throw that away.
1:07:53
So I want to look for this character here and chuck away the stuff in between.
1:07:57
And then I can resume my pausing from here. Mm-Hmm. So I'm going to drop all the text in S.
1:08:01
And I want not be cool, but. So all this up until that point, I'm going to throw everything away using drop oil in my arse.
1:08:12
And what I'm going to do here is vote the polls up.
1:08:21
Oh, no, no, no, not I'm going to oh yes, I've got to take the tail of that, mustn't I?
1:08:26
Because that will include this character here.
1:08:31
As we did above, so I've got to throw that character away, so I take the tail off and I know it's well formed,
1:08:35
so that tell that tale tell function call will always work. And all I have to do now is to Paul's point, the result.
1:08:41
I get back from that Paul's point. Right.
1:08:46
I just got to put a space in that kind of misery. OK, so I've got one two three buckets one two three one two.
1:08:52
That should be all right. What good?
1:08:59
OK, that seems fun. Next, what do we need to skip the skip the spices before like, could there be any spices inside the close?
1:09:06
No, no. The car? No, not if it's well formed. I think that's one thing it says broke it.
1:09:17
Oh, hang on. There could be spaces between the brackets. Yeah, between this bracket in this bracket, they'll get thrown away by the drop while.
1:09:23
Now your question is. Is that a precondition on par with Prime, it says the first.
1:09:32
Oh. I'm thinking, thinking, thinking so he have sip space coming in, haven't I?
1:09:46
What happens after an angle bracket? Let's see, let's see what happens in the next room.
1:10:02
You might be right, see rounds in the next room, so I haven't got one of those.
1:10:07
Now the next thing is says to look at and look for one of those. It is the start of the next element.
1:10:12
Yeah, I think this answers your question. I think I'm going to look at the white space in here.
1:10:18
My. Maybe I'm not maybe one of the other helper functions is going to right, so that's my stack.
1:10:23
What do I do now? So so we're going to do some work, so now I've got something which looks like this.
1:10:31
It's a new element, it's got a name, and it may have some attributes here.
1:10:41
Yeah. And then there's going to be that and then the rest of the stuff over here.
1:10:46
Well, we don't have to parse the attributes. What functions do? It's called Paul's attributes, so we'll look at these polls tonight.
1:10:49
Which will always be that. So if I pass the name giving it the string s, because that's where the name starts.
1:10:55
And of course, the past name will throw away the oh, just a quick thing to point.
1:11:04
I think you forgot the prime after the pass for the third case.
1:11:09
Thank you very much. Saved me a lot of time. Yeah, it's very easy to drop the primes, isn't it?
1:11:12
Paul's names, right? So that's going to give me back a pair consisting of the name.
1:11:18
Name of the element and some other remaining characters on uncreative, we call it one.
1:11:25
Now what I've got to do is to parse the attributes,
1:11:35
and that's what I hope it functions all about so I can give you the one that will pose the attributes,
1:11:38
giving me the the the that's the actual name, attribute value pairs and another string as to the remaining text.
1:11:42
And I can just assemble the answer from that because all I have to do.
1:11:52
Let's see. I've got to build an element.
1:11:55
So remember what there was when you hear an opening bracket, you're starting a new element.
1:12:01
So I build a new element with that name with these attributes.
1:12:06
There are no children yet, but by the time I finished parsing, they may get added attached to it.
1:12:10
So a start that's off. But because of the presence of the binding function,
1:12:15
because something stick that's in front of my stack and then that stack becomes a new start for the recursive call to pass prime.
1:12:21
And I get postponements, too, so I think that's that's just plumbing, isn't it? You know, if it's neither that, it just must be text, isn't it?
1:12:31
In which case it should be easy.
1:12:40
So if I've just got some text and then some other stuff and that's my stack, all I have to do is to I can do this in one bit or two.
1:12:43
Let's do it in two bits. So I guess what does text look like or if you look at the instructions?
1:12:51
So now I've got the case where I'm. I've got a text field, so I've done some stuff here and I've now got a text field.
1:12:59
Text in it and text and always at the start of the next element, and the text could, of course, include new lines and Typekit and all sorts of things.
1:13:11
So I just want to just want to go looking through the screen, looking for that. And that's the end of my text field.
1:13:18
So see, so I think that's true.
1:13:23
I'll use my break on not perhaps I should just be consistent, but I'll break because I'm using them fairly consistently.
1:13:26
I'll just look for that character in my string s.
1:13:31
This is going to give me about two things, which is the the text field I'm looking for and some string I'm I.
1:13:36
I'll call this one again, just because that's kind of my convention. And then I got to do is because the past prime, the the S1,
1:13:46
presumably and now I've got the text for the model I want to do is add the text, what was the help of function to do this?
1:13:54
And text which takes the text and adds it.
1:14:00
So I could do this manually, but I've got a helper function to do it, so I might as well just add that to the stuff.
1:14:03
So that puts a new text built on top of the stack. OK.
1:14:08
And I think. But is it does this compile?
1:14:14
No undefined 140.
1:14:22
What about oh, I forgot to delete the undefined thing down? OK, let's try again.
1:14:29
Oh, right, OK, so the programme is the types are correct, therefore the programme must surely be right.
1:14:38
Yes, that's right. And somewhere here, I've got some examples.
1:14:43
So pause, this one should give me that show, baby.
1:14:50
Let's try a slightly more complicated one if I parse Casablanca and print it.
1:15:02
Oh, baby, it's quite easy if you make a mistake, you sometimes find that these strings are a bit ski with.
1:15:14
So I had it look back when I was doing over lunchtime, I lost the T because I forgot to bring back home.
1:15:21
I didn't get lost in the evening. That's actually fun, isn't it?
1:15:27
So again you go, I see this is right now, so so that's a wonderful break for till 10 two and then we'll see if we can do part three.
1:15:30
Well, in time before before the finish, so I'll see you in about four minutes.
1:15:40
All right, welcome back. All right, then part three, are you ready?
1:19:50
See if we can get this to work. Right.
1:19:56
So we're going to a couple of functions, can you just hear me, by the way, to somebody put a hand up just to make sure that we still live it right?
1:20:01
So we got to write just one more function. But what a function.
1:20:13
All right. So there isn't a lot of help here, but you know, it's got something to do with these things called ex parte.
1:20:20
So this is actually an extremely bonded, very powerful feature of example, is that you can embed a language with Maximo,
1:20:28
which enables you to essentially microprocessor sort of thing you play with before there's a macro process
1:20:34
that will build XML for you from a Source X amount of this thing called X and cell style sheet something,
1:20:41
right? So I think I'm going to start by writing a couple of helper functions with with X, so if you come to the magic whiteboard.
1:20:51
If you read the stuff about experts and you've got something like.
1:21:01
Well, it's. Well, in fact, I don't need a magic wand when it's come down here. So something like.
1:21:06
If I've got I brought it as a string, I can have something like that.
1:21:15
Well, that's the next part that just for the arts, the arts of that is just the Part X where I can have x y z.
1:21:19
And basically the way to think about that is says go through and find Child X and all of that fine child one of that fine child z.
1:21:27
So the path is a way of navigating sort of left right down the middle, whatever through it, through a tree,
1:21:34
through a semi-structured tree to get to a point where you've got a value that you want to pull out and stick in your target.
1:21:40
Similarly, if you like. So there's a couple of things in plus needing to know about.
1:21:49
That's the so x x x is the name of a child. That's the current note.
1:21:54
If imagine you're traversing through a tree, that's the current root node of the tree.
1:21:59
So you can have you can keep on doing that if you like and you just this is state the roots there.
1:22:03
The extent they can go down to child C and then what you can do is you can ask for the attribute value of that child.
1:22:07
So that's like a like a base case, I guess in the next part. So you're looking at something other than what you want to do is you want to,
1:22:19
first of all, process that string to pick out the individual elements of the path.
1:22:24
And those individual elements are going to be named dots or acts.
1:22:29
And if it's an act, the thing is following the arches, the name of the attribute that you want.
1:22:33
So you'll see something like APT take one, and that's the name of the attribute.
1:22:37
OK. So somehow we've got to turn something like that into a list consisting of the while the String X, the String Y and so on.
1:22:42
And that's the first task that we need.
1:22:54
So it's actually an obvious helper function that might have been a hint in the in the description somewhere, but let's do that.
1:22:56
So what should we call it will with some pause x path, which is going to take a string and generates a list of strings?
1:23:03
It's actually really simple. Think about it because what I'm going to do, I know that the these strings that they are limited by the the slash thing.
1:23:16
And when do I stop and I stop and the strain runs out, so that presumably just gives me that.
1:23:27
Well, actually does it. Well, think about it in a minute. Well, what do I want if I got.
1:23:35
I think if I've just got the empty string.
1:23:48
Think I think I want that. If not, we'll take it out, but I think when I was doing this, I feel like someone needed that right.
1:23:55
Let's just say, right, so so if it's not that, then it must be some non empty string.
1:24:04
Then all I've got to do is and I've got the tools of the trade here because I know I can break the string at the next.
1:24:14
Just using the stuff we've been using before, I can break it to the next character.
1:24:25
So as my strengths and this is going to give me a pair of strings,
1:24:29
which is the which is the all imaginary called Mess one, the next to this one is going to be x one s one here.
1:24:34
Down on the example s one would be the String X and S2 is all the stuff after it, which is this lot here.
1:24:43
Yeah. So that begins with the slash character.
1:24:52
So presumably assuming the string is well formed, I can just take the tail.
1:24:57
So I do what I did before, which is something like, I don't care.
1:25:01
Oh no, I do care because I can't do that. I can't do that for this reason.
1:25:06
Because, yeah, what I'd like to do in a minute is something like take the tail of two and simply recurs.
1:25:12
By doing this in the past, its path on the trail.
1:25:19
And I must know as one as my first things, I remember this one sitting on the front.
1:25:24
So I want something like that. Which will work jolly well, but will only work if if there is.
1:25:29
If there's a non-existing has to. Because it could be that I get back.
1:25:39
So if I'm at the end of the street, let's see if I come down.
1:25:47
So let's see, supposing I've got something like.
1:25:53
Supposing I've just got X right, this is going to give me back, so we're looking at this bright thing,
1:25:59
I'm going to get back to strings, which in fact we can do it break.
1:26:04
It's trite I say break equals.
1:26:10
Think, think, think on the String X now I get that the X and the empty string,
1:26:16
so I'm not always guaranteed to get back on non-active string, therefore this is dangerous.
1:26:22
In fact, it's in general, it's not right. So there's obviously a separate case.
1:26:26
Do you want me to do something like a break or a you've got to think?
1:26:32
Is it always is that a pre-condition which tells me that the star is going to be not empty or not?
1:26:35
And here there is absolutely no precondition.
1:26:40
So you're going to have to check to see, first of all, whether the S2 is no, because it's a special case.
1:26:42
How do we ask whether something's empty we use? No. You could do it.
1:26:48
I don't like that. I would rather you did that now.
1:26:54
Otherwise, then, then we're good to go. For now, I've protected myself from this possibility, but as too could be, could be empty.
1:27:00
Could be no. Now what if it is? Well, the answer is just this one, isn't it?
1:27:08
That's exactly what I wanted from this example. So I know from that example.
1:27:12
Well, I think I probably just, yeah, maybe I did share your comment.
1:27:16
OK. So is that it? I think it is.
1:27:24
So let's. Let's pause just as a sanity check.
1:27:31
Sure, as we'll do it here. Oh.
1:27:38
I lost it because I killed it x y. The Dot Dot.
1:27:48
Whatever I had see. Something.
1:27:55
That's what was going to be the end. Pause X path, right, they go, how about that?
1:28:02
So let's check the edge cases. If I've got that, I want that.
1:28:12
And what happens if I've got that? That I think is right.
1:28:21
If not, we'll soon find out. Right?
1:28:29
OK, so that poses it. Now the other thing you've got to be able to do is what's the what's the mental picture, the mental picture?
1:28:33
We got this this piece of semi-structured data. You know, this structured data?
1:28:40
You know, we're doing something like this. So we're navigating, you know, left and then down and then right and then left or something.
1:28:47
So this navigation is really what's what's been specified by the path.
1:28:56
So, you know, you've got some, some, some name. What was it, X and Y and Z here and then one, some nine K here.
1:28:59
And then perhaps I want the attribute value. This note in the trailer, this is the idea.
1:29:08
So this this tree that I started with this thing here is the context which I'll call context or subtext.
1:29:15
Context, perhaps. And the path is going to come from this thing.
1:29:22
This party is going to come from the Xcel. So the extra cell tells me what path to follow in the context of the context is this sort the
1:29:28
source data to pick stuff out from the source data to assemble my external object elsewhere.
1:29:38
Right. So the other function I need is one that's going to follow its path.
1:29:48
And this is going to be this is going to take a while unless the string that I get back from the past.
1:29:53
This is the list of string I get back from the past, I could combine these on just maybe it's useful,
1:30:00
maybe just to separate them, but I'm not going to get back.
1:30:07
Well, I know I've got to give it the context, which is the excessive melting I've just been talking to you about.
1:30:13
And so I'm just going to navigate my way through the extra mile to give me back a list of things.
1:30:16
Now it's a list of things that's the sort of that's where the excel works. I get back a list of things.
1:30:22
That's how you use that to build tables and sell them to populate tables. So I won't get back a list of examples.
1:30:27
We'll see how this works in a minute, so follow the path says.
1:30:34
Right. So that's what I can see. I can see dots, acts and names.
1:30:42
And eventually the path will run out. It's the past runs out. I'm staring at this context.
1:30:49
Perhaps I should just call it seat context. Then I get back.
1:30:54
Well, it's tempting to write context. Oh, I see. I'm narrow. I've now hit the rocks.
1:31:00
I've not navigated left, right, left right through the tree. Using the the path.
1:31:03
I've hit a particular node in the tree and now I want to stop. There it is.
1:31:09
Well, that's also, but in this case, must be where I am in the tree, which is the context.
1:31:12
So think of the context as the example object that you're navigating your way through.
1:31:16
Now, of course, the thing to remember is that the way this that this accessible thing is, you get a list of objects.
1:31:21
So in this case, it must be a singleton. This, mustn't it?
1:31:27
The type checker would soon tell you you've made a mistake, but that's that's what you want, right?
1:31:30
What's the next thing that you remember? Well, if it's not entry, then from what I showed you just down here.
1:31:35
It's a list of. Steps, if you like.
1:31:50
So there's a series of steps that navigate me through the trip, so to follow an X path.
1:31:54
If I got a non-entity path now, well, the front, the first element of the path could be any number of things.
1:32:01
Let's say the the first thing could be a dot. So again, you can use the string pattern.
1:32:08
And if I've got a dot and some path up here and I've got some some context here, what do I do?
1:32:13
Well, that is just the context, isn't it? So it's kind of you have stuff after.
1:32:21
Oh, yes, of course you can have stuff after.
1:32:29
Yes, it's because I could say here, for example, I could go dot dot, dot, dot dot, and then there could be some more stuff.
1:32:31
So I got the recursively process, the X path, but I could ignore the dot because the Dot doesn't change the context.
1:32:37
So I think this is just a question of follow past recursively pay using the same context, because that's what Dot means.
1:32:46
Dot means just use the current context. What else could it be?
1:32:54
Well, it could be a the an attribute in which case we know it begins with a we know it begins.
1:33:00
So there's some thing in here and there's the context.
1:33:07
There's something in here which is a string beginning with the character act.
1:33:13
So that's going to be something of the Form Act. I'll put brackets round it, it's a string beginning with an act.
1:33:19
And who's remaining stock is the name of the attribute.
1:33:27
So for example, here. All right.
1:33:33
You see you see a that symbol. And then these characters say the string here is the name of the to be.
1:33:37
I'm interested in picking out from my context, how do I pick out a thing called at from my context?
1:33:43
Well, what it says is what was the the function we call it, get attributed with?
1:33:50
So we get our tribute act from the context, which is maybe I should call the context.
1:33:57
Similarly, it's just a piece of metal, but as we're navigating through it, we can sort of hear arbitrary points in.
1:34:03
So I guess it's historically people call it a context. Right?
1:34:09
So that is a string. And what I've got to generate is a list of X amount, so that's going to be a singleton thing.
1:34:14
And how do I turn a string into a piece of smell? I wrap it up in a text.
1:34:24
So I think we want that. So in other words, when you see that says, stop here.
1:34:31
And give me back the text field.
1:34:39
The text associated with that attribute. Right.
1:34:43
What's the only other thing it can be is if I see a name now, so if I see a name?
1:34:50
Then this thing, for example, the X, the Y, the Z, it's the name, by the way, if I go down here.
1:34:59
And this could be any old name. No, it's just a name of one of the children at this point in the tree.
1:35:08
So it's just an arbitrary string. So if I've got some name and it's the name of a child, so a what sea name, child name?
1:35:15
And that's my pee. And here's the context. What do I do?
1:35:27
I do the same thing again. I just I've got to sort of follow the same path from the children.
1:35:31
Now here's where this list thing comes in, because what I got to do is I've got to follow the path on each child because each child could me up,
1:35:36
give me back a different list of examples. So this is how you assemble.
1:35:44
A list of examples from a single element is by processing the children.
1:35:49
So the first thing to do is get the children. That's for the help function you write early. One does.
1:35:53
So there's the name of the child. There's the context from which we're going to get the children.
1:35:58
So whatever the root element is, there may not be any children, but there may be some common.
1:36:03
Text, so we're going to get the children, so that's a list of symbols.
1:36:09
And now this function takes one of those extra bells.
1:36:16
So therefore, we're going to have to do a map.
1:36:21
We're going to map what well, if you think about it back to the story, a partial application, follow X path with P.
1:36:26
So I've already pulled off the name.
1:36:36
This thing here, I pulled off the name, so I want to process the rest of the path, which is the pay gap for each child.
1:36:39
So I simply want to map this partial application. It's the same each time, but with a different child.
1:36:49
Now, why don't I do that? Guess what? Follow follow its path gives me back.
1:36:58
It gives me back a list of examples. So I don't just want a map, I want to conquer Mountain because I've each of them gives me a list of accidents,
1:37:01
I've got a list of list of symbols and I have to.
1:37:10
Conquer them together,
1:37:16
so I think I want to conquer map and then that should make the types of lives of the type system actually help you to get programme like good.
1:37:17
I think that's it. I'm sorry to interrupt some of your follow up, just missing an extended name.
1:37:26
Oh, am I miss Typekit them? Follow. Oh yes, follow x path.
1:37:35
Two of them. Yeah, that's. I you. Oh, it can pass.
1:37:40
It must be right, mustn't they, right the last function, the stinker, a stinker.
1:37:55
We got it. We got just enough time to do it.
1:38:03
Right. So here we go now we've got this Excel thing.
1:38:08
There's this beast. And in fact, if we go, look at the example.
1:38:12
Somewhere up here, I think it was section four. There we are.
1:38:18
There's an Excel document. So now what we're going to have to do is to walk through the exact same old document.
1:38:23
The idea is that you kind of leave behind the example that you want to output.
1:38:27
So it says, do that, do that, do that, do that, do that.
1:38:32
Do that, do that, do that, do that, do that and are OK now we've got this is the XFL stuff and now we've got a fridge.
1:38:40
That says, go through every film and do the following. Do you see this is where they map over the children, works for each child, for each film?
1:38:48
Do this lot so you generate one of these table rows for each film. So in principle is very simple.
1:38:56
It's just about getting the contracts right. We'll see you in a minute and say, Okay, what am I going to do?
1:39:03
Well, okay. Oh, okay. Here's another bit of acting so valuable that says, OK, what's I've got to this point in the tree?
1:39:07
So I've got this, this, this, this, this film, X-Men. I want to know the title of the film, and then I want to know the director of the film.
1:39:13
I want to know the composer of the film. And this is what the valuable thing does.
1:39:19
So for each precursors into the children and the base case is the leaf is b.
1:39:22
Oh, finally got there. I just want to pick up the values I want,
1:39:27
and then what I got gets left behind is essentially a copy of this template with each of these things substituted and that copy looks like that.
1:39:30
So it's actually the same thing where these things have just been replaced by specific instances of the data from the respective films.
1:39:40
All right, so here we go now. Let's go to we do.
1:39:50
I need to do which one should, which rule should we do first?
1:39:57
So there's only there's only two. Let's let's do the easy case.
1:40:01
There's two cases, you know, I guess, on there. So here's the concept the context that precedes the first argument and this for some reason.
1:40:05
So I may see an element with a name and some attributes and some children or I may see.
1:40:11
Or I may see something else. Well, it is not an element, it just must just be a text field, mustn't it?
1:40:26
That's the only thing it could be. And I must promise to give back a list of examples.
1:40:33
So the base case is actually quite easy. I think it just take.
1:40:39
I don't need the context, even so, I can just underscore that out.
1:40:44
All right, so if it's just a text field, that's the answer because there's nothing more I can do.
1:40:48
I can't request into a text field. It is the leaf of the the small object, so I just give it back as a singleton list.
1:40:54
So the beast is this one here, right?
1:41:02
So I'm going to do something about this now having lovingly written this, this one, this.
1:41:06
Boss thing, what have I got? I've got one of the following paths, wasn't it?
1:41:15
So so if it's not? If it's not a text field, it must be an element.
1:41:22
And the question is, what is the element asking me to do? So it depends, doesn't it?
1:41:32
So it depends on this name. So if I come back to the example?
1:41:39
What's this asking me to do if I see here an element whose name is for each?
1:41:48
I've got to do one Typekit thing. If I see an element whose name is value.
1:41:53
I've got to do another type of thing. But in each case, can you see that there's a select attribute on the one there?
1:41:57
So, so. In general, I may see a select activity if I'm up here.
1:42:06
I don't see a select attribute. There's no select activity anywhere yet in this stuff, but I can go looking for one.
1:42:14
So what I'm going to do is I'm going to try to get the attribute called select where am I going to look for it?
1:42:22
When you look for in this element, I don't want to copy the element out, but I'll just name the whole thing.
1:42:31
So let's nail it so I can look in it for the the select attribute, it may not be that it's fine.
1:42:39
If it's not there, it doesn't. It doesn't, it doesn't do any harm. So I'm going to get that and then that will give me an X path.
1:42:45
Sure. Let's just check it. Yes, this gives me an exit path and there is the X path.
1:42:52
And here is the export, yeah, so the attribute value is the export.
1:42:59
So what I get there is a next path. What do I do with exports?
1:43:07
Have a guess. I pass them.
1:43:13
Capital T and having passed them, I could combine these two function that occurs to me actually does I'm typing this, but I follow its path.
1:43:20
Yeah, fact. I think every time I use paths, I use follow. So I probably and that should be a capital allocation in that right.
1:43:29
So every time a pause I follow so I could combine these, if there's time we'll do it, let's just do it right.
1:43:37
So now if I follow that, I get back a list of elements because that's what follow x path does.
1:43:44
It gives me back a list of small elements, so I'll call the elements now.
1:43:51
It needs not only the path, but of course it's got to know the X amount it's got to look through in order to get those elements.
1:43:58
So I've got a pass in the context and then that's it.
1:44:04
So now that's first job done is I've got the the elements.
1:44:07
So if I go back to the example, if it's the fridge, select them.
1:44:11
So I've now looked through my my film X and L document.
1:44:15
I pulled off the the name of each film in the list, so it's gone through.
1:44:20
It found the film list found the film and I've got a list of the the.
1:44:25
The the film objects to reach film in the original Excel document, and that's what my Elam's is.
1:44:31
What's happened here? Oh, OK. Right, then, what do I do next right then?
1:44:42
Now I've got to look at this element because it could just be and it's just an ordinary thing.
1:44:51
It could be an instruction in this part of the Excel specification.
1:44:57
So what I've got to do is look at the name and see what to do. So the name, it could be valuable which guys are.
1:45:02
I've got to use the X path. It could be. It could be.
1:45:10
What's the other one for each, isn't it? With a hyphen? With a hyphen?
1:45:18
I think for each case, I've got to do that. Or it could be some other line, which case it's not accessible, it's just ordinary x amount.
1:45:23
So perhaps we'll do that last code first. If that's the situation, then I simply have to reconstruct this element.
1:45:34
Because its name doesn't change, its attributes don't change, but the children may contain stuff that's required by the Excel thing, if you like.
1:45:43
So. I got to do something like I've got to X and.
1:45:55
The Excel. So this is so this is the ninth, so this this thing that Patrick, this thing here, this thing here is the access out element.
1:46:03
So yeah, that's way. So remember what the XSLT is. It's it's a it's a template.
1:46:18
So if it's not asking me to do a valuable before its replacement, you just you just.
1:46:23
You just deliver about the template. Well, here is the template, but of course,
1:46:28
I've got to push the recursion into the children into these seas because there may be there may be values over them for each creatures inside those.
1:46:30
The list of children. Right. So I've got to do something like this, I've got to expand access.
1:46:39
Prime. I'm giving it the same context.
1:46:48
Oh, that's why I put the context first when I set the exercise up, so you could partially apply it.
1:46:55
Yes, OK, very nice. So I want to map that function.
1:46:59
Not that function over for this, the children presumably says, and in fact,
1:47:07
is that a and then I want to close that record off because that's the end of my singles and this I've got to return a list of X-amount elements.
1:47:15
So this is we'll just return the element as it is as a singleton and push the percussion into the children and each core to expand access.
1:47:23
So Prime gives me a list of examples. Therefore, if I make it, I get a list of list of acts.
1:47:31
And also once again, I could get map, not a map sugar.
1:47:36
Conquered map over that. Now I think that's.
1:47:44
Right, so take the element that's the name, those the attributes, I pushed the recursion.
1:47:52
Because the context hasn't changed. I'm just pushing the recursion into the children,
1:47:59
and I concatenate the results that come back because I guess I guess, I guess a list of examples for each child.
1:48:04
That's correct. Isn't that right? So we're getting there.
1:48:12
Let's look at the value of things, first of all. So now I've got value of.
1:48:15
So I've got something like this. I guess so.
1:48:20
What do I need to do, I need to. I need to get the value of the woke up, so the.
1:48:34
Think, think, think I've got value of. That's the path which they've just processed.
1:48:51
Oh, OK, so my so here.
1:49:05
Alright, so so what I've taken, I've taken I've taken the select thing, there it is then to select.
1:49:12
I've got the attributes, I followed the export, give me a list of elements.
1:49:18
So what I've got in my hand are the elements now, and what I want to do is what is the semantics of the semantics of this is I take the head element.
1:49:23
Don't lie. That's right.
1:49:31
So when I say value of I could that could be there could be any number of things I could take the value of and that excess excel,
1:49:35
Symantec says, you always take the head. This is just one that we have to read the specification.
1:49:42
So what I've got to do is I've got to take the head of those elements because, yes, there could be several of them.
1:49:47
And then I've got to get the. And then got cool, get value on that, but get value on that element.
1:49:54
And again, that's got to be a that's going to get what get value gives me an example.
1:50:07
Huh. So the head to the elements is the. The head of the elements is.
1:50:14
This thing is the path.
1:50:22
I followed the path in the context to give me a list of elements I only want the head element, so that had element is an example.
1:50:25
So I want the value of the example, let's say I want the value of the extra mile, which is just text, and then I'm going to stick that in brackets.
1:50:35
That's right. It's not easy. You've got to keep a clear head right now for each.
1:50:43
Oh, wait a minute, wait a minute, wait. We got another one of these, haven't we? I have no idea whether this thing is this elements is empty or not.
1:50:52
So there's actually an edge case here. Because it could be that that the.
1:50:58
So I could be asked. It's perfectly legitimate to ask for the value of something that isn't there, in which case you just return the empty string.
1:51:11
Yeah. So this is again, you've got to look at the SSL specification, what to do if there's no value?
1:51:19
Well, it doesn't say fall over and die. Just just give me back. I just give me back, essentially, and it detects string.
1:51:24
But of course, we're going to give you a list of examples. So if that's the case, we just got to do that.
1:51:29
And that's an edge case. Now, if this pattern doesn't match, we know that the elements are nonno,
1:51:35
in which case it's safe to take the head and which case it's safe to apply the value and then form the singleton this back.
1:51:44
So in both of these two were just returning a singleton list of examples. And now the difficult one, you thought that was hard.
1:51:51
Right? So what? I've got to do something like this again. I'm sorry.
1:51:59
Should you have name equals equals of the gods? Oh yes, you're absolutely right.
1:52:03
Today we're writing Haskell code nonadherence. You know, no alums.
1:52:10
Well, I think, oh yes, I forgot to tell you, I read it out and didn't Typekit.
1:52:18
Yeah. Thank you. And I'm not going to bother to align the equals here because I'm running out of space as it is, right?
1:52:23
So I want to do something similar at some of these things. A list I can probably just actually just.
1:52:29
Just stick that in here because I got to do something fairly simple.
1:52:35
Again. But now I'm not reversing into the.
1:52:39
Or am I am? What do I want to recursive cursing I don't want because it's the context.
1:52:47
I want to recurs into. Hmm.
1:52:59
Bear with me, bear with me. Oh, you wrote that, so I've got this list of Alan's.
1:53:07
Can we go back and look at this one? I've got this list of so here's a for each.
1:53:16
Right, so now I got this list about these, these are the so in my in my film sets, I've got a list of elements that come back in other ways.
1:53:23
It's the films in my in my XXL context.
1:53:30
I go through the film list and get back a film for each one. So I've got a list of elements which are films.
1:53:34
Now for each of those. I've got to expand the excel using that.
1:53:41
As the context, so I think I want.
1:53:50
I want to move on, I want to use another map, but I've already using a map here, so I'm going to use a list comprehension.
1:53:55
What you're telling us the other way round is just this two strikes on the line.
1:54:05
So what I'm trying to do is I want to build a list, I want to go through each element.
1:54:09
So that's now a that's a film, and I think of a compliment to you when you stop think of a concrete example.
1:54:18
OK, that is a film. Brilliant. So now got a film in my hand?
1:54:25
What do I do with it? So I want to in general for each film, I've got to recursively.
1:54:28
Do this. I want to do that with my film, with my E, and that gets given the what's the argument that got to be, I've got to take the look at each.
1:54:38
Concrete map expenses of. Right, that must be the season again, isn't it?
1:54:59
Yes, it's going to be the same thing. It's exactly the same as this. It's exactly the same as that, except instead of that.
1:55:08
I'm picking out the elements, so in other words, like think, instead of just focussing through the original film's access, everything.
1:55:18
I'm not rehearsing, just going from one lap to the next. I'm using the next part to pick out the next place to look.
1:55:24
So I'm jumping straight through that, which is what the lens gives me.
1:55:29
That's what the X part is giving me.
1:55:33
So now I recurs into the eat the element, which is an element of the context, but I've now got to carry on when I to push through the recursion.
1:55:34
I'm going through this the set of this list of XXL children.
1:55:43
So, right, OK, I think that's why I come up expanded that. So there's my that's that's that's right.
1:55:48
That is right, I think I can just do this. I'm probably well advised, in fact, when I run out of white space,
1:55:59
I tend to do this because I do like to align my bottom sides up, so sometimes I just want to do that actually.
1:56:08
So I've got that. Now let's just think about this, this is a.
1:56:23
But each one of those gives me a list of extra medals. When I nap, I get a list of list of smells.
1:56:28
When I come catch it, I go back to a list of smells, but it's sitting inside a list comprehension, so that's a list of list of smells.
1:56:40
So I think I need to conquer. Told him was hard, Russia, you got a question while I stare at the code.
1:56:51
In the last in the last card, I was in the context changed when we moved through to do the next one was the context E.
1:57:03
You know, it's because if you're just if you're just walking down some smell, you just were coerced into your children, don't you?
1:57:14
You go left, right, middle, left white, middle dirt dead.
1:57:21
The path is essentially giving you an opportunity to hop to further down the tree to a particular place you're interested in.
1:57:25
So the exit path, if you like short circuits, you threw the tree into a set of places where you're interested in continuing the recursion.
1:57:32
That's what's actually going on here.
1:57:39
Now, of course, when you're when you're traversing through the excel, you have to go line by line through the tree.
1:57:42
Because the access is the template, so you got to say copy the template, copy the template copy of copy the template.
1:57:50
What do I plug in here? Go to the context and pull out the names of the films, go into the context and pull out the something else.
1:57:55
Yeah. So that's what's going on here. So when we're when we're doing the value of case, why don't we have to think about the context?
1:58:01
Here, you mean? Yeah, because the Elam's is is you've already used the expo to look into the context.
1:58:12
So the lines are bits of the context. I reached the base case now I say, OK, well, give me the text, give me the text field I've just arrived at.
1:58:22
My guess is one way of putting it. Who's next?
1:58:35
It a better still convention to use part of much to screen the more likely you did in the grunts than you cosy close to something.
1:58:47
Yeah. I think when you're if you're just looking at strings that by its very nature, the metal is text processing.
1:58:58
So it's quite OK. I think just to put text literally in patterns, it's in God's there in God's, if not in patents.
1:59:08
Oh, you met with your question or your question is, could you put them in?
1:59:16
Yeah, that would be fine, actually, if you wanted to read about the programme and put the text drawings in.
1:59:18
Yeah. So I could have a separate line here element and I could I could do.
1:59:22
The trouble is, you end up reproducing quite a lot of boilerplate, don't you? Because you'd have to copy this line of progress.
1:59:28
And yeah, yeah, adding. And he.
1:59:33
To shout if you want a question. I'm sorry, can you hit the I want your question?
1:59:44
Yeah, I was. I was also just wondering about the pattern matching versus God because like you, because it's not just the boilerplate,
1:59:52
like you're also reproducing the logic for calculating alarms because you have to give up the value of it to make a judgement.
1:59:57
So if you could try it, go away and experiment with,
2:00:03
you can copy this line of code out and you can just substitute a different literal in here value of value of.
2:00:06
But then this, the way I've written, is slightly entangled up in this logic here, isn't it?
2:00:13
Yeah. In general, if I hadn't thought about doing that, I mean,
2:00:18
I've probably spent five years thinking about just thought it's a really bad idea, which is why I ended up doing it this way.
2:00:22
But it seemed to me that that was the obvious way to do it.
2:00:27
I think I need to get to the end. Can I just try and finish this off? All right, so.
2:00:31
Good, it actually can pass, it must work at the moment, it should we try it.
2:00:38
So it claims let's just do a little test case if we take one of these.
2:00:48
Fingers crossed. Oh, well, that's a good start, right?
2:00:55
Should we go for it?
2:01:03
So this should give me the list of films as of as so this would be the copy template with the film date of in if we've got it right.
2:01:08
Well, that's a good start.
2:01:20
If I can do a diff because I've got somewhere, I've got one line I can do is I can put that into me just just to say, you know, I'm not cheating.
2:01:23
Yeah, I haven't got I haven't got VPN turned on.
2:01:36
In case you're wondering why I'm doing this, because I don't trust VPN when I'm trying to run things, I think it's just a really bad idea.
2:01:38
Oh. OK, fair enough. So what six copy the films each HTML into somewhere where I can read it from my
2:01:48
browser and I think it's probably just do a C motion as long as I'm using this.
2:01:57
OK, so if I go to my browser, I look in here.
2:02:08
I do that. No, baby. Yeah.
2:02:15
And I think you'll find if it does, that is bound to do the other one, isn't it? So I do actually have a test here, so if I go.
2:02:21
Where are we? And there's another one, which is the composers, if I run that.
2:02:36
I can do different work, so I can do.
2:02:49
How do I do this in GHC? Oh, I can't remember.
2:02:54
I can do different composers. I've got composers correct from the from the stuff I gave you on the web, I think.
2:03:00
No, baby. Right, OK, we really need to stop.
2:03:10
We've run out of time. Some. It's really, really hard, isn't it?
2:03:14
I think it's absolutely fine until you get here. Category under 40, so what's so easy to get wrong is that, you know,
2:03:20
you kind of know you've got to push the recursion because it describes what to do, but then you remember is this is the Mac is a copycat Mac.
2:03:29
Do I have to conquer when I've come out?
2:03:36
And this was the line of code that threw a lot of students because remember standing behind them as they were struggling to get it right?
2:03:38
And if you'd like to, if you're interested,
2:03:44
I didn't think anyone was going to get to the end and I was done in the labs in this particular year and I was walking around the labs and I could
2:03:48
see there was one student who I knew very well because it was one of my duties and I could see he was getting perilously close to getting the answer,
2:03:54
and I could see him cutting and mapping and thrashing about.
2:04:00
And literally, as the as the bell rang for the end of the test, he hit the return button and it worked.
2:04:04
So he was the only student who actually managed to get right to the end with everything possible with tests.
2:04:12
It was that he was. So it was a fantastic effort, I thought, because it was a really hot test.
2:04:17
I think giving it another half an hour, lots of people would have got it working. But. Getting it all right in the time available, dummy.
2:04:22
What's your question?
2:04:29
It's honestly just syntax based instead of using like the the gods, I use the case of, then for the value of parts, I used an if statement.
2:04:33
Oh sure, yeah. But feel free to use cases. And if that's fine, as long as it looks beautiful and people can read it, you know what you should be?
2:04:44
Read Haskell programmes, you know. Click, click click. I know.
2:04:51
I know it gets messy. When you're looking at this stuff in concrete matter data, there's possibly a button like this,
2:04:55
but maybe using a bit of perhaps I could pull this off and name these bits in a where clause just sort of simplifies a little bit, but not you.
2:05:01
We're doing polymorphic type conference tomorrow, right? Yeah.
2:05:12
So is that going to be relevant to our tennis like how they're going to be similarities there?
2:05:17
Or is it just I think no, probably not so much.
2:05:22
So if you wanted to look at one more, I think probably the constant propagation one would be one you could play with between now and tomorrow.
2:05:26
The way the world will is going to be doing that one tomorrow, I think not because we'll set one of these test years ago.
2:05:31
So he's been he's been a victim of what I might say. And I think actually having a having a test explained by somebody else is a really good thing.
2:05:37
And the other reason I wanted to show it to you is because it is one of one of the most beautiful algorithms in computer science.
2:05:45
And I think, you know, if you're teaching Haskell, which is a horrible, polymorphic polymer, it's like programming language.
2:05:50
I think actually showing you how it infers types is just the most amazing thing.
2:05:55
So it's I guess you'll learn less about Wednesday's test by going coming along tomorrow,
2:06:00
but you'll you'll see you'll get an explanation from another from an expert at this sort of thing on how to do tests beautifully.
2:06:07
You can. You can. You can pick Bill's brain, say, what was it like for you?
2:06:17
Well, OK, so should we just lots question three on this year's test will and things like that?
2:06:19
Oh, that's for you. Yeah. Hello.
2:06:26
So can you show. Scroll down to Cast Path again.
2:06:32
Joe? Yeah, I was looking at this, I would actually.
2:06:38
Because if you notice in this programme here, every time I call. The only time I call it, I call them together.
2:06:42
So what I really should have is one function here to perhaps follow its path should actually do the parsing as part of the job.
2:06:47
So I think if I had five more minutes, I would combine these two. But I probably just need one more minute of audio overruns.
2:06:54
Can you do that again? Yes, I kind of Mr. So what I said was that when I call ex-parte, I always follow what I call follow.
2:07:02
I always. It always needs. So these two, they're only ever used together.
2:07:11
So why have two functions I could? I could combine them into one function. So follow x path could take a string this thing and.
2:07:16
So follow expert could take a list of strings. What do I want to happen to any couples, each one of them?
2:07:31
I guess. I just I just composed these two together, I could compose these two functions into one.
2:07:39
And then I wouldn't, you know, it's it's it's it's fine. Leave it as it is.
2:07:45
It's absolutely fine. Hetty, what's your question? And this is just like a general syntax thing,
2:07:50
do you get marks for like like variable like proper variable names and like commenting and stuff to be comment?
2:07:57
Yeah, do please comment your code, but don't put your comments here, right?
2:08:05
It's just trying to be annoying when you're trying to read a programme in someone's littered with comments,
2:08:12
you know, could they put another one here like, you know, when it comes to the next guy, you know it?
2:08:16
Don't put comments that if it's something that you particularly wanted to to say, you can put your comment here.
2:08:23
And variable names are really important. Yes. And so I've tried here to use sensible names like contexts or whatever you choose for that pay for path.
2:08:38
I asked for attribute. Seen a child knowing it's something that gives you a clue as to what the object is from its name.
2:08:49
But don't use don't be tempted to write. This isn't help.
2:09:00
This isn't if you got a function which takes in, it generates for something.
2:09:05
It doesn't help to call it it. So try not to pick names which are just reproducing the type.
2:09:10
So this is actually it's a counter of the number of people called Stanley.
2:09:16
So, you know, and for a counter or, you know, k or something, but don't just call it, it's not really helping.
2:09:22
So are we expected to comment occurred then? Not really.
2:09:29
These exercises are pretty small. OK.
2:09:36
And what is this project that I'm working on a big house project at the moment where if I don't comment what I've done and I come,
2:09:41
look at the code the following week, I have absolutely no idea what's going on.
2:09:46
So I literally prefix the awkward functions I prefix are often quite long comments to remind me what the logic is doing.
2:09:50
If it's these are relatively straightforward exercises even down here.
2:10:01
I mean, if you thought you weren't you, all you're doing is following is following the instructions in the in the spec, at least up to a point.
2:10:04
So it's not absolutely necessary, I don't think.
2:10:10
But if you are going to put a comment, you know, make sure it's a worthwhile one and stick it well out of the way the code.
2:10:14
So it doesn't doesn't mess up the logic. Pressure.
2:10:19
And then I'm going to know it's like I'm going to keep moving if you need to leave, just leave.
2:10:24
It's fine pressure. So when I went through this,
2:10:29
I actually did pattern matching before anything else in terms of like spotting when it was valuable for each and then working through it.
2:10:32
And I know it's slightly less efficient because I'm using the same lines of code, essentially twice one in the value of case one in the for each case.
2:10:42
So in terms of efficiency, how many marks would I lose in this kind of question?
2:10:51
I'm just curious. Well, let's let me just stare at it.
2:10:56
What you're saying is that you've got you. You've replaced that with that.
2:11:01
Yeah. Now, because there's a we need to do it.
2:11:07
We still need to do a no check, don't we? So I need something like that.
2:11:11
In which case I've got to reproduce this, this thing in here.
2:11:15
I guess. So this is the problem you get is that you might have to reproduce this logic here.
2:11:22
And then here I'd have another what I have here. I'm just making this off this post with better ways to factor, but I wouldn't need that now, would I?
2:11:31
Because I could just do that and then here I can have.
2:11:40
I meant also that the like the horse export and the follow export once they were done separately for value opened for each because for each I was.
2:11:45
The value of getting the child and four for each child using get children, so they were done slightly differently in that for my oh, I see.
2:11:59
I think the way I've done it here is that it doesn't matter, does it?
2:12:09
Because you know, there's this this Elam's could be empty. It could be a singleton, or it could be as many as you want.
2:12:13
But I think when I was working for it, initially I was.
2:12:19
I found that creating shareable functions was a bit too confusing for me, and I preferred to work by case.
2:12:22
I know it's not as elegant, but I mean, I think you know this, it's not easy.
2:12:28
I completely agree. And I'm looking at this, and I'm just wondering whether I could. It's almost tempting because I've gotten out.
2:12:34
You see, the thing is, I've now got this line of code here. Which is the same as this line of code here, but of course,
2:12:40
the obvious way to factor that is to take this function is to take this function and test it inside a workflow.
2:12:46
What about go up are going to work? So perhaps I could have.
2:12:58
So I might have said, maybe this is a kind of making this up as I go along, but so I can have that like a where?
2:13:01
Now that's no help not sitting at that. Now, once you got the workload, you see, now I can pull this out.
2:13:12
And put this here. Can I do this?
2:13:19
Does this help? So if I'd got. Because all I need, all I need for this line of good, I've got the compass, I've got this thing.
2:13:25
I've got something like this. So that's the context I need.
2:13:40
What else do I need? I need the. The.
2:13:45
Oh. What's lost something? What's he?
2:13:52
Oh, he's my top out of my top level element, this thing here, isn't it? Yeah, right?
2:14:00
So OK, so that's well, that's all I need for that. In fact, I don't.
2:14:04
I just need to know. I can just do that contact.
2:14:11
In fact, another one. I'm just playing just, you know, because if I've got 10 minutes left at the end of the test on March through.
2:14:16
OK, so that means I've now done this Elin's thing once and then I've got to define the function.
2:14:24
So now perhaps I can delegates to expand access SSL double prime and then I can put some stuff in here.
2:14:31
And then this lot here I could. Rename this to try to, uh, so I'm playing now, is that any easier?
2:14:40
So now see what I've done now. What we talking about scope earlier on me.
2:14:54
So now now Ealons is in scope everywhere in this helper function, and if I need it twice, I can just refer to it by name.
2:14:59
So that's sort of fine. Of course, I'd have to pass in the same element.
2:15:06
Might have to put the context, is also now in scope everywhere, so I don't need that.
2:15:13
But I could just do that, couldn't it? And then I wouldn't need context here.
2:15:19
I wouldn't need that, and I wouldn't need that, and I wouldn't need. OK, so and I wouldn't need that.
2:15:26
And you say, Well, I mean, I'm just playing around. I'm not sure there's any better or worse.
2:15:32
Who who knows? Matthew? Hypothetically, if we were to pass all the tests in the example that our quality of goods is in the best,
2:15:40
what do you know the maximum amount of blocks we could get?
2:15:51
Oh, I've seen students who not so much in the final Test, actually, if you pass all the tests, that's amazing.
2:15:54
Well done. You're going to do well. So it's more an issue for me because the practise test or interim test,
2:16:01
just because you pass all the tests in general doesn't mean you say you've written a good programme. Some of you would have learnt that.
2:16:10
Some sure already. If you asked me what the maximum what you can get is, absolutely no idea depends on the marking scheme.
2:16:15
Usually, you know, if usually there's an upper limit on the number marks we would deduct for bad style.
2:16:21
And normally with that might be two or three marks.
2:16:28
You know, if if you got just hopelessly bad variable names you lay out all over the place, your code shot over 80 characters and every other line.
2:16:34
You've used first and second, is that a pattern matching you've had intel everywhere, if it's an absolute mire of junk, then?
2:16:43
You know, you might only get half marked and to be questioned, even though you passed all the tests, I don't know.
2:16:50
It depends on on the parking scheme.
2:16:54
But if you do pass all the tests, that's fabulous, well done, but then to try and spend a little bit time at the end of the room trying,
2:16:58
trying to do the sort of tidying up on playing with here and looking at your variable names and looking for consistency and tidying up your layout.
2:17:05
And that's that's important. Russia is an old hand.
2:17:14
So just to confirm our memorisation and constant propagation, the latter one is more relevant to our test.
2:17:21
Well, why don't I just tell you what to do with questions? No, I'm sorry.
2:17:28
I mean, were less relevant. I mean, I think if you if you if you do one or either or both of those, that's good practise, I would say.
2:17:32
OK and quickly go with the for each part. Why do you have two cats?
2:17:43
Can you just go with the last one of the? Well, yeah, I mean, it's one of those things where you start.
2:17:48
My experience of having is over lunchtime as I started writing it, and I'm glad I've done this before, of course.
2:17:53
And I did it last year as well, and it was kind of in my. So I kind of know what's coming.
2:17:59
So ugly head start on you, people. But the argument is what I was doing there when I was doing it, when I was, I was using the types.
2:18:04
I think, OK, every time I call this function, I get back a list of Exynos, and that's in some sense.
2:18:13
The beautiful thing about types is that you almost you can almost forget what the function is doing.
2:18:18
Sometimes you just know, I say, I've got to do this to every child. Yeah, that's the first point.
2:18:23
OK, I've got to do that. To every child and then you start, you write that line of code in there,
2:18:28
but you might start with a map and then you think, Well, okay, what do I want to get?
2:18:34
I want to get back a list of symbols, so why not having sort of what was what was the what was the message on of code?
2:18:39
Was this one here, wasn't it? Yeah. So right.
2:18:44
So what did I say? Every time I call that function, I get back a list of medals.
2:18:48
So assuming I'm doing the right thing, I'm I'm I'm pushing the percussion correctly, this is this is tricky,
2:18:55
but you're going to get these arguments well, and I'm pushing the percussion into the children, so each call to expand gives me a list of examples.
2:19:01
All right. So I've got in my so I've got just that alone, gives me a list of examples.
2:19:10
So each quarter that gives me that's tobacco smoke. So why don't I do a map? I've got a list of list of examples.
2:19:18
All right. So I don't want to list a list of symbols, I want a list of symbols so I can catch it.
2:19:24
So now I'm back to a list of examples, and then I remember the fact that I'm sitting inside a list comprehension.
2:19:30
So I'm generating a list of symbols buried, which is that is a list of symbols for each.
2:19:37
And therefore, I've got a list of expects to exit polls again, and that kind of gives you a clue.
2:19:43
The way I need to do outside is to conquer it. It's horrible, isn't it?
2:19:48
It's really very, very hard.
2:19:51
And this is absolutely perfect because I walk around the room watching students trying to get this last little bit to work.
2:19:52
And if I could just see general like write a contract, write a contract, writing conquer and only wants to be responsible.
2:19:57
So it's not so much your face. Like I said to you this morning, I used the tapes to help you.
2:20:05
I guess the other thing question that you got is, why is this the right argument? Yeah.
2:20:14
Yeah. Clearly, you've got to reverse into the children because because what you do or what you think about you,
2:20:18
actually all you're doing is walking through the Excel template,
2:20:22
leaving behind a trail of smell until you get to one of the value of awful riches and then you've got to do some work.
2:20:26
So so this this rule here is leaving behind the trail of this is the templating bit.
2:20:32
Yeah. And this one is fortunately fairly straightforward, the value of it's this one is this is the really nasty one.
2:20:38
So so why have you got to guess, which is because the is picked, as I said, intuitively, the X path.
2:20:45
So this contact is is is the data source if you like.
2:20:54
It's the it's the data source is an excellent old document.
2:20:58
And what the pope is doing is is leaping you through that to find the thing you're actually interested in.
2:21:01
I don't want the film. I don't want the I don't want the composer of the film.
2:21:06
I want the name of the film. So you're jumping through to find the attribute you're interested in, which is what's happening here.
2:21:11
So what's so funny? This is why I'm looking at the violence here.
2:21:17
So the airlines have already been accessed through the expo. So I said, OK, we'll just carry on having having jumped,
2:21:24
having used the export to jump to the thing I'm interested in just carry on walking through the XFL, starting with this new context,
2:21:30
this this new context,
2:21:40
which is the result of the Xbox thing and then the rest of it is is just mopping up the types to make sure you get back the right type of object.
2:21:41
Hetty is that's an old hand on your hand. All times.
2:21:53
Okay. Okay, I have an appointment in half an hour and I need to go.
2:22:00
So is there any final questions? I think it's really I think this.
2:22:03
To me, I can I can remember when we set the tests that, you know, I would say, I would say the one about the.
2:22:14
OK, because I think, you know, I get people that help me when I'm doing these things and the times we sat for staring at it thinking,
2:22:22
you know, have we got this right? One with one was the. The process, the process will tell me to think what what it was called the final state,
2:22:30
not the final, not not not the regular expressions that was actually fine. The one to do with them.
2:22:38
What was it it was able to say, wasn't it legal transition system to this school that was really, really hard?
2:22:45
And I remember this one being really, really hard as well.
2:22:51
You know, what would you be to try to produce a specimen solution which is as good as we can get it?
2:22:56
You know, I remember we spent a lot of time. I spent a lot of time trying to tidy this up.
2:23:01
So you could ask one question, please. Yeah. What we're doing on Wednesday, is it anywhere near this?
2:23:08
In terms of difficulty. Yes. No, no, no.
2:23:18
I would say one thing I would say is it's going to be I think it's much clearer what you have to do,
2:23:22
whereas with this exercise, you've got to get your head around this exercise. I will tell you thing, which is very hard to understand.
2:23:29
You know, I think the speaker is well, is well worth it.
2:23:35
The spec is very clear, but it's a question of if you have four hours or five hours, it would be a much easier test.
2:23:38
This one, the one on Wednesday, is it's much clearer what you've got to do.
2:23:43
You can see it more easily. But there's a little bit less hand-holding at the at the end, at the very end.
2:23:48
So don't worry, it'll be fine. I promise you, I promise you, is much easier to see what you should be.
2:23:59
You know, when I when I go back in, you know, I was looking at this thing over lunch time with what, as you said, I was staring at this thing.
2:24:10
What the [INAUDIBLE] am I supposed to put in here now? Oh yes, it's the yeah, it's it's really very tricky.
2:24:15
And I've done this exercise before, and you haven't. Anyway, so I'm going to have to stop.
2:24:21
It's lovely to see you, thank you for coming. And I'll be with you tomorrow at nine for the polymorphic type inference thing,
2:24:28
and I will probably have to leave before the end, but I will be there for most of it.
2:24:35
So have a nice evening. Julia. Thanks.
2:24:39
Thank.
2:24:52