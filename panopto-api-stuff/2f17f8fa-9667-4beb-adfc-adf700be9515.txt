ID: 2f17f8fa-9667-4beb-adfc-adf700be9515
Title: Final Kotlin Lecture (livestream) - Tues 7th Dec
Category: Week4
Lecturer: Robert Chatley
Date: 07/12/2021
OK. Good morning, everyone, and welcome to what's going to be the last session of the coaching course in this term.
0:17
What I'd like to do today is kind of close off a few things, present a little bit more content to show you a few more topics,
0:25
a few more things, some things that are relevant to the exercise that you were doing this week if you are taking part in the porn race.
0:32
That's an optional exercise, but I think it's quite fun to try out a different style of application.
0:39
So hopefully you're having a go at that, at least to some extent.
0:43
We're going to talk up a few more language features, some which might be a bit more of a recap,
0:47
some of which are kind of pushing forward towards things that will be useful to you when we make a transition to Java next term.
0:53
What we're going to do is say this will be the last session of Coquelin.
1:01
We've got some pre-recorded videos that we're preparing and we'll make that transition kind of mapping a lot of
1:05
the kottmann stuff into Java so that you'll be ready for starting with Alistair at the beginning of next term.
1:12
We think the best thing is probably to release these just about around about the beginning of the next term.
1:20
So you've got this term to kind of put together everything that you've learnt about.
1:26
Haskell and Coquelin have a bit of a break over Christmas. Let that kind of coalesce in your mind.
1:31
I think you've got a Haskell test when you come back and then there'll be a chance to just make this.
1:36
Hopefully what's quite an easy syntactic mapping. A lot of the same concepts are going to be used between Kotlin and Java.
1:42
We've tried to line up the course so that it makes for a smooth transition.
1:49
So hopefully that will be easy.
1:54
And then you'll be ready to do more on object oriented design and data structures and concurrency, starting with Alistair in January.
1:56
So I made a few notes of a few things that I wanted to talk about today.
2:06
I've got a few examples to show you, but as always, if people have got questions or things that they'd like to dig into it,
2:11
feel free to just shout out open hand up or write something in the chat,
2:18
and I'll try to monitor those and come back to your questions as we go through the session.
2:22
So to start off with, I wanted to talk a little bit about doing inputs and outputs.
2:32
This was partly triggered by having a look at some of the code that was in the skeleton for the opponents exercise.
2:38
So I noticed that that makes some use of inputs and outputs.
2:44
And also, there's a link here into the way that we do things in Java and some of the kind of cross compatibility between the languages.
2:49
So you'll see they're actually going to use some Java code in order to do inputs in Scotland.
2:59
And that's totally fine. Like that, languages are designed to be compatible.
3:05
And so we actually start to make this transition and this bridge already in this course in this part of the course.
3:09
So.
3:16
You've been used to printing things out in court, and this is kind of one of the very basic things that we do and we've been using this print line.
3:20
And actually, maybe I'll just do some examples in the code. Here we go.
3:28
So obviously, something that we can do is just to.
3:31
Printer simple string and you've been doing this all the time. If you have been writing Java before, which I know some people in the US have,
3:39
and they were thinking, Oh, right, well, we're normally they're used to doing a system out of print.
3:47
I think this is the way that you would do it in Java.
3:52
There's the interesting connexion is that if I look at how print line is implemented and I want to do that on my Mac,
3:54
I'm going to hold down command and click on something.
4:01
If you're running on Windows or Linux, I think you can hold control and click on something to go to its definition if we click through.
4:04
We can see that this is actually implemented as a call to system out dot print line,
4:12
which is a bit of Java code that this is calling the standard Java Library.
4:18
And so if you've written Java before it, that's a very familiar call, and that's actually what happens when you call print line.
4:22
It's just that this is wrapped up in something of a more convenient method, so you don't have to write system out on the beginning of everything.
4:29
But it's actually fine to write systemctl out. Dot print line here.
4:38
And that will run. I can run this code here.
4:48
By Computable warm up in the morning. Here we go, so we can run that, and it does the both of these lines equally well.
5:00
It's just that you get this warning here that says actually there would be a more idiomatic Kottayam way to do this,
5:10
which is just to reduce print line on its own without the call to system to out-of-print line.
5:16
But you can see that under the hood, it's calling three to this soap more idiomatic in a copy of pure cotton in Congress to do this.
5:22
But if we wanted to do this, that's actually what's happening under the hood.
5:31
So it's fine to do that as well. Maybe we should investigate a little bit, though, what some of these things are,
5:34
because now we've got a system out and that's an object on which we're calling print line.
5:41
So let's see what the type of this is. And so what I'm going to do is make a variable for this thing.
5:48
And if I ask it to show me the tape explicitly and it says this thing here is a thing called a print stream,
5:57
and so a print stream is a cost on the cost from the Java Standard Library.
6:05
And you can see that if I have an out of a type print screen, then I get various methods I can call,
6:11
including print line for various types and print for various types of print line prints, for thing, and then puts a new line.
6:18
And then print prints. It doesn't put a new line. And then we've got just basically lots of different options of that,
6:27
and then we've got a few more detailed ones for doing particular formatting, which you can investigate if you want.
6:34
So that's as I say, most of the time, you wouldn't need to use that, but in some cases, and I think you see this if you're looking at the porn race,
6:45
it's useful to be able to use the stream so that we can send out to different places so that,
6:53
for example, we don't always want to write to the console. We might want to write into a file or something like this.
7:00
When we're doing input, we might want to read from the console, but we also might want to read from a file or a URL or anything like this.
7:06
So having these pieces that we can put together allows us to set up input output to various different destinations.
7:14
And so here we've got this print stream, which is a stream that when you print it,
7:22
it prints two systems out, which is going to be what comes out on the console.
7:27
Something else you'll see, which I think is done in the lab exercise, is that there's a thing called a print writer.
7:33
And if I remember correctly, what they do is they wrap it around, system out.
7:45
This is the right writer. And the writer basically has a very similar functionality, but it's designed to work with characters rather than bytes,
7:51
so if you've got a particular character in coatings, then that tends to work slightly better.
8:02
But in general, when we're just writing to the console, I think system about using the print string directly, it's generally fine.
8:08
But in some cases you might see the writer. And I think you'll see the writer in the skeleton of the lab exercise.
8:16
So if you do see that there, that's what's going on there. So hopefully printing an output is fairly straightforward.
8:22
I think what's interesting to look at, maybe is inputs because I think you may also be doing input in the lab exercise,
8:32
and that's slightly more interesting because we have to read from a very a source of input and process
8:40
that in a way that allows us to take out input from the outside world and include it in our programme.
8:48
So there's a couple of sort of plots to write about complementary classes that.
8:57
Allow us to do this. So where we had a print line, which was system out of print line.
9:05
I mean, let's put that pack. In Java, there's an equivalent or complementary thing, which would be a system in which is input stream.
9:11
So we had an output stream or a print stream for writing out data into our, you know, outside devices.
9:25
But now we've got an input stream that allows us to read from those outputs or outside sources into our programme.
9:33
The only thing that when we use it in Koechlin is that because this is a Java class and its Java class has a fit.
9:39
So the system is a class and it has a kind of public property built in, which is a feat which is an input stream in in court.
9:46
Then it's a keyword because we can use it for checking types.
9:54
I know sorry for checking set membership, not for certain types.
9:59
So you can say if a is in the set and we also used it, I think, in some loop definitions.
10:02
And so we can't use this as the name of a particular property.
10:09
And so if we start to use it, then you can see that column will actually take the name of in with these BANKEX.
10:13
I think that's a slightly unfortunate piece of the design. It looks slightly odd when you use this thing.
10:20
But mainly the time most of the time you don't need to think about it.
10:26
And you know, Scotland will just put the intelligent will put these tactics in for you.
10:29
If you were writing your code in Scotland in a text editor, then you have to remember to put these tactics in yourself.
10:35
But in general, I think hopefully you found that the smoothest way to write and work with Scotland is to use
10:42
the chat brain tool so intelligently because they built the language and the tool together.
10:48
So hopefully when you use that, it's relatively seamless. And if you make one of these, this is an input stream, that's the type.
10:53
Senator. And when we have an input stream.
11:06
What we can do is we can read things from it. But typically, input stream is quite a low level thing, so it only really allows us to read bytes.
11:14
You can see that when we read, we get an email back from it, even if it was a character or a piece of the text.
11:25
Just be reading one bite at a time. And then so that's actually quite well, irritating to work with,
11:31
and it's nice to be able to use some other classes to help us to abstract away from that and then to build up something that gives us a nice API.
11:42
So you often see a combination of classes used together when we do inputs, which allow us to read in a nice way.
11:50
So I'll show you some of those. So this one at the moment is an input stream.
11:58
So around an input stream, we might have an input stream reader, which again is another Java Io class.
12:05
But this is in the variable. So now we've got the reader. We've got slightly different methods.
12:16
Not really quite yet, something that's the sort of level of abstraction that I'd like,
12:29
I kind of like to read a line of text at the same all at once because I might want to process,
12:34
say, the whole lying that someone's typed in or a line from a file or something like that.
12:40
So typically, the way that we solve this is to use a buffet reader.
12:46
And the thing is, I love you to kind of learn about it says a lot.
12:51
But the thing is. OK, wasn't quite so is to use a buffet reader.
12:58
And to wrap that around this reader, I mean, we've got a buffet reader.
13:08
Then we start to get. Things like Red Line.
13:15
So it's what you'll see is. So this should give us a string.
13:20
I'm sorry. This will be a line.
13:26
It should be a string. And what you'll typically see is that it's configured so that we don't have this.
13:34
And this is in line in here,
13:46
so you'll see this kind of rapid construction where you say make a buffet reader from an input screen reader from an infantry man,
13:49
in this case, let's put this one inside. This is going to be system.
13:58
And again, I think just to pick up on a message in the chat,
14:02
the reason we have the tactics is that if we don't have the tactics, it's going to complain that this is a keyword.
14:05
And this is a key we use in various different places in Scotland.
14:13
So you can't write in here like this.
14:18
So to convert it into an identifier, they gave this back take escaped name, which is a valid identifier in Scotland.
14:20
We've been using that for tests naming. There's not very many places that you would use that you might need to use it in a couple of places.
14:27
But typically, if you see it, that's all that is doing. It's just escaping the night to make it fit in the context.
14:36
So you might see quite commonly, especially when you move into Java and you start doing it in Java, like this kind of construction,
14:44
wrapping the buffet reader around the input stream reader around system in and then that gives us the buffet reader.
14:51
And when we read a line from it, the perfect read is going to read something from the input string reader.
14:57
The input string read is going to read from systemd or in an at each level.
15:02
It's going to use kind of a lower level of audio,
15:06
but we don't have to worry about that from this point because the API now that we've got, it's just like,
15:08
read a whole line so we can actually write a little programme that does something to read from the console so we can say, please type something in.
15:13
And then here we're going to read a line and then we can say. You Typekit.
15:26
The line. How about something like that, so let's just try running this one and see what happens?
15:38
So then a print line is going to print out here, and I can just click here and then I can write.
15:51
Something like this and then enter that it's going to when I enter,
16:03
that's going to trigger it to be read into the programme and I'm going to pull it out inside
16:07
the programme that we just treat it as a regular variable and we printed it back out again.
16:11
So that allows us to do interaction between the user and the programme so that we can actually
16:15
enter things in not only as command line arguments that I check in the pre-recorded video,
16:21
but actually interactively as we're running the programme. The other thing we might want to do is to read from a file.
16:26
And so if I've got a file here, I've got a file here, so we could actually read a line from a file instead by changing this from system to in.
16:38
To being a different kind of input stream that's associated with the file,
16:49
so I could actually make a final input stream here and the file input stream as the parameter takes the name of the file of my file is court test.
16:53
But, Steve. And then we could have.
17:03
Something like this, and if I open this file up, you see, it's just got the list of some programming languages in it.
17:09
And then if I run this, hopefully it's going to pick.
17:19
The first line out of the file and then processed so we can use that, you know, we could read another line.
17:25
We basically using exactly the same construction here and the same construction here.
17:31
But what we're changing is just how to construct that input stream, which is going to give us that source of bytes.
17:35
So it's kind of read from the file in this case, and we could do similar things to read from a URL, from the network, from lots of other sources.
17:41
Just checking the chart, and yeah, that seems I think people have got that got things figured out that.
18:02
So hopefully that's relatively straightforward, there's a little bit of boilerplate, especially with the inputs, just to put those classes together.
18:11
But it's a relatively flexible framework. And as I say, particularly when you get over into Java land, you'll see these things quite commonly.
18:18
What we've tried to do is to wrap them up into another object that encapsulates, you know, inputs.
18:27
So I might write a class called keyboard inputs and then have it do all of this stuff.
18:33
And then I can say to keep what you put, please give me the next line and then maybe that will do it for me.
18:38
That's just. All right, let's just recap the print writer. So we had.
18:46
So we did system out. Trend line of something like this.
18:55
And then so the type of this thing here is print stream.
19:02
And most of the time, this is absolutely fine. You can see that the API of print stream.
19:11
Takes everything here and writes out basically what he writes, as is a series of bites into the file, onto the console, something like this.
19:22
If you want to have a bit more flexibility because you're using output, for example,
19:33
in a particular character set like you want to specify that this is UTF eight, UTF 16 or something like this, you can't do that on the bite level.
19:38
But if you wanted to do that, you could use the print writer and so you could wrap your print rights around the print screen.
19:47
Can't remember if it takes a second and it takes a few more options.
19:58
Oh yeah, here we go. Oh, sorry. Down here,
20:02
we can specify what type things like the character sets here we want to print into a file with a characters that
20:08
can talk about automatically flushing the output stream if we want to to make sure that it's not buffering.
20:15
So there's just a little bit more option and control with the print, right?
20:21
But I would say, if you're just doing basic things like you're just going to write into the onto
20:25
the console because you're doing some debugging or using simple Io with the user,
20:31
I would just use the print stream directly, and I think that's absolutely fine.
20:36
That's a question of saying, what was the problem with input stream reader? There's no problem with input stream reader.
20:42
Apart from the fact that if we use the input stream reader on its own.
20:47
Then the options that I get, I can read like just one particular character.
20:55
And really, what I'd like to be able to do is to be able to read a line at a time and say what the buffet reader does is when you ask it to read,
21:01
it's going to kind of read ahead, get a whole line.
21:08
And that means that when I can use the API, a faithful reader, I get a few more options that are a little bit nicer to you.
21:11
So I can say, you know, get me this line. We can actually get a whole stream of lines, which is maybe something that you could experiment with.
21:18
So it just gives me a bit more higher level like API to stop me having to write some of that code myself.
21:25
Let's take a look at something else, and then we'll come back and look at a little bit more, I hope once we've gone on to the next part.
21:35
Oh, yeah. Maybe I was going to show you about SCANA, wasn't I? Yeah.
21:49
Let's quickly look at scanner, so scanners, another way of doing input so I can make a scanner.
21:57
Again, this is another class from the Java Standard Library, but we can just incorporate it into our copying programme.
22:04
And then when we construct one of these, we can see that we can pass in lots of possible things.
22:10
One of the things is an input strain. So again, let's put system in as our input stream into our scanner.
22:15
And the idea of the scanner is, again, it's a little bit of a higher level abstraction, gives us a little bit nicer set of methods to work with.
22:25
And what you can say with the scanner is here's a stream of inputs. I'd like you to scan it for tokens.
22:33
So, for example, words or numbers. And then I want to ask you, OK, give me the next word.
22:39
Give me the next word. Give me the next word. And it will actually break up the input into successive words.
22:44
So let's let's get rid of some of this.
22:49
So that we can say scanning the dots next.
23:08
And maybe let's just print that. So I need to type something here, so.
23:13
So you see there that it did this slightly, but not out of order because I printed this.
23:46
If I wanted it to pause, I could have read this in fast. Maybe we should have done that.
23:53
Something like this that's just from once again the way.
24:02
They are so basically first then it's going to at this point, it's going to read in the first words, then it's going to read in the second words.
24:14
And so every time we want to extract a word from the input, then we can cause cancer dot next.
24:21
We can also say, like we can say next.
24:27
Boolean, we can say next inside. I think we can say next, it's coming.
24:35
Next, double next. So we can actually get it to convert, and that will witness an event rather than a string, so we're not always working in strings.
24:41
If we do this, it will find the next number in the thing and give us as a number.
24:49
So that gives us again a little bit more abstraction, a little bit more power,
24:55
a little bit less code that we have to write and more relying on code that's written by the library users.
24:59
But just another little piece that's useful in your toolbox of input processing.
25:04
So the other thing I thought we should touch on, just as a kind of basic mechanics thing we don't need to spend long on,
25:16
this is something that we've looked at briefly, which I think in other programming courses we would spend more time on.
25:22
But I know that a lot of you have done a little bit of programming before or some people,
25:28
a lot of programming so that you're kind of familiar with these things.
25:32
And we've come from this Haskell mindset of processing collections with higher order functions.
25:35
When we write a lot more imperative code, like in some cases, it's going to be useful to use a loop.
25:41
And we've used for loops, for example, with the string builder to build up things in the two string methods.
25:47
And I just wanted to show you a few different variations on the leaps that we have in Scotland.
25:53
Again, as you move into other languages, you'll see these.
25:58
They're useful in some cases, but don't forget that we can do a lot with mapping a function over a list.
26:00
This kind of thing that gives us a lot of power and often a lot more concise code, so I wouldn't drop into writing loops for everything.
26:08
Try to remember the Haskell mindset, but where we want to use them, there's a few different variations that can be useful.
26:15
Or if you see them, you know you want to know what's going on with those. So we've seen the simple follow up,
26:22
I think we said we did for a particular element in a collection and then we could iterate through all the things in a collection.
26:29
If you want to go through a set of numbers, then there's a few different variations we can have here.
26:36
You've got the first one, which is simply with a range which is from zero to 10,
26:42
and it's going to go a step through every line from zero to 10 printouts out.
26:48
So in this case, I think that is an inclusive. So it's going to go, it's going to be 11 times if you want to be exclusive.
26:53
So you want to go from zero up until nine. You can either write 0.49 or you can say zero until 10, then it's going to go that way around.
27:01
Is that the right way? Perhaps I should explain that the wrong way round. Let's check it.
27:12
I don't actually write the lipstick or not leaps in this style that often, so I think it's useful for us to check.
27:20
So let's do four I one dot dot five.
27:25
Let's see whether this is inclusive or exclusive. OK, so this one's inclusive, it's going to print one and five.
27:35
And if we get one until five. Then we should get one, two, three and four.
27:47
If we wanted to not do every single one, but we wanted to step up in, for example, in two years, we could do that.
27:57
So they've got one, three, five, seven and nine. And if we wanted to go.
28:09
Down there, we can do that 10 until one step minus two.
28:15
Now, how do you do that in this light? They may have actually forgotten how to do that in Got.
28:24
Let's. Find a browser window and check it.
28:41
Down to. They are so you see people we work in different programming languages, I've been writing lots of Java this term and some Python yesterday.
29:14
And so it's easy for us to forget, you know, the exact details, but quick cross reference,
29:38
often with a Stack Overflow post or some documentation, as long as we've got the principle of what we want to do in our mind.
29:44
We know that this should be possible, easy to find the syntax and to get back on track.
29:49
And I think that's just part of what our programmer does most of the time.
29:53
We know how we want to solve the problem, but we can't always remember exactly the syntax of doing it in that particular language.
29:57
We're working in that day and I would say modern projects often have lots of different languages going on in different places.
30:03
So often we have to look things up, and I think that's nothing, you know, it's just a normal part of our work.
30:11
So learning how to reference things quickly find the thing you're looking for matter against your understanding.
30:16
It's a good thing to do, especially when we don't remember or things that we don't do that often.
30:22
So this is the down to. And then let's see if we do a step. Does the step go?
30:27
It's this test positive or two step negative. It's a positive step.
30:34
OK. That's going to give us the difference between them.
30:42
There we go, so that shows you these variations on the Phillips.
30:51
The other ones that we haven't seen, but may be familiar to you if you programmed a lot in other languages, are these wild leaps.
30:57
They work a little bit differently. So they're going to say while a certain condition is true, do this block.
31:03
And so then what we'd expect is that something in the body of the block makes some mutation to one of
31:11
those things that's in the condition so that at some point it becomes false and then we exit the loop.
31:18
So one of the things we would want here is that there is some possibility of the body of the loop making a change to the state.
31:23
That means that the condition sometimes becomes false. Otherwise, we're going to leave forever.
31:31
Then we've got another variation on this, which is do while she's like,
31:37
do this thing and then check at the end whether or not the condition is true and if the condition is true, do it again.
31:41
And so the main difference between these two is in the top construction.
31:48
If the condition is false, never do either block,
31:52
whereas in the bottom is like we always do the block at least once because we're going to do the block first and then check the condition.
31:55
Whereas in the first construction, we check the condition first and then do the block.
32:03
So if you want it to run at least once,
32:07
maybe the second case is good if you want to check and maybe do it zero times, depending on what your condition is.
32:09
Then the top construction, I would say, possibly a little bit more common after top construction.
32:16
That might be what you want. There are a couple of things.
32:22
Does that mean that I don't?
32:25
But I do prefer a follow up to a wildly if possible, it's not always possible because they are applicable in different situations.
32:29
But the thing that's nice about the fully. I have another one here, and I do.
32:37
Again. This eye is not in scope here.
32:47
There's no I. I can't do this because this I.
32:51
Is defined within the body and only for the body if they sleep.
33:00
And then this is a new eye that's just for the body of they sleep.
33:05
And so that means that we have a kind of extra scoping that's introduced by the loop construction and its block body.
33:10
And that means that we can reuse AI as our deep therapy for lots of different loops,
33:18
and they can never interfere with each other because they are limited local to that loop different definition.
33:23
So that's a nice property,
33:30
and I think that that means that you can know that nothing else is going to be affecting your eye because it's defined only in this place.
33:31
That's not really true for a while, deep so natural. If we write something that says, you know, while X is less than six.
33:39
Point nine x, and then let's do something to update x x x x plus one, we need to define X,
33:51
but we can't have X as something that's local here but need to have it defined here.
34:01
Let's start with one and then oh, actually,
34:10
now we need to have something that is over because I want to do some updates to it, so let's change it to being a final.
34:13
Intelligence just suggesting here that I might like to do a plus equals, I think.
34:22
So this is just a convenient shorthand for doing X equals X plus one I can do X Plus equals one.
34:27
And then I can run this programme, and hopefully it does what you would expect it's going to say start with one go through,
34:34
is it less than six yesterday's do body and one on to keep going, keep going.
34:41
And when it's just not less than six, i.e. it's six, then it doesn't print the body, so it doesn't print six.
34:45
But the thing that I don't like is that now we have the X is in scope here.
34:53
So it's fine for me to work on this X here and if I have another leap. Down here.
34:59
This is the same acts as above,
35:06
so anything that I do up here can affect this sleep because it's using the same X and XS Avar so we can update the state.
35:08
So where a follow up is quite limiting and gives us a local block in order to say this is where these variables are defined with the leap.
35:17
That's not the case.
35:27
And in fact, it has to be that any variables is defined before and is modifiable otherwise that the model while it isn't really going to do its job.
35:28
So I would say if you have a choice, try it towards the forelimbs because they tend to be more localising,
35:38
easier to reason about the way you do need to do it while. This is obviously one option.
35:45
And then the other one we had was just to switch this around to say do. And while.
35:52
And then if I print that one instead. And we can see that you get the same kind of repetition, but we're just doing the check at the end.
36:00
So nothing, I don't think very complicated that just a few useful pieces to know.
36:19
And I'll just quickly show you the combination of the loops with the input that we saw earlier, because you might want to say,
36:23
continue reading from the, you know, from what the user types in until we get a certain value that says we want to stop.
36:30
Or you might want to say, continue reading from this file until we get to the bottom.
36:39
That would be very common. So in that case, using something like a wildtype works pretty well.
36:43
So let's do let's read from the file and read all the lines until we get to the end.
36:51
So we had what did we do? We had a buffet reader.
36:56
Around an input stream, reader. Around a file input stream for the file.
37:01
Just a text. And then we can say that we have a line on line because Buffett read it out, read line.
37:09
And then we can say. While.
37:27
The line is not equal to no.
37:33
And so what would happen would be when we get to the end of the file and there's no more lines to read, then he's going to return us now.
37:37
Then we want to let sprinkling some symbols at the beginning and then the line.
37:47
And then do this again, so I'm going to read another line from the reader.
37:57
Hopefully, that [INAUDIBLE] that's exploded boys hearts. Because I've misspelled the name of my father's court test or text, not text or text.
38:09
OK, here we go. So that's printing out, do we get all the lines in the file?
38:24
One, two, three, four, five six.
38:30
Yes, so we got that and then when we got to the end at redline, whether for 10 now and then, we will have used that as a control signal to say stop.
38:31
We could also do something with the scanner, so we could say, OK, let's make a scanner around system time and.
38:41
And then we could say, what could we say while?
38:59
But maybe we should do the same thing a our token, because scanner dot next.
39:05
And then we could have a special token that we defined that says this is the end, so we could say, well, the token is not equal to you and.
39:14
Then we could print. You typed.
39:26
Token and then we could do token. Equals.
39:34
Scanners on next. And then we can take.
39:40
And then it finishes, maybe we should have printed.
40:15
Something like this, so that just shows you the combination of the scanner for getting input or the red line for getting input,
40:46
either from the console or from the file, together with the loops and how you can use those control signals to determine that.
40:53
So again, hopefully nothing to fantastically complicated that, but just something to add to your toolbox.
41:00
So you know how to put those pieces together. And we saw that, you know, when you forget something to go and just check the documentation,
41:06
find the syntax where you want to do and when you move to a new language like you move to Java and you want to do a descending Faleke,
41:12
that syntax is going to be slightly different. You can just quickly look that up.
41:19
Know that that thing is possible. And then just map it in. And hopefully it's an easy translation that.
41:23
OK. Yeah. Let me show you one more thing before we take a break.
41:32
This one did. So this one's a little bit more sophisticated, but I don't think difficult, and this is the idea of generics,
41:41
which is something that we going use when we creating our types or using types in coddling or in Java to specify parametric polymorphism.
41:55
So this is something that you've seen already in Haskell that you can make a list of a particular type or you can make a.
42:04
You can make a function that specified for a particular type, or you can make a collection or a data type of your own.
42:11
That's parameterised over types. And we've actually used lots of examples of this in Scotland already, so we've made.
42:17
Examples of a function that is the list of strings.
42:27
So you have these angled brackets to say that this long this list is specialised or
42:31
franchised by the type string so that when we put something into it has to be a string.
42:36
When we get something out of it, we know it's going to be a string.
42:40
But if we make a list of it or a list of URL or something like this, it's always going to match up those types.
42:43
And so list is defined as a type that's parameter sizeable by another type that gives us this possibility.
42:51
Same for PR. We want to know how to do this for our own types.
42:58
And so the mechanism that we use for this typically known as generics.
43:02
And basically, it's everything that's involved with these angle brackets that allow it to specify a different type here.
43:08
So we know how to use a generic type from the Standard Library because we can just
43:15
say list and go bracket string and hopefully people become familiar with that,
43:21
and that's just a kind of natural thing to do. What about if we want to define our own type and allow it to be parameterised with another type?
43:25
We would like to build our own cost. That's a collection type or something else that would be benefit from being parameterised by a type.
43:33
So in that case, we need to introduce type parameters. And the way that we do that is when we make our cost definition, we add at the beginning here.
43:44
After the name of it, we say, Ah, this is a class which can be parameterised with a type.
43:55
I'm going to call that Typekit. We can use any name for this type parameter, but it is idiomatic or typical.
44:01
If you've only got one type parameter in your class to call it T,
44:10
and if we've got more than one type parameter, it's we'll see a little bit later in examples.
44:14
Sometimes people go T and you.
44:18
But then when we were doing maps and we've got a map is a type that specifies two type parameters, one for the keys, one for the values.
44:21
In that case, it tends to be K and V, and sometimes with collection types.
44:29
People use E for element types so you can use what you want.
44:34
Typically, people use single letters for these rather than longer names, and that helps us to recognise them as type parameters.
44:38
The compiler is going to recognise it as a typewriter anyway, but as a reader and as a programmer, as the Azari,
44:45
as a reader of the programme, it feels more natural to me, and I think more common makes it more understandable.
44:51
If these are single letters, and I say t would probably be the most common one if you were just going to have one type.
44:57
So here we say this is a Class A, which is parameterised generic on type T, and it has a constructor which constructs a private property,
45:04
private file property, which is called lowercase T, and its type is the type uppercase T.
45:15
So whatever we specify, if we make an array of strings, this will be string.
45:22
But if we make an array of Int, this will be it. And so this is not known at compile time or at least not known at the time of our class,
45:27
but it's known when we write our programme because we are going to make somewhere else.
45:35
We're going to make an a of T or we might passing it when I can a and passing a string here.
45:38
And when we pass in a string, it's going to say, Oh, that string is tight string.
45:45
So therefore Ti must be string and it's going to make string everywhere that we have T.
45:49
So basically we can have T here to define what the type parameter we can have t here as the type of a parameter to a function or to a constructor.
45:54
We can have T is the type of a property and we can also have the T as a return type of a function.
46:04
So here I have a function which is located. And it returns a T for whatever T is in this case.
46:10
So hopefully that's not too complicated. I'll show you an example just in the code, just to put this together.
46:19
Yeah, let's define our own path. That seems a good way to do this.
46:28
So in this case, I'm just going to define a new class, actually, let's make a main fast.
46:38
So I'd like to make a pair, which is like our pair.
46:43
And it's going to be a pair of, well, let's just put a pair of jeans just to start with.
46:48
So we'd like to define this class to be kind of the equivalent to what this built-in pair is,
46:53
just to see how one would go about building one of those. So obviously, we need a class.
46:58
How a pair. And then it's going to have two properties, which we're going to initialise in the constructor.
47:02
The let's say one at the moment, we could say that this is a private.
47:09
Now what you want to call it f and ask for first and second, maybe first, maybe even to this at the moment we could.
47:14
Let's just fill in the line. This. So I could say that these are not.
47:26
And that would make this could work. But now if I want another part. There has two strings in it.
47:36
Then it doesn't work because I've said these have to be ins,
47:48
so actually what would be good would be able to say that this is a part of a certain type T and that both of these have the Typekit.
47:50
So in that case, and put the T here to say this is introducing a typewriter, and I put the T here and I put the T here.
47:58
And then they should all line up and the type inference engine inside the compiler says, OK, for P2,
48:08
you passed in a string for a string sorry string four f and a string for s so that 40 of B string.
48:14
And so this key string overall and in fact, if we put in the type explicitly here, you'll see this is how a pair of string.
48:22
This one is an ALP have it. So that's good.
48:32
But if we want to. Let's prints.
48:36
He. So then at the moment,
48:43
the problem that we recognise is something we've done lots of times now is
48:52
that it's not going to bring nicely because we don't have a nice two string, so let's define a two string.
48:55
So I'm going to override fun to string returns, a string, always a string doesn't depend on T.
49:04
And what are we going to have, are we going to have it's going to be brackets and well, let's do it with a plus to start with.
49:11
So here I've got an F.
49:19
But I can still call history on it because actually, whatever it was, it would have a strain because all objects have a new strength.
49:23
So I don't need to know what type T. is. It's always going to have a two string here.
49:29
Then I can have a comma and I can be asked to string. And then.
49:36
It's the practise. So that will print nicely like this.
49:47
I could convert that into a string template. Let me do that automatically.
49:59
Maybe I'll just leave it, I could do that as a string template instead. The other thing we might want to do is not to print only P., but to print.
50:06
Peter, first and second. And in which case I could have.
50:18
A function first, and that's going to add sanity.
50:31
And in fact, that's just going to be half. And I could do the same for second.
50:37
So this is fine.
50:45
There's just one more variation that I might want, which is that all the pairs that I have to find here first and second have to be the same type.
50:48
So it has to be a pair of integers or a pair of strings.
50:56
What about if I wanted a pair where the first heart element is a string and the second half is an integer or type?
50:59
Signature doesn't allow for that at the moment. So if I did and pick three.
51:06
Which is. It's just it's our power of trying to and if.
51:16
OK, so this is allowed because he's going to say this is a pair of anything.
51:26
But actually, what I'd like to be able to say is that then I'd like to say, actually, it's a pair of integer and string, so I can say that.
51:33
I change this, so this is T. And you so I'm going to introduce to tight parameters here and then the second type is going to be you.
51:47
And this is all fine. And then this one becomes you as well.
51:57
So then. This one is intense.
52:02
This one is string string. And then this one is in string.
52:13
And if we look about the types we get out. This is in.
52:25
This is not because that was from Peter first, but if I GP3 the first.
52:38
And this is actually now going to be a system strain.
52:46
So you can see that if we want to have more than one time parameter, what's it complaining about here?
52:54
This should be less. We can specify more than one type parameter here.
52:59
And if we do that, then that allows us to have you here and T here.
53:09
And the inference engine, again, it's going to match them up.
53:13
As best it's can as specifically as it can against the types that we provide in the constructor.
53:18
So here we gave an eight and a strings. OK, teeth benefit it and you had that to be string.
53:24
And when we do that, that means that this is going to return intact.
53:30
This is going to return string and then we get those types out here. I'll just from that one more time.
53:34
So and the point that you want to define your own types. The generic fair parameter I support, we have the tapes.
53:43
The main thing to know is that we introduce.
53:51
These angle brackets and the tight parameters after the class name, and then we can use those tee and you throughout the rest of the code.
53:55
Then when we come to construct one of those like Trum, the type inference engine is going to kind of bind the type.
54:02
That is most appropriate to T and depending on what we pass in.
54:10
Or we could if we wanted to think we can be explicit. Can't we be consistent and string?
54:15
If we wanted to, we could say make one of these faint and string.
54:23
But in this case, intelligence saying this is redundant because you can already figure that out because that's what we passed in this case,
54:26
we could put it in if we wanted to be. Extra helpful to the compiler or to the human to explain what's going on,
54:34
but we don't actually need that because it can figure that out from the types of things that passed in.
54:41
Are there any questions about that section on generics and time parameters?
54:49
I think that's a little bit more complicated.
54:54
You'll see this a bit more if you especially dive into some of the standard library classes, see how they're implemented.
54:56
And also when we get into next term and you start looking at more data structures yourself,
55:03
it'll be common to build your own data structures that are generic and types.
55:08
So whether you're writing in Scotland or you're writing in Java,
55:12
the same kind of mechanism is going to be in place where you can specify these angle brackets after the
55:16
class bind to say these are the type parameters and then use them through the rest of the class definition.
55:21
OK, not loads of questions coming in, just a couple of things, so I suggest we do.
55:49
Let's take a break for what should we do?
55:53
Let's do a 10 minute break. And then when we come back, I've got a couple more things to show you relating to Noel types that we talked about before.
55:56
So I'm going to show you a little bit more building on what we did last week about notability and using those in your programme.
56:06
Then I've got a bigger example, which ties a lot of things together, and I'll pick up any other questions that come in on the chat.
56:12
So feel free to post things in during the break, and then I'll come back and have a look at this.
56:19
So let's break now for a few minutes and we'll come back and start at 10:10.
56:24
OK. Welcome back. So just to pick up on a couple of questions in the chat.
1:06:03
Yeah, the question about two stream, I think that's right when we use a string templates.
1:06:08
So for example, if I converted my two string online for here into a string template rather than this concatenation,
1:06:13
I would just do so I could do this. I think if I wanted to do this, I'd have to do this with my.
1:06:21
So if I want to actually compete something in the middle,
1:06:32
call a method in the middle of the string template, then I can do that, but I have to put braces.
1:06:35
So that should still work. But we can also make a simplification, so let's try this one.
1:06:51
It's fashion first. Did I not print?
1:06:59
I didn't print. OK. That's just. So this way it's OK that I put an extra space in it by mistake.
1:07:06
But because what the string template is going to do is anything that it's passed to it, it's going to try to convert it into a string anyway.
1:07:28
We don't need to call these two strings ourself. We can do just dollar act.
1:07:36
Just tolerance us, and once you've got that, then we can actually reduce the prices and we get back down to this.
1:07:41
So that should have exactly the same effect.
1:07:49
And the reason for that is that effectively the string templates calling to string for us, so we could I mean,
1:07:53
we could do this right, we could call to string here and say, please convert P3 into a string and then bring that string.
1:07:58
But if we just say, please print P3 inside print line, it's going to say,
1:08:05
Oh right, well, I need to make this thing into a string before I can print it. So it's going to call to string for you.
1:08:11
So that's just an extra step, so we don't have to take. So it still works this way so effectively whenever we print something.
1:08:16
Or apparently using a string template in a position like we could convert it into a string ourselves, but actually that's going to happen for us.
1:08:26
And so more common, which must be to pass the whole object here or pass the whole object here.
1:08:36
And then under the hood, those mechanisms are going to call to string for us.
1:08:41
And then it's going to make history. I'll maybe I'll come back to the I00 question at the end if people are still interested in that.
1:08:46
I think that might be just for a few people. Let's, yeah, let's carry on and do a couple more bits then.
1:08:54
I wanted to talk a little bit more about dealing with Noel's safety, we talked a little bit about this last week in the video and in the lecture.
1:09:07
And so the thing that we noted about Scotland, which I think is especially useful and powerful,
1:09:15
is that the notion of malleability is encoded into the type system.
1:09:21
So we know from the Typekit something whether it could be null or not.
1:09:25
And we know when it can't be now,
1:09:29
and the compiler actually helps us to make sure that we remember to check things that could be now so that we don't have
1:09:31
a runtime exception and crash our programme because we have something that turns out to be null that we didn't expect.
1:09:38
And so that's actually a very powerful property of Scotland as a programming language.
1:09:44
There are just a couple of ways that we can deal with the possibility of now in a
1:09:50
programme that helps to make things a little bit more elegant or flexible in some ways.
1:09:56
So obviously the first thing we should do is just to write.
1:10:01
And if Jack, I think we did that in the videos last week where we were saying, OK, if this thing is potentially null,
1:10:04
the compiler won't let us, for example, call a method directly on something that might be no.
1:10:09
But if we make an if check, let's just do an example.
1:10:15
So if we have something that is, oh, actually, I suppose, if we.
1:10:22
Read a line that's right, how he had an impressive frame rate, impressive frame reader around system in.
1:10:28
Buffet returned this. If we read a line here.
1:10:42
Then this could be no, because we saw that we used that the no signal was we've got to the end of the file, for example.
1:10:54
So the type of this is going to be string. Question mark. I'll just ask it to explain, isn't it?
1:11:02
I thought it was strange. Question mark. Pretty sure this is a strange question mark.
1:11:09
So then if I say, what's the length of this line, it's going to say, no, you can't do that.
1:11:16
Because this thing might be no. And what we saw last week was that we could.
1:11:27
Well, the possibilities are either we say, if the line is not now.
1:11:32
Then we can put it inside a block where it's checked, then the compiler knows that it knows that we've gone in here and knows this is a vowel,
1:11:43
so it can't be any must be set only once and then this is safe.
1:11:50
We also saw the option of using the safe call.
1:11:55
Well, we put the question mark here. And therefore, if the line was no and this would return, no, and it wouldn't try to call day length,
1:12:01
and if it is does have a value, then it can call that length.
1:12:10
So we either get the length of the string or no.
1:12:14
But someone asked a question in the lecture last week, which I thought was very insightful, which is what is the type of this?
1:12:18
And so if we say, what's the Typekit this length?
1:12:24
This has length the length of the type of into question mark because it might be the length of the string.
1:12:29
If the line is a rail line, but it also might be now because we're going to get back now from the safe call if we have a no receiver.
1:12:34
And so what I'd like to do in general is to restrict how many places we have potentially
1:12:44
no values so that I don't have to do these safe calls and checks all over the place.
1:12:49
And I can just rely on things being nonno. I would like to be able to say, OK, well, this is definitely a need.
1:12:53
I don't want to say, well, this might be an and if it isn't, then that's good,
1:13:00
but otherwise I need to check for it and do call or if conditions, everyone.
1:13:04
So it would be really nice if this was an. But it's not right.
1:13:09
It says no, that might be now, OK, because if this is null, then this is going to return.
1:13:13
No. And so one of the ways that we can get around this and allow us to convert from potentially Nullarbor things into
1:13:18
things that we know definitely have a value is to combine the safe call that we've seen with another operator.
1:13:27
We've seen this one, and the one we're going to combine it with is called Elvis.
1:13:35
The reason that it's called Elvis is that it has this kind of shape which if you look on the side, turn your head to the side.
1:13:40
It's kind of like two eyes and then someone with a quick hair like Elvis Presley.
1:13:46
So that's why it's sort of informally known as this Elvis operator.
1:13:51
I think officially it's called the no coalescing operator, but that's a bit of a mouthful to say.
1:13:55
So I think people will often talk about it as an Elvis operator, you might see this in some other languages as well.
1:14:01
And what this is doing, it says, OK, well, if this site is, which would give me the right way around.
1:14:07
If this site is not now, then is this value? Otherwise it is now.
1:14:14
Then it's this funny. So effectively, the way we reduce it is to put it here.
1:14:20
And what we would have is the equivalent of, yeah, if line at length.
1:14:29
It's not equal to no. Then the result is like.
1:14:38
Committee this week, I don't want. Yeah, can do that here.
1:14:48
So he said like, OK, if this is not, no, then it's this.
1:15:02
Otherwise, it's zero. And that means that we don't ever get no back from this expression.
1:15:07
We always get it. We either get the length of the line because the line has a length or we get zero.
1:15:12
And so that's what the Elvis operator is doing. We basically say, if I just don't do this.
1:15:17
An equivalent piece of code to what you've just written, which is to say, OK, if the line length is a value,
1:15:25
if line is not now, therefore length give us and back, then we can add in line length.
1:15:32
If line is now, then it won't call this, it will return null instead.
1:15:38
And then this operator will kick in and say, Well, if this is null or other, this is null.
1:15:42
Then give us zero, and that means that we either get out of line or we get zero,
1:15:48
and that means that the type of this is just ain't not in question mark.
1:15:53
So it's not notable that this can never be no.
1:15:57
And then from this point onwards in the programme, like we're absolutely fine to use it and to call methods on it and not to use the safe call.
1:16:00
So we could possibly use something like this at the kind of first point that we have potential no liability and say,
1:16:08
OK, well, if this is potentially null, let's try and coalesce it into a non null version.
1:16:16
So if we got a potentially null line, we want to get the length of it.
1:16:21
OK, let's just go with zero. And then that gives us a definite value to work on from here on in the programme.
1:16:26
So you might commonly see these together, so you'll see Safe Call, which will say try and call this if there's an and if you have a non null receiver.
1:16:32
If we do have a known, obviously if we have a null receiver, then this is alternative value to use.
1:16:44
So Safeco and Elvis often have had a go together.
1:16:51
The other variation that I wanted to show you was this idea of Let's.
1:17:01
And so that is something that we can also use with a safe call in order to do something so we can say do something.
1:17:06
With this value, if it isn't now for methods.
1:17:14
So previously when we were using safe coal. We could say call a method of line if line is not now.
1:17:19
But what if we want to do something that we've decided? So let's let's take a line.
1:17:26
And we kind of want to say if the line is not now.
1:17:32
Then I don't I print. Print three times.
1:17:39
The line, something like this. Otherwise don't do that.
1:17:46
All right, so basically, we want to say only if it's this and then maybe.
1:17:51
Something like this, let's just define this. Something, you know, pointless, but demonstrations like this.
1:18:04
So let's do this. So I only want to do this if this is not null.
1:18:20
So I can do that, but another way that I can do the same thing.
1:18:25
As I can say, OK, well, line dot let and then I can pass a block that says, OK, in this block, let's have an AL.
1:18:30
And then we can do whatever we want with it, so he can say print three times al.
1:18:42
And then we can do this. You can do that kind.
1:18:49
Highs and lows, string question mark. What seems odd, what's going on there?
1:19:05
I think we need a nine question mark. Are you?
1:19:21
Thank you very much, people who are paying more attention to me took a want to tighten.
1:19:28
I need a line question mark because I don't want to run this let if if it's no.
1:19:32
Small bit of syntax makes all the difference, thank you to people who are paying attention.
1:19:38
So here we can say if the line, we're going to do a safe call of lads.
1:19:44
So if this is no, don't run this, let me say, is not if it's not now we're going to run this lap block.
1:19:51
So we're going to run this lambda. And at that point, [INAUDIBLE],
1:19:56
it's going to take the value of line and then we should be able to call this and call this and treat it as a non null value.
1:19:59
Because we know that we've gone into this, it's effectively doing the same thing as this, except in a shorter way.
1:20:05
And especially if we do this on one line, that can be a nicer way to do that.
1:20:11
So you might see this. In some cases, it might be useful to use this in some places.
1:20:16
It's just another variation really on, you know, doing this kind of thing.
1:20:22
Perhaps more concise, perhaps more idiomatic, and then I'd like to see try to avoid this check if we can,
1:20:28
as an explicit thing in and if and use these cycles and the rest of the system as we can.
1:20:35
And as I say, if we can get into non-negotiable values as soon as we can on multiple types,
1:20:40
then that's good because if we don't have to write the question marks,
1:20:47
we don't have to do the safety checks anywhere else in our programme from that point onwards.
1:20:50
So if we can do this conversion and then call onwards into functions that take non-animal types, then we're in a better place.
1:20:55
Sorry, I talked to Enron that caused some confusion. Any further questions about these contributions?
1:21:02
Yes, please go ahead. So see for Elvis. Operator Can you can you like to function?
1:21:11
Can you let the programme run a function after the Elvis operator instead of just if I care about you?
1:21:19
Yes, I think such as such. But you mean so basically, I hear what did I say?
1:21:27
So if? So basically, we want this end to be the line length, but if line is null, then you want it to be some function.
1:21:31
What function would you like it to be? Plus one plus one of.
1:21:42
Oh, yeah, that's true. Probably. Mm. So you could definitely do like, you know, random number or something like if we had that function,
1:21:50
that would I would definitely call a function here, but you can't there's no parameter to this function.
1:22:00
So it's not like we're going to pass line to this function because we're only ever going to do this if line is no seat.
1:22:08
You'd always get no. Yes. So you can deftly call a function here or call any other bit of code.
1:22:14
And if we create this function? Well, let's say if we were to print something, if a truly Elvis operator, if it is, oh, well, let's let's try.
1:22:18
So you want to like print something you can't? OK, we can only print something.
1:22:30
Because if I define for something. Right.
1:22:37
And that's that's just saying. That's right, so it's saying, well, actually,
1:22:41
you're supposed to return her value because we need to give it and we need to return and to assign to length.
1:22:51
So if print is a function that returns units like it doesn't have a return, then that doesn't work.
1:22:57
But what we could do is like print something and return five.
1:23:03
Like this would be all right, because then we could return five. This would mean that the talk of this became since.
1:23:11
And then it would be happy because this would be then like, OK, do something,
1:23:20
but eventually return a value because it needs to return a value to get assigned to length.
1:23:24
OK, thank you. That makes sense. Right, as India, all better, basically it already.
1:23:32
It is, but instead of being true or false, it's like null or not, no.
1:23:43
OK, so because it's like when it's Henry, you would have like, you know, if this is true, then X.
1:23:49
Otherwise why? And in this case, we kind of the combination of the Safeco and the Elvis is kind of like this.
1:23:55
If this is not null, then the result is this otherwise the result is this.
1:24:04
So it works in the same way as the ternary, but that kind of conditions are different.
1:24:10
So we weren't assigning it to a variable, could we then have opened Alan statement?
1:24:17
That's a good question. So you want to say like, don't ask me to invariable.
1:24:23
Basically, put this back to being just print something.
1:24:30
Honestly, you don't know what it's going to do. Let's have a look. So this is going to be returned units, right?
1:24:37
This is not very happy. Oh, no, does, because it's not renamed it correctly.
1:24:43
Yeah, then it seems happy because you're returning effectively, you're returning as a unit type and you're not assigning it to anything.
1:24:53
So therefore, yeah, therefore that is OK. It looks slightly weird to me, but because.
1:25:02
But but yeah, but it is okay because, as you say, you're not assigning the results.
1:25:12
It's just that if if it. Like, if it's not, no, it's going to do this, but then it's not going to do anything with the results.
1:25:20
I guess you could do. Yeah, it's kind of slightly odd, I guess, but I guess you could do like let's.
1:25:32
So you could kind of do this, so you could say like, OK, let's do a safe call on the left, I'm sorry.
1:26:01
Safe call with a left so that if it's not null, we're going to print out the string.
1:26:05
But it's that thing is no, which is if this is null, then it's going to do this one instead and it's going to print, it was no.
1:26:11
So you could yeah, you could do it like this. It looks kind of slightly odd to me, but slightly difficult to work out what's going on.
1:26:20
But you could. Yeah, the type system allows it.
1:26:29
So I would say have a little experiment and and see what you can do and kind of what feels right for you.
1:26:31
I think what you know, feels clean, that one is working,
1:26:37
but it feels like now we're getting into the state of actually maybe it would better to be that is to print like, you know, if X is now.
1:26:41
Then print, it was now. Else this was lying.
1:26:51
I feel like in this case, this one is slightly more understandable than than this one.
1:27:03
But it depends on the style of the rest of your programme, I think. So I think as with all of these things, just go and have a play in intelligence,
1:27:09
see, you know, what compiles, what doesn't compile, what types things are,
1:27:25
what goes together, what feels neat to you and what may be intelligent gives you a suggestion of
1:27:30
how to compress things in some cases where things are needed or not needed.
1:27:35
All of these things, just as you get the language under your fingers, you'll begin to feel you know what feels natural to do.
1:27:40
So I wanted to do. Yeah.
1:27:48
Think I wants to do one more example. Let's go back to the slides.
1:27:57
But she's just a little bit bigger.
1:28:02
And it'll just pull together a few of the different things that we've talked about today and allow us to build a slightly more complex programme.
1:28:05
Not very, very complex. Just what I'd like to do in this case is to build our own data type again, like we built.
1:28:13
But instead of building a pair, I'd like to build a linked list and we'll see how this involves a number of the different pieces that we saw today.
1:28:19
So just to be clear, the structure that we want to build is I'd like to have an object called linked list of Typekit,
1:28:29
so I could have a link list of strings, linked list of events, list of URLs or web pages or whatever I want.
1:28:35
And the way that we're going to build it is that a link list is an object which has a head node.
1:28:42
And then there's another classical node which is going to hold the data and each node has a pointer or a reference to another note.
1:28:49
So as we going to build it up, we're going to end up with this kind of structure.
1:28:57
So we kind of have one object that represents the list as a whole. That's how we're going to talk to the list.
1:29:01
And then behind the scenes, there's going to be this collection of nodes that's built up as we add something to the list.
1:29:06
It's going to make a new node and put it on the end. And then if we want to operate on, say, the second node, we're going to have to start ahead.
1:29:13
Follow the links. Count along and get the second node out and then look at the data that's inside.
1:29:20
So we're going to build up this structure. So I'm going to build a couple of classes that represent these pieces,
1:29:26
and we're just going to see how to implement those and how that involves using some of the stuff that we've done today.
1:29:31
So let's maybe I'll make a new file. Well, I mean.
1:29:40
And so in this case, maybe I'll write the main first. So what I'd like to be able to do is say foul ale is a linked list.
1:29:53
Of our length, this type of strings. And start with an empty one, say, and then at.
1:30:04
This and. At this, so then we should be able to build it up into the structure that we saw in the slides like this.
1:30:15
By calling this kind of API. So the first thing that we're going to need.
1:30:25
Is that in order to make this happy?
1:30:32
I need to give it a tight parameter, so that says, OK, this is a class that can be parameters traced on tape, I wanted to use it that way.
1:30:36
So let's give it our tight parameter. And then if we check back to our designed documents,
1:30:44
we're going to have this and it's going to have a property which is the head, and that's going to be a tight node.
1:30:51
And then each of the nodes is going to be like this with a data and an next.
1:30:57
So let's make another class for note. Inside the no, we're going to have a property.
1:31:04
Maybe a day like this, we're going to have a private file data.
1:31:15
And that needs to be of type T. In the case, this data is an insult because this is actually a node event inside a linked list event.
1:31:21
So in this case, we're going to have a link list of string. So it's going to have node of string and then data is going to be of type string.
1:31:30
So here I need also to have tea.
1:31:38
So this says, OK, we're going to make a link, Mr. Tohti, inside, it's going to have a private foul head, which is a type.
1:31:42
Node of tea.
1:31:53
And this tea is going to be the same, so when we're going to make a link list of string that's going to populate or bind as we say this tea.
1:31:55
And that's going to mean that this tea is the same.
1:32:03
Then we're going to have a node, which is also a type T, but we could have a different type parameter here.
1:32:07
This would be fine to use this one like this. So this is just a name that's local to this class.
1:32:12
And then it's going to have inside data of type T. And it's going to have a next, which is a note of tea.
1:32:22
So we've got a few compiler errors to deal with here. So the first one is that this is not initialised.
1:32:36
And OK, so we have to think about how are we going to initialise it?
1:32:44
Well, when we make the initial list, it's going to be empty.
1:32:47
And so we're not going to have had to point to anything. So in this case, I want it to be that when we create one.
1:32:51
It's going to be no. And now we're going to have a different type of campaign that says, Oh, well,
1:32:59
that's not good because your head type is type node of T, so that's not allowed to be no.
1:33:05
So that's a question mark here. OK. Well, in this case, we're making something that we are controlling privately inside,
1:33:12
and we're going to use now as a signal to say this is going to be possibly populated later.
1:33:20
Let me add something to the list. So it's OK for this to be done. Then let's look at the note.
1:33:24
Basically, the same problem the vowels, but they are not.
1:33:30
Constructed. Let's what shall we do that it should be?
1:33:35
Well, we should construct. No, with a T, so let's have.
1:33:44
Did I call it something in the diagram? No. So let's have like lamb of type T.
1:33:51
And this is Alan. So we're going to construct a node with a value.
1:34:01
Maybe I should call this value. And then I'm going to save that in the VAL data and then the next in the chain again,
1:34:07
it's like we saw with the hedge property where you can see that in the third case here next currently is no, because we don't have a next.
1:34:16
After the end of the chain. So we better say that this is OK to be no.
1:34:25
So I got to say, well, it's initialises now. And its type had better be note of to question mark because it has to be allowed to operate to be no.
1:34:30
So we can proceed and build up the chain this way.
1:34:41
So we're getting there now, we've got to add this function that allows us to add things into the list.
1:34:46
So this is going to be a method of linked list because I'm going to call Eldon,
1:34:51
and so then I'm going to go into here and I'm going to define this function.
1:34:56
All right. And you can see the type here is what we in this case,
1:35:02
I called it with a string and string matches this type T. So this is going to be add some element of type T.
1:35:06
And then we have to think about how to do that. So in the case of the list is empty.
1:35:17
Then I want to create a note with that vitality value in it and assign it to that.
1:35:23
And in the case that it's not empty, I want to build another link in the chain.
1:35:30
So let's do the case where our head is no offence. So if head is now. They were going to say that had equals a new note with this, and I mean it.
1:35:35
And again, we lean on the compiler, see what it's saying, it's saying, Oh, OK, well, actually,
1:35:50
you've tried to reassign heads because previously you assigned it once and it's currently declared as vowel,
1:35:56
which means it's not allowed to be reassigned. So in order to do this, we need to define had to be a mutable property of linguist.
1:36:04
This seems fine if you think about it design wise,
1:36:13
because what we've said is correct when you create the linked list, it's empty, so it doesn't have a head note.
1:36:15
And then when we want to create wants to add something, we're going to give it a head note.
1:36:21
So this seems reasonable for it to be mutable. So I'm going to change this one to be Avar.
1:36:26
And then this is happy. So that's OK for the first one.
1:36:31
Then we want to think about the second one. So what kind of what's going to happen so we've had is not now.
1:36:38
There's a few different ways that we could do this, but perhaps we could say otherwise.
1:36:44
Go to the head node and ask it to add an element and then defer that down the chain so we could say otherwise, Head adds.
1:36:53
And then we have a question of whether we want to add a note with the alarm or just maybe let's add.
1:37:03
Yeah, let's try this way. So this is an OK right now, we need to build a function on node that allows us to add a node after that existing node.
1:37:14
So that, say, function ads, which takes. Node of type, node of teh.
1:37:27
And then what's it going to do? Well, it's going to say we want to add it after this one.
1:37:42
So if. Next is now.
1:37:47
The next equals this note. So if it's the case that we're at the end of the chain and we're just going to tack this one on as the next one.
1:37:55
Otherwise, let's add. The note to the next note and then keep going that way.
1:38:06
Something like this. So what's this complaining about? OK.
1:38:19
Same problem again, because previously we defined our properties as being vow.
1:38:22
And I think that's good. That should be our default is private and vow. So they're private, they're only a sign of a once.
1:38:28
That's the kind of safest, easiest to reason about. But now we come to realise that OK,
1:38:34
in the same way as had needed to be reassigned next needs to be reassigned because we want to dynamically build up this.
1:38:39
So let's allow that to be reassigned.
1:38:45
Now, let's let's see what this one's complaining about.
1:38:51
So this is a new message that we haven't seen before, I don't think maybe you've seen it experimenting on your own code.
1:38:55
This says next is a mutable property that could have been changed by this time.
1:39:02
So here we try to say if next is now, do this branch, otherwise do this branch.
1:39:07
So in this case, we know that next is not now here and that it should be fine to call at.
1:39:13
But the compiler is saying, Well,
1:39:19
I'm not sure because there's a possibility that there could have been something else happening here like, you know, randomly.
1:39:21
Reassign. Next to no or not.
1:39:31
Like, this is a method that it could exist here, and in this case, if we did that, because next is a vile.
1:39:42
If some code ran here at this point, it could now be null.
1:39:49
The compiler, although we as a human, can see that that wouldn't happen in our programme,
1:39:54
the compiler can infer quite enough to be absolutely sure that this is definitely going to be not null at this point because it's VAR.
1:39:58
It's possible that someone else in the programme called something that's going to modify it,
1:40:06
and it's not able to totally be confident, totally proof that that's the case.
1:40:11
So therefore, even though we're in an else block with an effort, with that with a null check, we still need to do a safe here.
1:40:17
Now. We know that this is not going to happen, and we know that this is this is now it's going to come in here.
1:40:25
Otherwise it's not going to be now. But just in order to guarantee it to the compiler, if you get that message,
1:40:31
that means because we have immutable property, it may have been buried in value.
1:40:37
Therefore, we put a safe call in. This is another reason why we prefer Rafal property, then that allows us to not have to do this if that was a vowel.
1:40:41
This part wouldn't work, but this cycle wouldn't be necessary, so to make this work when it's out of order and then we need it to save cohere.
1:40:52
But then we should be all right. So I think our code is OK now, but we probably be a good idea to be able to print it.
1:41:00
So let's try and print our list.
1:41:08
And as we know by now, I mean, I'll run it anyway, but we can predict that it's not going to print very easily because we don't have to string.
1:41:15
And I just a little. Oh, no, it's the same problem up here.
1:41:26
Sorry, didn't scroll up far enough, that's the same thing.
1:41:29
This could have been it was the same message.
1:41:33
Smart smartcast to head is to know it's impossible because head is a beautiful property that could have been changed by this time.
1:41:38
But this case? Safe call this. OK, so then we print and it's going to print in the style that we have come to expect.
1:41:44
Like this, so let's implement all two string. We're going to implement two string.
1:41:55
And what should we do, let's do the string builder. Approach that we've done before, so do you vow SB as a string builder?
1:42:04
Let's return ESP to string. Let's spend cash, we print it, let's print it with square brackets.
1:42:15
So let's do this and now we need to make a leap.
1:42:26
But I mean, we could do various approaches, but I think, well,
1:42:32
let's do a loop that's going to look through all of the nodes and then try and print them until we get to the end.
1:42:34
So let's see. How about.
1:42:44
Are currents equals head? So let's get a reference to the current one, and then we'll say while.
1:42:50
Now, maybe we need to shrink the current one, so let's do a speed or upends.
1:42:59
The current one. Then.
1:43:07
Is this right? Do we want to do this and then we're going to do a loop that says.
1:43:16
While. Current dot next.
1:43:22
Is not novel. Then we're going to say that.
1:43:28
Current is current on next. We're going to spend a comma.
1:43:38
Space. And then let's spend. The current one and then we'll go around that again.
1:43:49
So then the problem is we haven't got a next method on note, so let's add a next method.
1:43:56
I think especially because this is a property, I don't want to make it public, so I'm going to make a next, I just create this here.
1:44:05
I'm just going to define it. So we're going to say.
1:44:18
Next, which is a type. Node of key question mark.
1:44:24
His next. That allows for this and the same as what we have before, this is going to say,
1:44:33
well, you've got an immutable property and you've got another thing here.
1:44:39
So we need to safeguard this one. We don't need to Typekit that one thing.
1:44:44
So again, we just follow what the competitors are saying and then hopefully. This is enough.
1:44:55
We haven't done testing on note. So let's say, yeah, let's just do two string here.
1:45:08
And here we can just say, okay, let's get the data and ask it to convert itself into a string.
1:45:24
And now we'll see whether we've done the right thing. So we've got these two that looks good.
1:45:36
Let's just add a couple more things. Typekit.
1:45:42
Just to check the box. So four things in the G-string, that's all right, so hopefully people who are worried about that in the chat are convinced.
1:45:59
And then I just want to do one more thing. Just to kind of bring everything together.
1:46:10
So how about if we also one of the things we've been looking at is how that we can
1:46:16
use functions as first class things we can do kind of functional style programming?
1:46:20
So what if we want it in college and what he wants to allow for a map function override link list where we could pass in a function?
1:46:24
So for example, if I have this list,
1:46:32
AL and I want to map a function that takes each string and it goes to databases like the string and goes to up length.
1:46:33
And then this would be a list of lengths.
1:46:47
And then I could try to print. Thanks.
1:46:59
And so on, what to expect is that this is a type of linked list of its.
1:47:05
That we could get by calling and map function,
1:47:14
which we're going to map method that we're going to define to apply this function that we are defining as a lambda to each of the elements,
1:47:17
creating a new list and returning the list of things so we can create this just in the same way as we did with everything else.
1:47:23
So let's say this is a function map. Let's think about the signature stuff, it's going to take a function that's a function type of letter before.
1:47:31
So this is a function which converts T's into another type.
1:47:43
So this is a function of type T two type you.
1:47:48
Now the problem here is if you don't know what you use,
1:47:55
not defined as a type parameter on the class, and it's only really interesting for this method.
1:47:57
And so here I want to define. An extra tight parameter that's only for these methods, so I'm going to do that here.
1:48:02
So that's another place where we can put a tight parameter definition. And this is going to return us a linked list of you.
1:48:11
So now all I have to do is, let's say that will make a vowel results.
1:48:22
I could type is a lengthy list of type you, it starts off empty.
1:48:30
We can return it so that it makes the compiler happy.
1:48:36
And then all we need to do is to populate this with the result of applying the function to everything in our list.
1:48:40
So let let's do something that's kind of similar to what we did down here.
1:48:46
So I'll just copy this in. So I'm going to get the current heads. We're not going to append the we're going to say.
1:48:54
While. It's not licenced, so we want to do.
1:49:05
Results DOT ads apply the function. The current dot.
1:49:17
Data, so actually, we need to be able to get the data out. So this is another method that we should add like this one.
1:49:28
And that's of type T, and that because data.
1:49:42
And then if you come out here, then hopefully. Which is safe, called this one.
1:49:49
Do we? Was he complaining about? OK, we need to do.
1:49:55
If. Current. That should do the trick.
1:50:18
I think that's probably a neater way to write this, that we could refactor in a minute if we have time.
1:50:32
Hopefully. That's going to do the right things.
1:50:38
Missed one. OK, which someone we missed, we missed the first one.
1:50:45
So why if we'd get that wrong, so we didn't we didn't process.
1:50:54
Maybe you can move the current next time of the day after the if so.
1:51:14
This line. Down here, I work.
1:51:24
No, no, it's missed out the last one. I think the problem is that we need to do that.
1:51:38
First of all, do you like if current? If not now, then we'll.
1:51:53
This. And then. If there are more to do than let's go and get them all and then do this one.
1:52:01
I think that's going to be right. And I suspect if we spent five minutes, we could find some neat ways to write that that looks better like hello.
1:52:14
Five. So there's probably some neater ways to do that.
1:52:26
I'm sure we could tidy that up so that you could tidy that up.
1:52:29
But the part that I wanted to really show with this is this bit here, which is that we're going to define a function which takes a function.
1:52:32
But in this case, to find a function that takes a function between two type parameters 20 and you two constructs
1:52:42
a new type of our own type of type you and that this view is defined just for this function.
1:52:49
So hopefully, as I say, I think there's some ways to tidy this up.
1:52:56
We've used some loops, we've used some null safety checks. Give you some type parameters of generics to defined our own data structure.
1:53:00
We put that all together and hopefully now we've got something that works and we would be able to use.
1:53:07
So hopefully in that example, we just put a lot of things together that to show you these ideas working this way.
1:53:14
So I think that that's all I wanted to cover today. Just take my notes.
1:53:20
Yeah. And so I think that hopefully puts you in a good place.
1:53:24
First of all, just to work on some more cutting programmes yourself.
1:53:28
But then to do this transition into Java, where there'll be lots of concepts that you recognise from Kotlin,
1:53:31
you'll be able to map across directly in terms of syntax, and hopefully that will give you a good start.
1:53:37
And then next time you'll be working much more on the bigger, object oriented design trying to model the world.
1:53:41
Do you typing relationships and thinking more about encapsulation and design?
1:53:47
And I think you have Alistair for those lectures. It's really great.
1:53:51
So you'll really enjoy that as well. So I'll stay on the line for a little bit if people have any more questions, but otherwise,
1:53:55
look out for some more posts that I will explain about the pre-recorded lectures that we'll put up again,
1:54:02
which will be short segments like we did before to do the transition from Java psychotically to Java.
1:54:08
But all of the tooling and inteligente that you have already set up is going to work just fine for that as well.
1:54:14
So thanks very, very much for everyone for attending for the last four weeks.
1:54:20
Hopefully, it's been enjoyable to try a new language and to get used to the tooling and see what's available, and we will see you see.
1:54:24
I have a quick question, Sir. John, I'm so, you know, enumerated class types.
1:54:40
Yes, sir. Sir, how would you put a function for?
1:54:45