ID: d172f338-64c4-4692-ba04-add500cefd78
Title: Type classes II & intro to IO
Category: Haskell
Lecturer: Anthony Field
Date: 03/11/2021
OK, good, so welcome back.
0:10
So what I want to do today, I'm going to give quite a short session today, so I'll give you a bit of time off so you can do something else.
0:13
So I won't use the full two hours. I want to finish off this stuff on type classes.
0:20
So what we looked at yesterday was all this stuff I showed you,
0:25
the classes you need to know about for the course generally one, they are basically the EKU, the old the show and the class.
0:29
Those are the ones you really should have at your fingertips.
0:39
There are other ones that you'll come across in your travels or you may come across in your travels and feel free to go and explore.
0:41
But I don't think you need any more if you do need any more for like a test, an upcoming test or assessed exercise or something.
0:47
And I'll let you know in advance and you can practise with it. All right.
0:54
So so it'll all show and will do nothing today. So I showed you how to show you how these classes were defined, or at least some of them have.
0:58
Some of these were designed to show you how to what the impact they had on type signatures by word contexts.
1:06
And we looked at functions with multiple contexts, which is the example we showed you here.
1:11
And we ended up looking at tuples and we discovered that tuples, I think we decided, was a 16 cheeba was the biggest tuple in the world.
1:17
As far as Haskell is concerned, you can't have a 19 tuple. So these are all.
1:26
So 16 16 tuples are members of EKU provided the types of the individual elements, also members of Q Right.
1:32
So typically we just use typically two or three elements, tuples.
1:40
We tend not to ever sold any more than that. OK, so I'm going to finish up with this.
1:44
So in this week's lab exercise, you will have a data type which is probably not dissimilar to this.
1:52
And what you have to do is evaluate it and then do some write some rules and implement differential calculus over these expressions.
1:57
So you think of these expressions as being functions of some variable.
2:06
And so in the expression type you've got there'll be another there'll be another constructor, I guess, for a variable.
2:10
So you can introduce a variable like X or Y or Z, and then you can differentiate a function with respect to X and expression involving X,
2:15
with respect to X or Y, Z, whatever your chosen variables are.
2:22
So if we omit the variables and we just have really simple data type like this, this one's got three.
2:27
This one's got four constructors. It's got constants and then three operators, addition, subtraction, multiplication.
2:33
And it's a recursive data type because the arguments of an addition, for example, will be two expressions.
2:40
So I can have the addition of in addition of subtraction and multiplication it so that the level of nesting is arbitrary,
2:48
hence the recursion, the data. And this is exactly what you get in Haskell language proper.
2:55
So you know that Haskell expressions can be arbitrarily nested. There is there's no restriction.
2:59
Right. So. Well, right. And by the way,
3:05
I made this data type derive automatically what I've got Gibus GHG to derive automatically the the member functions of the show an equal class,
3:07
which means equals, not equals. And then little show it's shown little s.
3:17
So what that means is that if I've got an expression like add well it says keep it simple.
3:22
If I got an expression like const one and I've got I can ask no one is equal to by virtue of the the the equal thing, the fact that it's an instance.
3:29
If he came in, I could also ask it to show an expression like const three for example, and that will display it in an obvious way.
3:42
So I haven't actually given it any specific instructions on how to show it.
3:51
Just do the best you can do.
3:54
Look at what I'll do is I'll show the name of the constructor and then I will essentially, because if we show the argument,
3:55
which in this case is just three, well,
4:01
it now has it knows how to show three because three if if an expression const three, what is the type of three.
4:03
Well three must be in it because the that's the way it's defined.
4:11
So does she know how to show in it. It's certainly jolly well does.
4:16
In fact I can actually just make that and make it absolutely clear it's not different to
4:21
anything else and it knows that to display the three it puts it displays the string.
4:25
The delivers the string, the show function,
4:32
given the industry will give me a string with the digits of the number, which is just a single digits three.
4:35
So to show coal industry, it shows the string consed and appends to that the string for three and of course the show function,
4:42
we can give it any expression. So let's make it slightly more complicated. One constant five to constant seven for example.
4:52
Well of course that's just going to recursively show the five. The seven and then.
5:00
Attended to the name of the construction of the construction,
5:07
so you can see how the string you you're seeing in front of you, you can see how that gets generated.
5:10
As a result, of course, we've been working the show on on the on the bits and pieces and the expressions of the show by show concern,
5:17
and then they were prepared to that string representing the ad constructed ad space, I guess.
5:23
Now, if I admit the show. That's fine, because high school say, well, that's just an expression.
5:31
So what does GHC do we know what GHC does? GHC takes an expression, evaluates it, and then in order to display the result,
5:37
it applies the little Shogo function to giving it back a string and then the contents of the string is the
5:45
thing gets printed to determine several exactly like the same as the above but without the double quotes.
5:51
OK. And that's the same thing if I say eight, I don't get quotes around the show, it I get the double question.
5:56
So GHC is the printing engine, if you like.
6:03
It is the engine which drives the evaluation. And if there's any, of course, you know, expression's but Lezley.
6:07
So it's GHC itself that forces the evaluation of the expression,
6:12
then invokes the show function and then displays the contents of the resulting string at the terminal.
6:16
That's, that's the way ghc well the way it works I guess at the top level.
6:20
Right. So let's go back to this.
6:26
So let's see what are the evaluation rules. So OK, if you give me an expression I'll give you back an inch.
6:30
So that's like I could say, to give an expression, I'll give you back an expression.
6:36
But actually this one is designed to compute, not expressions, so.
6:39
Well, if you have a well, we know X is already in it, so therefore the result must just be the X.
6:45
If I have the addition of two expressions. Do you see any problem here, arbitrary sub expressions?
6:52
Well,
6:57
we just because we evaluate the E the prime and those are going to give me something that must be an inch looking at the type signature that must be.
6:57
Therefore, I know I can add them together using an int using plus rather parts together to give me an and certainly with subtraction multiplication.
7:04
So these rules are similar. The only difference between them is the mapping between the name of the constructor and essentially what it's meaning,
7:12
which in this case is the mathematical or the Haskell function plus or minus four Suppan and multiplication.
7:22
All right, then. So there is a an example.
7:29
Was it three times six plus seven? And this has a rather sort of grotesque representation, but that's absolutely fine.
7:35
That's that's what you get with when you define your own data type. You use the constructors of the data type to build an object directly,
7:41
which has the specified type so it can build expressions just by typing in an expression involved in the constructors of the toll.
7:48
And once I've done that, I can even evaluate. And so perhaps if one can, I actually should be able to just place that as it's an example.
7:57
Let me see if I can find the right control key and it's come in here and there.
8:06
You can see that I can get the answer. Twenty five.
8:14
Right, so the evaluator is taking the representation, representation of an expression, and it's giving me back an inch,
8:18
which is what you get if you evaluate that representation, interpreting the operator's, the mulch and the ad in this case.
8:25
So that's fine. It's OK. But it's a little bit sort of long winded, isn't it?
8:35
Know if I go so slightly longer. So really, really what this is representing is what was it good to get my bracketing like?
8:39
This must be three times six plus seven, is that right?
8:47
That's right. And in fact, you know, we know it brackets it that way from the actual one so you can put the brackets in or not.
8:52
But but that's really what I mean, isn't what I mean is the expression representation of this thing in here.
9:00
And you might think is that wouldn't it be nice if I could just type that rather than having to type all this lot?
9:07
Is there some way I can get it automatically to generate this representation of three times six plus seven,
9:11
given the input three times six, seven, which is the more familiar mathematical way?
9:18
Well, it turns out that this is exactly what type clauses enable you to do.
9:24
So there's a type clause in Haskell called the no class. And the rum class, which we stumbled across in our travels when you were going back,
9:28
it looks like this these are the type signatures of the number function. So it consists of seven seven functions.
9:37
So so for you to remember the NUM class, you have to be able to add and multiply A's and subtract.
9:44
And so these three types that the trucks of these four things are eight whiteway.
9:54
So you can't add a num, an integer, for example, to a floating point number.
9:58
Once you've once you said, oh, I'm going to create the instance of NUM,
10:03
then the plus function for that instance must be institutions to Entercom to float to something.
10:08
I mean, you think you discovered this number right at the beginning.
10:14
We had to work from Integral in order to wrap to MAPA to a map of an integer into a floating point so that you could use exploit the say,
10:17
the floating point or the double double precision, for instance, of the class and so on.
10:26
But it turns out there are other functions and there's one called Negate and ABSs. So if we come to the terminal, you can play with these things.
10:32
You can get eight. Guess what? You get back. What was the other one about the signal?
10:40
So you can say, what's the absolute value of minus ninety nine?
10:47
It will tell you the absolute value of one of our.
10:50
And it was also a signal, the signal which is spelt signalmen that way signal of a positive number gives me one and.
10:54
Oh. Oh, I yeah, so I've got the ninth moment, but signal of a positive number is one signal of a negative number is minus one signal of zero zero.
11:08
So I've already got the signal function implemented in the script, which is why it's complete.
11:19
So which one you want to pick. So it's simple enough.
11:23
I mean. OK, and there's one more, which is this from integer function,
11:28
so the other four inches as it is, it's a way to to to put an integer into the NUM type.
11:34
So given an integer, its job is to pick something of a.
11:41
We'll see how it's used in just a minute. All right, so.
11:47
Now, and so the idea is we're going to make an X instance of none and this is the trick.
11:53
So I've got a new data timer, a new data type is this thing here is expeditor type I.
12:00
Once I've got a data type I can do, I can make it make it into whatever whatever type classes they want.
12:05
So if they've got GHC to make it an instance of showing IQ, but using the different definitions, of course I could make explicit,
12:11
for instance, instances for X if I wanted a more elaborate shell function or a different notion of equality.
12:19
But when it comes to them, I've got to define my my own instance.
12:27
So what I've got to do is I've got to say, what are the definitions of plus and minus multiplication and uncertainty from integer?
12:29
We'll skip the other two for the X data type.
12:37
Well, you can see why I've chosen the constructors I have because the the the the add to structure corresponds to addition.
12:41
The sub constructors, the subtraction, the more constructed the multiplication.
12:50
So if those three lines aren't immediately obvious, let's come and look at the.
12:53
It's this declaration which you can see somewhere here.
13:00
There we are. That is the emergency declaration from the slides that now that might be a bit confusing at first.
13:04
So let me write it the simple way. Simple. Why? Let me write it another way.
13:10
I can say that what happened? So when I create an expensive number to say what?
13:14
How do I add to expressions? So you might say, well, if you've got the addition of two expressions in a prime, what do I do?
13:19
Well, I have to add I to create the representation and add a different.
13:27
OK. So any problem of both expressions and add is a constructive attempt to expression.
13:36
So the types of write, all I'm doing is I'm just mapping the the plus symbol to the constructor.
13:43
And in that case, and you can see by exceptionality, let's just let's just confirm that that works.
13:48
Oh. Um.
13:59
Right. Let's try that. So I've got to remember, I'm on the other laptop with a broken control.
14:04
It's like switching from a man to an automatic car. You can get used to it.
14:12
Right. So that's it. Happy with that. So let's let's pick an example.
14:17
Let's just make sure this is right. So what I can do now. So this is the trick. So three times six plus seven if I talk to them.
14:23
Come on. I would normally just give me twenty five which is treating the three,
14:28
the six of the seven is integers and then just using the relevant rules of multiplication and addition.
14:32
So there's a thing called default if that's called the command line ghc a JFC level.
14:36
If it doesn't, if it's usually the whole number, it's always a whole number.
14:41
I bet a pick. Is it an end to an integer or some other type of poll numbers.
14:45
So it defaults to integer as it turns out, but it's quite hard to see that.
14:49
Right. So that's what we know. Now, here's the trick, once I've defined the expenses of number one, I type that in.
14:55
I can also treat it as an expression on the GHC command line.
15:03
You know, I can force the type of something using colon cancer rather than for the above.
15:07
For example, to be an end to an integer. I can force it to be an expression. And if I do that, then the multiplications is interpreted as amul.
15:12
The plus is interpreted as an error as an added.
15:19
And let's see the three, the six, the seven somehow magically getting mapped into these constants will come to that in just a second.
15:22
So let's just think about the definition we just wrote, so I've just replaced the ad, which is on Slice with that one there.
15:29
So let's just pick a very simple example. If I've got add constant and five constant for loop, constant flow.
15:36
Well, if I just type that, it says, yeah, well, that's an expression and it prints,
15:48
you know, it uses a little show function to print that expression, but.
15:52
Uh. Yeah, that's the that's the long version.
15:59
So what's the Short-Handed version of that? Well, that is just five plus four. So if I take five plus four, it's as well.
16:03
That's nine is what I watch. What I meant was my passport, not as a as an eight, which is the same thing, or an integer.
16:10
I can force it like to be in the same answer.
16:19
But now I want you to think of that thing as an expert and it says, OK, well now what is the bottom in the expenses of now?
16:22
What is the definition of plus in that case? And it's ADT. So getting to expression's, it just wraps it with the deconstructive.
16:29
The back comes that. So that's beautiful, isn't it?
16:35
So now I can write a mathematical expression, five plus four and and how it generates the internal representation of expression as an exp.
16:39
So it's beautiful, like I get to see the representation of expressions, mathematical expressions, and of course I can enrich this,
16:49
think that this is an embedded language, if you like this an embedded language, but for doing simple calculations.
16:55
And and I can now get my hands on the representation of those expressions by by via this instance so
17:00
they can watch programme and manipulate manipulates these constructors example by evaluating them,
17:08
which is what we did on the previous slide or anything else. Put them in a strange way, would good.
17:13
So the last part of the puzzle was how do we get the const five.
17:20
Well that's what the purpose of the from integers you see when you see that on the command line,
17:24
you think, oh that's just, that's just some sort of integer type five.
17:28
It's a digit collateral stuff. I guess what GHC does is it wraps every one of those in from integer so that thing fly just right for life.
17:32
I think that's just five. What's the problem. Well actually Haskell actually does what GHC does.
17:42
Awesome. Actually wraps that in integer and what you get back depends upon the the particular instance we're looking at.
17:46
So if this is in Teja, for example, then we get the integer instance from integer, in which case I guess the mapping is idea.
17:57
And if I take five and then there will be so I can force five minutes now.
18:06
So now this is how I have to use the the eight instance from integer, but.
18:11
Oh. Sorry, I didn't mean that.
18:16
I want to force that to be an inch. Um, so I have to use the Internet.
18:22
This is from just so I like the five, which is an integer, must not get maps to an inch.
18:29
That's what this is what's happening in here. So to understand that, look at the type.
18:33
So from integer touch on slide isn't it.
18:38
So from integer that takes an integer and generates something of a typo, whereas the specific numbers are interesting.
18:43
So if I make that since I want to function from each year 2012, she actually knows how to do that.
18:54
But what it doesn't know how to do is to take any charge and generate an expression.
18:59
So for my expenses, I've got to tell it how to do it. So here this is how I've done it and I've written it this way and to come to the end.
19:04
That's a bit worrying, by the way. I'll come back to that in just a minute. More tidy this up and go back to what it was like.
19:12
So that's another way to write. To say what? You give me an integer n and I want you, first of all.
19:17
To turn the Integer N into an int so that I can run with a constructor because const only takes it doesn't take integers.
19:25
So you think, how do I take an integer and generate an end?
19:36
Well, that's what from integers, from integer does.
19:41
If I give it an eight, then I will pick the instance of the class so that from integer will have a different type to that one.
19:44
You say this is what overloading gives you.
19:53
If I see the same function, use three or four times in a programme that's an overloaded function in each of those,
19:55
each of those uses could be at a different type, just the difference in the polymorphism.
20:00
So here this from integer is integer to int. So given an integer produces an eight and now that's the correct type to give the const.
20:07
Yeah. And this one must be integer to expression.
20:15
So here's my integer and out pops an expression, so I'm using an existing sense of an existing definition from integer to build a new one, right.
20:21
So that's that's all I could do, this sort of long handed version of subnormal, but actually what I was going to come back to now.
20:34
Now you see that if I put the brackets in,
20:39
we know that this is left associative so I can turn and I'm not going to do is to turn that into a prefix function.
20:42
We have to do that one. And I can put the brackets in there as well.
20:49
And now you can see I've got something for F.
20:54
Of X equals G. Of X, and therefore I know I can cancel the option to cancel the exit so I can get rid of the oh,
20:59
he said, adding to it is I can get rid of the X in this case.
21:11
The problem, I can cancel that one and that one, which I guess I might as well get rid of the bracket now because I don't need it.
21:15
And then I've got another one, F of X equals Jay because one cancel the E.
21:24
And I get that, which is why I ended up with the definition of storage and likewise here I got something of the form F of X equals G,
21:30
so something here is F of G of X.
21:41
Well, that's the same as the composition F dot G applied to X.
21:47
So I can replace that with Dot from Integer.
21:53
Put that in brackets for the time being just to make it clear, because I need to.
21:58
And you say other stuff. All I've done is I've just I've just driven the composition definition backwards.
22:05
F g effect is actually applied to Maxwell Viceversa and now I'm back to square one again.
22:10
I can see F of X equals Gebek and I can cancel the X.
22:15
So. And again, you don't have to do this, I mean, what I've written is perfectly valid,
22:19
but it's just that is the idiomatic way of watching how serious it is to do ulvaeus cancellation of arguments through the exceptionality rule.
22:25
But you can't go overboard. As I said to you, every single function can be written.
22:34
Point three. But I advise you not to try and your programmes will become rapidly unreadable.
22:38
So you have to make a judgement whether someone started the programme.
22:42
Oh, I can say yes, it's just exceptionality. Or they can say, what on earth are they done?
22:46
You don't have to unpick this endless procession of flips and dots and so on.
22:50
Hamzy, can you please repeat what const does on this line?
22:56
Const I would consider the constructor, sure. This is little fella here.
23:03
So you what so in fact, let's nail this that's come down here.
23:10
So what is the type of cons so you can mediate and I'll give you an expression.
23:15
So it's a way of building constants into my expression type, I just have to recommend cost.
23:21
So what did I show you? Well, I showed you.
23:27
That had to add to how to add five to four what the representation of five passports, that's that thing there.
23:31
Go to. Yes, thank you. OK, so I suppose one of the things to point out is that although countries are constructed in this data type,
23:38
it is actually also a function, isn't it? And that's that's I guess maybe that's the sort of thing you have to get your head around,
23:47
is that CONSED is a function which, given the name, will be given expression.
23:54
So we think of it as a constructor. It's just the thing glues, glues things together.
23:58
So glue in it you add glues to expression's together and those anex actually
24:03
it is nonetheless a function and if it's a function I can partially apply.
24:09
Well. Yeah, so what's the type of ad that's an expression thing?
24:14
Well, that's just a function to constructability. The function has no rules. It's just to function.
24:20
So what's the type of ad const? Seven.
24:25
Well, that's and that's a function was given another expression will give you an expression,
24:30
so that's a that's a that's that's a function which if I gave that, if I if I find that to be some function,
24:36
that then I can apply that function f to another constant and it will give me you know,
24:45
it will complete the complete the argument set and then they can invoke the rule of law and it will complete completely.
24:54
Aughrim separate world and then we know how to get the result. So that is an expression, not a function of expression to expression.
25:01
What was the type of that especially special. So I give it another I get back an expression.
25:07
All right. So that might be a similar thing, so I guess the message is that when you do your exercise, you'll get to a point.
25:13
You will have already written poetry and started write your evaluation function,
25:24
and you've probably already noticed that it's a bit tedious testing it because you have
25:29
to write and out of concern and concern that you probably got variables floating around.
25:32
Then how do I just how to attach the differentiation function. I've got to write, you know, I have to specify on my function.
25:39
I want to differentiate as an expression involving variables and constants and additions and multiple locations and signs and co-signs,
25:46
whatever is quite messy typing all these things in.
25:52
Well, first first thing to do is make an X instant's number and that means you can use addition and subtraction.
25:55
And the suggestion also is that you try making expenses of other type classes so that you can use things like signs and co-signs.
26:03
I think signs and co-signs are in your lap this week. If I remember rightly, I could be wrong.
26:11
So you say tell me about sine. And so that's the finding in this is in the in the in the in the floating type class.
26:16
So you think, oh well if I can overload. Plus, so that I can give it XPS like an overload sign, so that I can give XPS, surely of course you can,
26:27
you just have to create an instance for floating because I was telling you about floating.
26:38
So this is presumably some of the operators of a floating point arithmetic and absolutely right.
26:44
So if I just have a little scanner here, we can see the function of the member functions.
26:49
So I've got some exponentiation, Logan Square roadsigns go suntans and so on, the visitor.
26:54
And likewise, you've got a fractional class. You know what's ruction?
26:59
Find out, Haskell. What all the documentation fractured.
27:03
So that's where I get the vision from. So that's great addition, subtraction, modification from none.
27:08
I've got floating port division from fractional, then I've got sine cosine.
27:16
So you see how these type classes are all linked together.
27:20
You know, there's a there's a rich hierarchy of classes in high school, too, so that at the end of the day,
27:24
you end up with all the if I got a floating point, no, I can do all sorts of things too.
27:29
I can add, subtract, divide sounds, hyperbolic tangents and so on,
27:33
that it and that's because somebody has lovingly created fractional numbers and floating instances of of double's and floats and so on.
27:38
So there's lots of lots of things to play with. And what you'll find is that the you can massively simplify your revaluate.
27:49
So your differentiation rules if you use the these type plussing. So enjoy that.
27:57
And I think it's time we had a little bit of a break so I can grab a cup of coffee.
28:02
So what I'm gonna do is I'm going to start Eyo today,
28:06
but I'm not going to go through the slides because I'm going to finish the slides
28:12
on but go through the slides on Monday because I want you to do this this week.
28:15
And I want just to plant the thought about it, because it's quite difficult to get your head around it first, believe it or not.
28:21
So I want to plant the thought. So it's got time to sink in. And next week we'll come to it fresh and then I might be doing with you.
28:28
I am writing. But Jamie, to give a lecture because it'll be kind of optional.
28:35
We might also talk about a thing called the statement, which it turns out to be very simple, similar to the way the fireworks.
28:39
OK, so let's have a break and we'll come back. So 20 to. Well, welcome back.
28:47
All right, let's make a start with IYO and then I'll let you go.
36:58
So here we are here. So we're actually at the point where this is the last topic for this course,
37:02
but there'll be a whole bunch of new and advanced topics which we'll be covering
37:10
on Thursday mornings from now until somewhere around about nine and 10.
37:14
So feel free to come on. As you know, there's a voluntary and optional.
37:19
So we're not going to assess you on that.
37:23
But there's so much more to the language and functional programming that we don't have time to teach you everything.
37:24
So you can you can get a feel for all the stuff that we've missed out by coming to those advanced sessions.
37:30
So between them longer and will. I don't know. I don't know.
37:36
I think Shonga will probably end up getting getting most in this year because I'm busy teaching elsewhere as well.
37:40
So. Right.
37:45
So the last topic is on IO and monads and so I'm not going to cover the slides, I'm just going to do this through the terminal today, I think.
37:47
So let's get back to where we were here.
37:57
Perhaps a bit of room stuff we were looking at yesterday, though, right?
38:02
So I'll show you a little bit about how iron works in Haskell and its superficial when you look at it.
38:09
So let me let me just backtrack a little bit.
38:17
So usually when you teach, when you're learning a programming language, the first thing that the textbook will show you have to do is Hello World.
38:20
So you say print hello world and hello. Will comes out and you might think, well why doesn't why don't we do that with Haskell?
38:27
Why we know why is IO the last topic in a Haskell programme.
38:35
Because we will soon become apparent and that's because it's actually very, very high order.
38:40
But nonetheless I can actually say put down and I can give it a string.
38:45
Hello, world. Type you can get the string hollow and out pops, hello, do you think?
38:51
Well, what was so hard about that? And I could even write a programme that prints other world.
39:00
So let's do that so I can say let's have a programme called Print.
39:05
Hello, World. I'm going to give it tight because I want you to start thinking about this.
39:12
So when we when we write that with what we say is that, oh, it's an art is an hour and we say it's an audio action.
39:17
It's something that does it's a function that does audio.
39:24
And the thing that makes it a little tricky is how it does the IO and why it does the IO the way it does.
39:27
In some sense, it has to do this way because it's a transparent side-effect, free, pure, functional programming language.
39:34
And that's the topic. That's the thing I'm going to focus on next week. But we can know that's what I guess what it says.
39:42
Put Strollin. Capital of the world,
39:50
and you can say that and you can come down here and you can read the programme or you can say Print Hello World, and it says hello.
39:59
Well, so what's hard? You know, in fact, I can even do I can print several things.
40:06
So. I can do I can put several things and if I want to do is control kids the other so I can put these into if I want to do more than one,
40:14
the more than one piece of it I can think of to block this as well, do several of these things.
40:28
So let's do that if I can just that's actually perfectly valid so I can say that or I can maybe a couple of things so I can say.
40:33
I can see perhaps do the helo in the world separately, so let's print out the strong helo first, but I don't want to throw a line.
40:46
I just want to print the string without the new law. And then perhaps I'll put stroke noon and I'll do the world ibbett.
40:52
Will we go and then I can say that.
41:02
And I can see it does the same thing, so I brought it down so I can do a sequence reading that I can do a sequence about IO things,
41:07
one of which is that I want to present to the world. I know I can also at times I can also read things in.
41:20
So let's now write a slightly richer function.
41:24
So how about one that does that does Somalia, what do I imaginatively and again, it's something it's basically implementing an election cycle.
41:29
So how about we read, get the use of the type of character, and then we'll look at the character back to the back to the user.
41:40
So we want to do something like, well, how do I. Well, let's first of all, prompt.
41:48
The enter a cab. So we're going to prompt the user to enter a character and then I want to read a character from the keyboard.
41:54
How do I do that? Well, what you do is you write this, you say get your which gets the character in the cup.
42:06
But what am I going to do with the character? I'm going to want to assign it to a variable, to point it to a variable so the body approaches that one.
42:12
And this is just we will see in a minute. This is syntactic sugar.
42:21
So it looks like in a Python programme or Java, you might say C equals get charged with like a method call or what call,
42:24
which gets the picture and then assigns it to the variable. C It's kind of a similar thing here.
42:30
This is actually just a special binding mechanism.
42:35
So the do block is actually syntactic sugar about something else, which I'll show you in just a minute.
42:37
So at that point we went to the type to prompt. We got the character from the.
42:43
So as soon as I got back from the keyboard, it's going to fire back into the next line of code and it's going to bind the character to this variable.
42:48
C And then how about I put Strollin?
42:56
And I'll echo back under it and then I'll just put maybe that and how do I show a character?
43:01
Well, perhaps I want to show the character with its quotes so I can use the little show function that we've learnt about that.
43:10
And it turns out there's a there's a show instance for Char which puts the single quotes in.
43:15
So that will give me the quotes, which it just so happens that when I hit the keyboard, there are no there are no new lines thrown in.
43:19
So in order to spread out the what was typed in with the next line,
43:27
I'm going to put I'm going to insert a new line there that was slightly more pleasing.
43:31
Look, when we come to run the programme. Oh, no, no.
43:36
Oh, well, perhaps have actually in the left hand side. It would help, wouldn't it. They do not.
43:42
Oh, oh. Well, perhaps if I actually write, if I could get them, I'm of the opinion function, right, that might help.
43:50
Of course, I was actually thinking Java was not when I wrote this. So this is how you doing, Java?
44:01
In high school. I have to pen the strings together before I can show them that I shouldn't be here right now.
44:06
OK, right. So let's do this. See what happens.
44:12
So it's a central character. So pick your favourite character. How about why?
44:17
So I can hit the wiki and as soon as I hit it is going to ping back and tells me once or twice.
44:20
It's quite nice to see that the Y is formatted with the Supreme Court by virtue of the little clothing.
44:25
So all this is doing is this argument simply constructing a string that will be the contents of which would be displayed on the on the on the screen,
44:31
essentially. Right, so let's just to just to show that we can do so, perhaps we'll do in addition to that now,
44:41
we'll ask the user for perhaps a line, a string, so perhaps we'll say into a string so we can show off another one of these functions.
44:49
And so now I'm going to do rather than get shot. I'm going to say get line.
44:59
And I'm going to bind the value of that to a variable. Yes.
45:04
For example, meaning the string, the contents of the line so that the line basically in order to when I finish talking the string,
45:07
I'm going to hit the return button. So the thing might have spaces and other stuff in it.
45:13
So I'm going to do that. And then having done that, why don't we do that again?
45:19
And instead of showing so that's that's how it should be.
45:26
Well, that is already a strength, so I don't need to show it, I can't do it, but it'll just be the identity function.
45:28
So I can just do that now. And in fact, because I have to hit the return button. So for ascetics, I don't need that.
45:34
It turns out I don't need that. So I can take up the new line in here. You'll see what I mean in just a minute.
45:40
OK, Guaymas, come down here, reload the programme.
45:44
And now let's do IYO again, so now six central characters want to see the style and that tells me four strings,
45:49
I'll say Hello World, and it's going to say you want to play, be good.
45:56
In fact, if I want to put the quotes in, I want to do that.
46:04
Well, I guess I could rather than just rather than just spending, yes, I could spend the representation of this.
46:09
Which will put the quotes from. Uh.
46:18
OK, so it depends what you want to what you want to pay, you can control with or without functions and other bits and pieces.
46:27
Tiphanie question. A little.
46:34
I can hear and this will show basically create a that has one of in a single character,
46:42
like I said, also if I exercise show here for I to and see, didn't I.
46:51
So that will be a string, the contents of which is how you would normally print a character which is single quote see single quote in that case.
46:58
So if I asked it to show a string and what was it I typed and I typed in.
47:07
Hello. So that will be a string.
47:12
And whose contents is the way it actually would normally print a string, which is the double quotes.
47:17
So the first character is the character. Then they get the help.
47:23
Then we get the last thing, which is the character.
47:27
And so that that is the content of the whole string, which is how you would play the contents of that is how you would normally display.
47:29
Which is why in the second time round, we got the second time round.
47:37
Oh, sorry, do I see when I said hello the second time I got the double cross round.
47:46
Hello? Cool. OK, right.
47:52
So that's really what I kind of what I wanted to do just to convince you that I was on the surface of it, very simple, because you just do that.
47:58
You stick your audio statements in a two block. There's a much there's a very rich story behind this song, a little more detail next week.
48:07
But to give you a taste for that, I'm not going to show you how to unpack the syntactic sugar,
48:15
because only then will you see why IIO isn't as terrible as it looks.
48:21
And in fact, why arguably it's even more beautiful than it looks. So let's just see an.
48:26
Right. So I want you to let me do this, let me write the same function again.
48:36
Let's go back to the simpler version I can. Let's go.
48:40
Let's just let's just shoot that person there. What I'm going to do now is going to write another version.
48:45
Which is going to work in the long hanway, so I'm now going to I'm going to write exactly the same function,
48:52
which is going to be implemented exactly the same way. But I'm not going to show you what GHC does with a do block.
48:58
So not do blog gets compiled out, popped into.
49:05
And expression, just a single expression, so do blocs are synonymous with expression, so what is the expression?
49:11
Well, it goes like this, it says, right? First of all, it's going to apply that function to what I would consider myself a bit of time.
49:17
You can't just someone can do that.
49:27
So says put straight into a character. Right now, here we go.
49:35
Brace yourself. Then there's an infix operator called Sequence, which is a little double angle bracket.
49:39
And then what I get is the next thing I want to do is to do a getachew.
49:48
So I get shot, which is just get shot in here, like brace yourself.
49:52
So get your reads the character from the terminal and then somehow presents it back to the programme.
50:01
So does that using a joint, which is that thing with rallycross on the end of it.
50:06
And how does the C how does the character get into the second?
50:11
Out into that is a function expecting a C so I can use Alanda notation lambda an anonymous function which takes the C and which does what.
50:15
But what it's going to do is to put strollin. You rented an chaussy.
50:26
I think I need a bracket that's a match to that. So it's actually unpacked as using two index operators.
50:33
The sequence in the joint is OK.
50:43
Yeah, and already you begin to see that something slightly frightening about this,
50:49
which is the the second argument of this, this operator here is a function.
50:52
So you think, OK, we've learnt about how to function. That's OK, I guess.
51:00
And so perhaps the RWC. So the idea is that Getchell goes away to the outside world, reads the character from the terminal, and then, oh,
51:05
presumably it's got to apply that Frank Ocean to the red character and that will bind the sea and away we go.
51:14
Yes. And that's essentially what's going on. But it's a little bit more complicated than that.
51:20
And it's more complicated because behind the scenes there is this world,
51:24
this world where they have keyboards and screens and file systems and networks and stuff.
51:29
And a functional programme cannot wantonly observably by the fact that world.
51:34
So I can't just go and write something to the screen and I've got to somehow change the world.
51:40
So the way to think about it by going right to the screen or read a reader's string from a file or send a message across a network or something,
51:46
then each of these operations is something which in some sense changes the world to make it purely functional.
51:54
I think of a print statement, a print command, a production is something which starts off with some initial world where the print hasn't happened.
52:01
And as a result of the print, I get back another world where the print has happened yet.
52:11
And so long as I'm careful and I chain these worlds in and out of these IO functions, it's purely function.
52:15
That's that's that's the that's the first thing to get into your head so secretly behind the scenes when you see this idea
52:23
that this is basically giving you access to the secret private access to the world was undisclosed access to the world,
52:29
which provides me with a mechanism for doing things like printing to screens, reading cards and terminals, waiting strings from files and so on.
52:37
But I mustn't observer be seen to be changing the world.
52:45
So the model you have in this, I say in the ilmenite is that the the world state, the initial world state comes into my programme.
52:48
The first IO function modifies the world state and gives it into the next function,
52:58
which modifies the goals and gives the third function and the world is changed through, I can't see the world.
53:05
There's no mention of the world in this programme, but behind the scenes, that's what's happening. So that sounds extremely mysterious.
53:11
So let me come to the virtual whiteboard and I'll just leave you with this to think about in preparation for next week.
53:19
Let's just go back to composition. And just so you get familiar with what I'm about to do.
53:25
So there's competition. We know that if you take the competition to functions and give me an X, that is the same as I'd like to write it this way.
53:33
This is FFG IREX. Right.
53:41
So there's another way I can write this, I can say after Jerry.
53:47
It is a function which given an ex.
53:53
I've changed my font university, changed my font, whatever format is so after you give me an X and I will do what?
53:59
Well, let's see, how about this? It's sort of been sort of so what it says is, first of all, you give the extra G.
54:10
That's the first thing that happens. And let me name that result.
54:21
And then what you're going to do is you're going to apply the F function to the results and you're going to name that same result prime.
54:26
And then the answer is result from this is another way to write the composition function.
54:34
So the key thing to observe is the fact that the application of G to X gives me a result I'm going to feed.
54:39
That was on the chain that was into the. And then that c that result from it becomes a result of the computation.
54:45
So the ethnology. But this is this is really simple. This is just composition.
54:53
So there's just a flow of whatever comes out from the G goes directly into the F, and that's the end of the story.
54:58
So that's easy. Now let's think about IYO. Let's think about this, all right.
55:04
So now I've got. This said, when I use this sequencing operation, these two arguments are five options.
55:09
So when when you see this. You see this thing here, that thing, and there's the operator and there's it's.
55:20
So this is a function. Well, I suppose it must be a function, doesn't it, because it's got to.
55:31
Well, is it a function? It's a function. So coming back to the question why?
55:38
But I'll show you the difference between this and composition. So this is a function now which given some well, it's given something.
55:43
And let's imagine, although we can't see it, this, you know, we just write the function after function and we just use the sequencing operator.
55:54
We can't say this, but behind the scenes, she actually says, aha, this is an election.
56:02
I know what to do with my actions. I've got to give them a will.
56:07
So income, some initial world, which you can think of as the state of the world, the state of filesystem, the state of the keyboard.
56:10
Right. So similar to composition, what we're going to do is we're going to let's see what this does.
56:17
This is going to give me something to work towards again.
56:24
First thing I'm going to do is I'm going to give the will to G. So I knew that she was a function because I kind of just saw it earlier on.
56:28
So behind the scenes that G gets given the world and the idea is, again, behind the scenes, we can't see this.
56:34
We get back a result. But we also get back a new world of coal that will be prime.
56:42
So I'm going to put a note on this. This is unseen. We cannot see it.
56:51
We cannot observe the world. And therefore, this is also unseen.
56:55
We can't see the result of that. But this is managed behind the scenes.
57:00
Besides, inside the human monad is the terminology we use right now.
57:04
It turns out that with the sequencing operation, I never need the result.
57:09
If I say put string hello world and then I say put strings and.
57:13
The first action, the second action doesn't depend on any one, the result,
57:19
their output in the U.S. doesn't depend on the result from the first action.
57:22
We've just got to think it will depend on is this this is this is the world is the fact the world has to change as a was outside affected the screen,
57:27
but I don't use the result. There isn't really a result when I just print something, is there.
57:36
So the next thing I'm going to do is I'm going to apply the function F to the world that comes back.
57:40
So as with the composition that gets fed into there, but the difference is,
57:49
is that I get a new result, which I may or may not need, and the new world.
57:55
And again, this new world is unsign. So it turns out that what I get back from this is just the same thing,
58:00
so I can write that out or I can name it or I can just simply like if I get that from the withdrawal plan.
58:09
So the way to think about this, it's a bit like composition. Well, this isn't a bit like the ones we like competition,
58:17
except there's this additional thing floating around, which is the world, which I never get to see.
58:25
So all I do is write that in my programme. I never get to see the W and the W is fed in by the system.
58:31
Then I threw in the wonder. What's the difference between that and the joint operator?
58:40
Well, the joint operator. Is this operator here and that takes two functions.
58:48
There's my phone first. In the case of audio, this is my first election and here's my second election.
58:55
Now we know that the second election. Is a function expecting the result that comes back from the first action.
59:02
So get your producers are the characteristics in,
59:14
and that is going to be the that this function is going be applied to that somehow so that it binds the sea to the structure.
59:17
So the way that works is the incomes of the world. Again, we can't see this.
59:27
We'll see how this works, but we'll get some more on this next time.
59:34
So now we're going to give the wealth to Africa. So the first thing we do is the first action.
59:39
I suppose the other difference between us and composition is that in composition we do the first in the afternoon here, we do the first and the G.
59:44
But that's just I'll see. There's a couple of hands. Let me just finish. So incomes of the world and outcomes are a result.
59:50
And a new year old, but this time when I apply the function G, I give it the Zolt.
59:58
And. Then you will. And this is going to give me a result, prime time and will double prime.
1:00:07
And the answer is then just the result from W W from the can, we can see this.
1:00:16
So now the differences you can see just with composition is the thing that's fed into the word, but also something gets fed into that.
1:00:24
So there's this additional we call it state. This is the state of the world.
1:00:35
Is this additional thing we're carrying around. So there's this change of results is just essentially what you get from composition.
1:00:38
But this is additional thing the state which we're using to generate those results.
1:00:43
So this is this is essentially what's the statement, but in the emotion of the statement, that actually they have many things in common.
1:00:49
So that's what we're looking at next week is more of that right then.
1:00:56
So that's probably started to blow your brains hands. Are you with first with your hand?
1:01:01
What's your question? I still don't exactly understand the significance of w like what does it do and why would we not be able to do without w.
1:01:05
Yeah. So this this isn't literally the way it happens, this is the way you kind of think of it happening.
1:01:16
So what we're going to do next week is I'm going to I'm going to build a mock up of the IO monad where we can see this world.
1:01:21
So you get a feel for what happens behind the scenes.
1:01:30
And it is essentially this sort of thing. So it's so but the word what is the world?
1:01:35
Well, next week, in fact, let's just have a look at a couple of slides.
1:01:39
So next week, what I'm going to do is I'm going to model the world initially as a very simple thing, just a pair of strings.
1:01:44
And this string, this is these these are the characters typed into the keyboard.
1:01:49
And I'm going to see if I can magically look into the future and see all the input that these
1:01:54
are going to take and this string is going to represent what gets printed on the screen.
1:01:58
Well, the screen is initially blank.
1:02:03
Another the programme, the second the second element of this world tuple will still get populated with the stuff that's being printed on the screen.
1:02:04
Right. So this is just a model is a mock up of what's actually of course, the world is much more complicated, as I said,
1:02:12
because it's got terminals, it's got keyboards, it's got screens, it's got networks, it's got filesystems and so on.
1:02:18
It's a it's a beastly thing. But nonetheless, it's what is true is that you talked about world through the monad, through this IO action mechanism.
1:02:27
And it's the only way you can talk to the world of the. So I guess back to the thing, they just the thing to take away is that, you know,
1:02:39
whether this world really exists in this form or whether it's this is just a mock up and whether this is just a model to help you understand it.
1:02:47
What's important is that worlds come in. They get chained through this mechanism here.
1:02:55
They get fed into the illegal actions and there could be another act, there could be other actions and so on,
1:03:02
and we just have to change the world in and out and in and out and in and out in order to give us this preferential transparency.
1:03:08
So in other words, this is a if I write this, this is a pure functional programme with an input world which produces an output.
1:03:16
It's pure. Of course, it's a complete con because it's a programme and suddenly I have created a fall that wasn't there before,
1:03:26
so I've obviously changed the world. But within the confines of my programme, it's absolutely preferentially transferred, I think, in my programme,
1:03:37
starting with a world which didn't have the file and computing and ending up with another world which does has the have the.
1:03:45
Well, that's just a perfectly functional concept.
1:03:52
Richard, your question, and I think we should probably stop, so when you say that the world is unseen, what does that look like?
1:03:56
Can't we see? Well, why can't we see the world?
1:04:04
Because if I can see the world, I might be able to change it in a way that isn't transparent and that's clearly something we wouldn't want.
1:04:06
So I'll cover that next week and explain that to you. So, you know, this like the same thing again next week, if you if you would.
1:04:15
So do you mind going over the same thing again next week before I going to go through all this again next week?
1:04:26
Actually, I just wanted to plant because I wanted to show you two things.
1:04:31
One, that I actually, as a use as a programme also is quite simply has to looks just like any other programming language.
1:04:33
But behind the scenes, it's a lot more involved because we're trying to make it functional and referential, transparent.
1:04:40
So I will be going through this again tomorrow. So if I get through it twice, if you go through a third time,
1:04:49
because I think we might be able to do keptin for an unlocked electron on statemented
1:04:53
is like monads is very similar in character to what I'm talking about here.
1:04:58
But what I've talked to here is essentially a statement. Or all will become clear.
1:05:02
Good. Right, so that we all come out of the park and say next week you're going to be writing a game of knots and crosses or tic tac toe game,
1:05:10
and you're going to interact with your users and you can you can build an arbitrary NBN
1:05:21
grid of squares and you can start from and then the first person to complete a road,
1:05:25
Collimore or a diagonal, wins the game. So you don't have to interrupt the user using just basically the sort of stuff.
1:05:30
There's a little it's a little bit more interesting because I think the exercise has some maybe type's in it.
1:05:37
And this is to do with when you're parsing a when you're parsing and see the user types in the position of the square they want to move to.
1:05:45
And then you've got to parse that. So you take a string in and generate province out or something like that.
1:05:55
And there's a syntax error in the stream.
1:06:01
What do you do when you trying to maybe say, well, yes, it's it's a just as if the string is valid and well-formed, otherwise it's nothing.
1:06:04
Which because you also used to say, please enter your move again.
1:06:11
So there are these maybe types floating around and it turns out rather beautifully that maybe they are also monads.
1:06:15
So you can use exactly this new notation as well for processing objects of type maybe.
1:06:22
So we'll see a bit more that next week. So if so, lots of things in Haskell and Monads.
1:06:28
It's not just so I was amongst the states and maybe some on that list and monads what this is about as well, believe it or not.
1:06:32
That is shorthand for. There is a moderate Monadnock centralists where this gets compiled into.
1:06:51
So let's do an expression here. This gets compiled into precisely things like that that we'll see we'll see if I don't cover,
1:07:01
that will be covered in the events and lectures because it's getting it's getting right on the edge of what we need to you need to do for this,
1:07:10
the basic part of this course.
1:07:15
But anyway, just just a little precursor to the advance programme lecture will be coming up in a week or two years time.
1:07:17
And this comprehensions is just syntactic sugar for an operation like this.
1:07:23
All right. Very good enough brains exploded. You can allow your brains to soften now and go back into your skulls.
1:07:31
Go have some fun. This week, playing with the countless Texases, lots of lots of things you can learn about type classes in there.
1:07:38
And by the time we come back next week, maybe this is some of the stuff I talked about today will have something good.
1:07:43
Right. You can go early and enjoy. Have a nice day.
1:07:50