ID: 82d6345f-9e18-4978-82b7-ae1a00a8fb00
Title: Haskell revision-20220110_101615-Meeting Recording
Category: Haskell
Lecturer: Anthony Field
Date: 11/01/2022
OK, so I've just started recording, so if you if you if you if you're tuning into the recording, we just we haven't got anything technical yet.
0:08
Just a little bit of Q&A from people about second.
0:14
A little bit of a Q&A. So you haven't missed very much. It'll come back by way of summary shortly anyway.
0:20
No year will the test be run the same way as the interim, so we can do it on my own laptop so we can have access to the internet.
0:26
Is there anything else we have to do? We know what the purpose of the infant system to give you practise that using an actor doing a test.
0:36
And so it could be exactly the same as the interim test. That's the intention. Yeah.
0:44
Good. I think I think Matthew is an old hand. One more question sorry.
0:56
Oh yeah. So if you're going to the set, solving it says that we shouldn't use filter equals one dot lengths.
1:01
Yeah, the other way of doing it, it would involve like quite a messy block of code.
1:09
And I thought we prioritised like how nice it looks over the efficiency.
1:14
So which way round is? Oh no, you don't ever use them. Ever use length in a recursive function?
1:20
Ever. Well, OK. Well, it depends, doesn't it?
1:25
It depends on the problem, but certainly not in that function. When you think about if if you had recursive function on any given, say,
1:28
an enormous list with 100 million elements or something, and the base case was the empty list, yeah.
1:37
You wouldn't say you wouldn't calculate the length of the list and ask whether that the zero in order to know whether you've hit the base case,
1:45
but you would use a pattern? Yes. So in fact, if we can frequency so I've said this, so you had to generate you had to get front of a singleton list.
1:52
Is that right? In that programme. I think so.
2:03
So if I've got a list here and I've got some non-signatory lists and some make list, maybe there's a singleton list and there's not a singleton list.
2:07
And here's another non singleton list. So if I've got that and if I name it, actually say.
2:19
So the question was, I want to pick out the singletons, so you know what it says it don't do.
2:29
Don't do that. Over XS and then filter or whatever it was, he says, don't filter use.
2:35
It said he said something like that. I want to see the things I guess I can filter, right?
2:45
So I want a function here over X is what's the function I want? Oh, will you give me one of the XS?
2:51
I want to calculate its length and then ask because the dot thing goes left to right,
2:56
goes right to left, or is it the length function gets applied first? And what function will ask whether the length is one?
3:04
Well, that's just the section. Isn't it something like that? And then then that gives me that.
3:09
Well, that's that's the terrible way to solve the problem, because if it is really big.
3:15
You know, you can't, and it's got lots of very long lists, which in principle it could have.
3:20
I mean, in this case, I guess you could argue that it's one of those problems where it's unlikely you're going to have a billion element,
3:23
a list with a billion elements, each of each of which has got a billion elements. But it's still a it's still a hopeless way to solve the problem.
3:29
You're better off using it is using a patent. So what would you do?
3:35
My ex, as I say, I want something like, I want the list of all.
3:39
Which local, might it wise, where, well, I could say wise comes from exes.
3:45
But actually, what I want is specific patent. Don't I want something like that that comes in from taxes?
3:51
And then I want a name that was something like that.
3:59
Now that's that's a beautiful way to solve the problem, because I'm using a pattern here.
4:05
This little thing, this little fellow in here that will only match a single unless you can put a name in there if you want.
4:11
But actually, I'm never going to. I'm never going to refer to the EC.
4:15
I just want to know that it's got the shape of a single industry. You get the idea.
4:20
Yeah. Thank you very much. Yeah. So this actually is a really nice I this is useful to remember that it's a beautiful way to.
4:25
So you've you've got some some list here. And this is this is if I say this is the list of monad at work, you know,
4:33
if you came to the tables by giving lectures and I'll probably mention this in the audio lecture these lists list is they're actually more that.
4:39
I mean, this list of monitor what's actually going on here is that this this thing is shorthand for a monolithic expression.
4:46
We don't worry about that. It's a list competition as far as you're concerned.
4:53
But the beautiful thing about it is it's built into the the framework is the ability principle,
4:56
the pattern just here in the same way you can put a patent on the left bin equals,
4:59
you know, when you say after-effects because they did it, and that's the definition of a function.
5:03
So this thing in here is always think of that as a patent.
5:08
Think of the whole the western side of the patent if you want, but particularly that's a patent.
5:10
So when you define a function, so anything on the left of Bernie because of the patent, also anything in here is a patent as well.
5:14
So I can play any part in that. So as long as the types. The patent structure matches the type.
5:20
So that's what I meant by that remark. OK, well, we carry on.
5:27
This question is now is this is that are these old handsome Shenzhen is?
5:34
Well, it's not on hand. Actually, this really make me getting confused because I take a look how this I found all this part of this,
5:40
this part is not complete and it has somehow filed right.
5:51
So it's kind of like a users of Momo not failed or something.
5:56
Yeah. Yeah.
6:02
So what happens is this gets compiled into an auxiliary function which has got patents, which says that if the patent matches this structure,
6:03
then do just you just pretends that the list itself, otherwise, it'll otherwise it'll fail.
6:13
So, for example. But you won't feel as if example, if this doesn't have any.
6:19
You know, this doesn't happen as well. There aren't any. Oh, well, if I got my clothes on right, then wouldn't.
6:27
My deputy and I'll.
6:36
Yes, I do. I think I meant that.
6:43
Right, OK. Yeah, so so he just says, go through the list and you said, so what?
6:47
You have to look at the cut, the the way this will get compiled. Well, I could probably construct the sort of code.
6:54
So it doesn't actually it doesn't work with an air of don't think of that as a pattern match, which can fail and we'll give you an error message.
7:00
It just says go and look at each of them. And if you know, if it if it matches the pattern, then that becomes part of the solution.
7:08
If it doesn't match, the pattern doesn't become part of the solution. So if none of the patterns match, you just get an empty list back.
7:13
So they're like inside the two block. It's still going on fields because you normally define part in it to be like.
7:23
Like, if it's not fair to the parties, I'll be felled message.
7:36
Look, if you wanted to write this, if this concerns, you could say you could have a function.
7:41
Call this singleton, which says if you give me a singleton less than the answer is true.
7:47
Otherwise, it's singleton. Anything is is false.
7:56
That's a perfectly good way.
8:02
You know, if you voted this way, actually, this is fine because what you're doing there is you're defining a little a little, a little predicate.
8:04
It's a predicate. It's given this gives you true or false.
8:11
And then once you've got that, OK, so you could then say, filter the singleton, but what you're not doing is you're not using the link function here.
8:14
Oh, so I need to recharge my XS, don't I? Because I'm just there.
8:24
It's if I say filter filter is singleton is a singleton singleton over XS, then I get the results.
8:29
So that's a perfectly good way of doing it if you're talking to you.
8:40
But that's essentially exactly what gets what the monastic code gets compiled to some is something like that.
8:43
Which is better that function or the one that occurred? I don't care, either.
8:49
You can argue that the management of Kerry says, Oh gosh,
8:57
there's this absolutely wonderful thing that you don't get to learn about straight away because it's
9:00
the sort of second level feature of high school is the idea in the patterns in in this comprehension.
9:04
You could argue this way is possibly clearer because it makes it completely clear that you're saying,
9:13
go through and give me just pick just the singles unless there's a pretty good argument you're using the right function,
9:17
you're using a filter or you could use a list comprehension, except give me the list of all axes.
9:21
Well, or wise, you know, you can always write a filter using a list comprehension.
9:26
These are good questions. You know what's what's best? So you could say wise comes from what is I should really call excessive, shouldn't I?
9:32
It's a list of lists so conventionally in has copies of idiomatic way of naming.
9:41
A list of list is to say X X is, but I've got to stick with it for now.
9:46
So it was said this doesn't fit right, does it?
9:50
Because if the thing on the left should be a thing on the right should be a list of names and the names,
9:52
the quantity, what I'm just going to do that I'm just going to do that.
9:56
So that's a list of list of X's list, the list of numbers, right?
10:02
Right. So there's my excuse. And what am I going to say?
10:06
I'm going to say is single 20 these singles and waters and then I get the same answer.
10:10
And these are all perfectly good. You thought you might look at the length of the code you've had to write?
10:19
You know what I wrote? That's well, that's certainly got any characters in this.
10:23
This one's got more. So maybe the filter is better and sometimes it's the other way around.
10:27
Sometimes when you're writing a map, you know, we're going to put a flip in there somewhere and you end up writing more.
10:31
But actually, from the point of view of, you know, from what you expected to know at this stage,
10:35
you know, having done an introductory course, I mean, any of these solutions are completely fine.
10:40
But as soon as you please don't write me long, either try if you can try to avoid writing long winded recursive solutions,
10:45
when it's a map, when it's a filter, when it's a fold, when it's as it you to spot, that's one of the tricks.
10:51
Well, we look at up examples this morning.
10:57
Try to find examples where you can just use one of, you know, I'm here, you can see what I've got is import.
11:00
I've imported these two modules here and they're packed full of really useful things, including some hardware functions as well.
11:05
You can use. OK, so Russia is an old hand or a freshman?
11:15
No, it's a new one. I just wanted to ask. So for example, if you have to define a custom look, a function, can we just do from just look up?
11:21
Yeah, that's even though that short is the goal. Yeah. Yeah, yeah, yeah. Yeah.
11:28
If you find something in getting you to answer to produce solutions, which you can find in the obvious modules,
11:31
and if we if we just something we've missed, you can just you can import it and use it, that's fine.
11:39
Generally speaking, you can't. Yes, it's so obviously look up.
11:45
If you if we said, please try to look up, you can write just what's how do we look it's from?
11:48
If you want to buy the free version, was it free from just don't look up?
11:54
Yeah, well, if that's my well, I can, I can call it look up and I can say, look up.
12:02
Three. And what have we got a table of tiers?
12:10
Something like that? Yeah, it's absolutely fine.
12:18
So like, so what I really want to ask is like, can we use functions in these modules that really make the code like a one liner, even though?
12:22
Oh yes, I think that's the art isn't, isn't it? Isn't that what functional programming is all about?
12:28
So I want to try to find a nice little hold a function or something that somebody else has written.
12:33
And then then instead of writing 10 lines of code, you do it in one line. Yeah, absolutely.
12:37
I mean, you can go to extremes, we had this discussion on AIDS, didn't we? You know, you can say, well, what's what's is?
12:43
Is this the owl operator something you think?
12:48
Why please don't write programmes with that in it? Because it's the type of thing.
12:52
That's not the owl, actually, but it's something that little sort of Typekit does have a use.
13:00
And that no, I mean, as I said, you can you can push these two extremes.
13:04
OK. Yeah, so have a question on like if it's possible to like see if the output of some function matches,
13:10
one specific like form, so like pattern and then to use that pattern to do something and let her guard.
13:23
So example like you have some function that returns, some thing that's packed into some unknown to pull.
13:30
And then you try to say, OK, if it if it has this form,
13:39
then unpack that to pull and then take those things into this function, otherwise just return nothing.
13:42
Or like otherwise, like A. In the second guard, have the otherwise be like, do something else.
13:47
Might your best if you post an example, and that's the sort of question, maybe if you put it on ED,
13:57
actually, I mean, I could we could interpret it in the channel, can cut and paste it.
14:03
And what's the principle? Well, let's see.
14:06
Let's just there's a there's a possibly different question,
14:12
which is what if I've got a function where if I see something some pattern or something, I want to do this.
14:16
I want to generate this. And if I don't see that button, I want to do nothing.
14:23
Then the thing is, how do you code that in Haskell? When you're in a procedural language, I guess you just don't.
14:28
You just pretend you just don't do anything. But in Haskell, you've always got to return something before ActionScript turns and they say, How do you?
14:32
Well, that's what maybes for. So if your question, I don't know your question was that.
14:38
But as we're talking about it, if you've got a function which either does something or does nothing, wrap it up in a maybe.
14:42
And if you say nothing, though,
14:49
it didn't produce methane and you're consuming function within use functions like the media function from from from digital, maybe.
14:50
And what's the you know, this is in the notes these that these are really hand. I was going to do this anyway.
14:59
This one, these are handy things to have at your fingertips. And if if, if it succeeds and it's wrapped in adjusts,
15:04
then I just want the thing that's wrapped in the just otherwise the special case of bits and nothing.
15:11
Then you could use the from maybe function, which which which would do that.
15:15
So it's it's probably worth reminding yourself about these things. Otherwise, you just have to write your own functions that do the same thing.
15:20
And that's a bit tedious. Now, I think your question was slightly different.
15:26
So maybe the answer to your question is, well, past the thing.
15:32
You've got to a helper function and then patent much in the helper function or insert a case statement because case statements,
15:35
case expressions can have patterns in them. Yeah. All these are completely fine.
15:42
OK. Yeah, I think it's um, yeah, I think so in that sense, it's like, I think someone's trying to put something in Chuck.
15:51
There's only so many things I can actually get on my screen at the same time,
15:59
and I didn't know if someone if you see it, if you see an interesting chat thing,
16:03
pop up and I'm not talking about it, then put your hand up and briefly shout, Shout it out and I'll see if I can address it verbally.
16:07
So that's your question. Kyle, I think you've got a question as well.
16:15
Yes, yes. Can you hear me? Yes. OK, so I saw enough for some past papers, you are giving out a little, a little notes for us.
16:21
That's a before. Are we going to have to this board exam as well?
16:32
I don't think so, because I think this this session will be much we might change our minds.
16:35
But I think this is this is what you need to do, this sort of thing.
16:41
I'm the one where I thought it was really important to do that was the one on automata.
16:46
What was that called? It was well, actually, I've got it here and there.
16:55
Which one was it? The labour transition systems one Yeah, this was a this was a this was really hard.
17:02
And yes, we absolutely.
17:09
And it required getting a head round something which you'd never seen before to do with these automata and processes and so on.
17:12
So what we do is we we could we gave students a two or three page that basically, I think, began the introduction to read overnight.
17:20
And that was a big help. Actually, people did quite well in this test, somewhat surprisingly, because it was really hard.
17:26
But I don't think we need that here because I think by the time we get to the end of this morning session,
17:33
you should have it your I think tomorrow's test just needs you to know about things you already know about,
17:38
but you need to practise them and reinforce those ideas. And we'll get to those before the end of the session, which are month we start the session.
17:43
But this is this is fun. She teaches at another. I think that's a new question, isn't it?
17:51
Yes, I set up to do the only computer during the Christmas break, but I'm not sure if everything works as it should.
17:56
So would you be able to set up a mock assignment on GitLab so I can check everything works fine?
18:03
Who else, Constantinos, that question? Thank you.
18:12
You know that you can. It's entirely up to you can you can always say, Well, no, can you?
18:19
Yes, you can. You can just association to love machines.
18:25
I think if you wanted to, if you wanted to to sit essentially in a virtual lab, you could do that.
18:27
So let me get Constantinos. I've got three. I got three questions already for him.
18:35
So if we can sort this out.
18:39
Evelyn, how could you say which of the exams it's like most comparable in terms of difficulty or are you can you not say that?
18:40
And so the difficulty, I never know, really, because there is one I thought was really,
18:53
really hard and people did really well in it and there was one I thought that was doable and people didn't do quite so well.
19:00
Yeah, I mean, when I put these little stars, I'm completely guessing, I think.
19:09
But I think what I can certainly then say with confidence is that this one, the binomial heaps one.
19:12
Was the easiest, I think that we we don't.
19:21
And what was the most? So I don't know, I don't know until, you know, when we mark you it gosh, you know, they do, they're all doing really well.
19:26
Or we might say, Oh gosh, it was hard when we thought, in which case you revise it?
19:36
I don't know. Let me. I would say probably something like what did we do last year growth and.
19:41
Yeah, I think this might be about the same sort of difficulty, something like that or.
19:53
The solving, I think was going to give that was probably once, yeah, the solving was it's probably between one and two star,
20:00
but it's one of those exercises that pulls out so beautifully in high school.
20:08
If you know, if if you know your higher order functions, the solution is just absolutely glorious.
20:11
So that's why I think I probably gave it one star. Well, actually, it's probably harder than solving.
20:18
I think this is one and easier than the label transition system, which I think is probably the hardest.
20:22
Well, I can tell you what was the hardest, because after having having having having set the test and having gone back to to prepare this web page,
20:33
I actually found a bug in this model solution. So even we didn't get it right.
20:44
It was extremely subtle. And you know, Stuart, whatever, whatever, it's come across the bug, but you.
20:52
All right. So it is.
20:59
These are difficult questions people ask if you ask if you ask me that question after with it and I'll give you a more accurate answer.
21:00
And. Chin.
21:06
I found the interesting way to soak the part in that problem you called for and the way I do, I'm doing it.
21:11
I have already put that on the test.
21:20
So basically, I'm pulling that using the least comprehensive and useful, as you told before, about how I have failed or not.
21:22
So it's like if you gave a wrong, wrong part about just return, and it is to say if you give the right part, they will return a single to.
21:31
OK. OK. Yeah. I mean, there's as I said, there's a million ways to do that.
21:40
Can't see the chap. There's a million ways to do these things. I mean, I think that the messages don't like 10 line programme using pattern matching.
21:44
If you can watch it in one or two using comprehension or something else, it makes, it makes you also, I mean, it's got to be.
21:52
As I said, just know that you don't don't pick a cryptic, clever, ultra clever solution, which, you know, we have to stare at it.
22:01
Oh my gosh, are they using a composition of the owl operator and some other ghastly thing?
22:08
And then, oh yes, I can see what if, if we have to spend five minutes reading a.
22:12
You know, question three on a 10 question paper, then there's something wrong. You're probably going to be losing marks.
22:18
What does that say? Just got a strange message on my teams when, Oh, I see what's going?
22:28
Right, so let me go back to what I was so foolish to think of things I thought we could talk about this morning.
22:36
I go back to this. Oh. Let's see.
22:43
Let me just first do some basic functions, so you'll get these and there might be some other.
22:49
I think these are the two that we we normally bring in.
22:54
I think they're in the test on Wednesday. So functions you might like to practise within the.
22:58
Let's see. I mean, have a rummage around there.
23:06
We're not we're not going to ever expect you to know the obscure ones, but I mean these these these you've seen things like salt.
23:09
Yeah. So don't write your own sourcing programme because you don't have to do that. You probably 100 times anyway.
23:15
There's one in data dot list, so use that one. If we ask you to sort something just just to know something, something like that.
23:20
So that's the first thing, and that might be useful. We might need to sort things.
23:31
What else have we got? You know, so something we'll be using today think this morning or this afternoon is his break.
23:36
So I guess I guess maybe, maybe one thing to you will need to know.
23:43
You'll need to know your higher order functions in your partial applications and that sort of thing.
23:46
So Break is a function. What does breakthrough so says, Well, let's just do the simple one.
23:50
So split at this bit that says, you give me a list.
23:58
And split a particular so we were actually going to even even write this one because it straightforwardly,
24:04
but you can do this in one pass, but as you know.
24:10
But if I if I pick a pick and index to split out, it gives me the first four elements and then the remaining elements.
24:13
And if I if that number is bigger than the length of the list, then of course I get, you know.
24:19
And if it's zero splitting it, zero is the opposite extreme. Well, that just gets me.
24:25
Is it going to be? The thing is, they split up. You know, it is. You know, there's another one called break.
24:30
So a break is the higher order. So this sort of thing that says, well, rather than spitting at an index, I'll give you a function.
24:37
When the function seems to function gives me true. That's the split point. So you can say, well, let's try equals one.
24:41
So I'll get through the list until I find a one. And then that's going to define the split point.
24:48
And if you've ever coded quick thought, do you know how quick? So it works if I give you an unordered list doesn't.
24:56
It's not a particularly interesting on this, but it's like more interesting on I would.
25:03
List X is my white coat the whole thing, but it's one of the exercises you.
25:06
Something like that. There's an unknown so you can just see across sort of the way.
25:14
So I I don't know what I mean, what the sorting algorithm is, probably merge.
25:21
Sort this built into the library here. But the quick, always one of the classic ways to do what is quick thought says, Well,
25:26
let's pick a number like four and we'll take the List X's and we'll we'll oh no, I'm guessing I'm getting slightly ahead of myself.
25:32
So let me just finish the bracket. So, so yeah.
25:43
So so it's a break. So break is a higher order function, isn't it?
25:47
Because it's type? Is this so the first argument is a function?
25:50
So you give me a list of A's?
25:56
The first item is a function which given one of these gives you back a ball so you need to be good at Harvard or functions you need.
25:58
You need to know how it functions. Right. So there's what I was going to tell you.
26:02
There's another one called whilst we're on sorting. There's another function called partition.
26:06
And this turns out to be really useful things we use. There's another one called What's the other one?
26:14
I use a lot in the crossword solvers sequence. Mother, we realise it's Wednesday, but this might.
26:19
This was a politician again takes a function and this debate and it's going to not just different.
26:25
Define it. It's going to go through the whole list and it's going to partition.
26:31
Listen to two subsets or two syllables, then which for which the predicate is true and then to which the particular spells.
26:35
So if I've got a list like that on, I can say partition that list now, what am I going to partition what?
26:42
I'm going to pick a function? So let's say. So this is how quick sort work.
26:51
So what do they say? Four six? A lesson we could offer but could be my partitioning function.
26:57
This would give me back to list those elements less than we could form those, and it's bigger than four.
27:02
So the way quick sort works is, of course, within quick thought.
27:06
The left list, quick thought, the rightness and then just concatenate the two together using plus plus.
27:09
So the structure of quick thought, it says something like defunct actually.
27:15
See if I can get you right quick sort of x.
27:19
This is um, well, I'd have to define a base case, but basically you do something right and so you do something like that and then you feed you.
27:21
Q Source. I'm not going to write the whole thing. You can do as little exercise,
27:31
so you can use X is one appended to Q Salt X two and then you say something like where X is
27:34
one x is two is a new politician and you'd have to choose what what the partition there.
27:42
There's a lot of people as well. Perhaps they might pick the first element of the list, you know, like this, this one here, the four,
27:50
or they may look at the first three or four and take the million of that or pick a random element.
27:56
So this is called the pivot with quick thought.
28:00
The options to choose a good pivot and a good pivot is one which generates two lists of approximately equal length.
28:03
So there's all sorts of strategies for good pivot. So you'll be studying this next term when you will this coming term.
28:11
When you do, we're already in this term. When you look at algorithms and things like me, it's going to be talking anyway.
28:16
So quick, what's the classic algorithm for the sorting? And it would use this this partitioning function.
28:23
So have a practise of politician. On my list. What else is lying around?
28:28
So sets often come up. So a set is a list without duplicates.
28:34
So you know that if you got a list like that?
28:39
Well, yeah, I can turn it into a set point. This removing the duplicates is a functional nub that would do that.
28:46
I think I've got a fairly neighbours business square.
28:51
It should be and get again because you can just sort these you and then you can go through picking up adjacent elements,
28:53
which are the same as it's the same respect. But once you've got a set, if they've got two sets, one two three, that's a set.
28:58
And here's another one three to one for something like that, there's another set.
29:06
I set a list for that without duplicates. So the question is is if if I if I wanted to form the union of those, well,
29:14
I wouldn't use that function without because it's got duplicates in it because I've got two to one come up twice.
29:21
But what have we got lying around that will help in the.
29:27
In the days who thought this thing was a punch called union, which actually do the same thing without Typekit.
29:31
So that's another thing you might find. Right?
29:37
So the other thing? Next thing on my list is is scope.
29:43
I guess we look at the scope. So, you know about nested functions.
29:47
Let's just say let's go through the slides. Where was the somewhere we wrote?
29:56
We find the square root very ethnically. Right.
30:08
So I thought I'd pick on this slide this, but this one, this is the square root function.
30:16
What did we do here? Well, we had a square root function and the answer was we want to calculate the square root of X, please was the question.
30:22
And so we use this iterative algorithm where we give them one approximation initially a zero, which is over two.
30:31
It turns out we can choose any initial approximation. So it's not zero. And then you from Gimnasia are you generated A1 from the A1?
30:39
He generates No. Two and you keep you keep generating a successive approximations until you're happy that the approximation you've got is a good,
30:47
a good approximate, a good approximation to square root. And then you stop. So this is the function that does it.
30:54
And this thing here is helper function is doing the iteration for me now.
30:58
I couldn't I couldn't do the iteration at this level because I need always the X because I'll use the X in the in the base case.
31:03
I've got to know whether the current approximation squared. Is close enough to X that I can stop.
31:12
So I always need the exercise, so I can't I can't go around trashing the X by rehearsing on,
31:20
you know, changing the X into an X over two or some, I suppose some, some successful approximation.
31:25
So I need the X intact everywhere. So I had this helper function, which was doing it right before me.
31:30
I primed it with X over to my my zero, if you like. And then we went from zero to a one two eight two two by three using the proper function,
31:34
and we terminated when this condition was true and we went away.
31:43
Anyway, the point about this is that I put the helper function inside the inside of the square root because it's only useful as a helper function.
31:47
I'm not going to use square root prime outside of the function.
31:57
And so you'll notice that, in fact, I think I wrote a version of this.
32:02
Sure, you made notes, but I'm very sorry.
32:10
I wrote a version of this, so I probably wrote something like we had.
32:15
Was it cool? Did I call it? Oh, bear with me, my hockey.
32:23
I put it square. So we have the square root function.
32:34
And this took an ex and did some stuff to it.
32:41
Yeah. And what I actually did was I called a square root prime function and I gave it X over two.
32:44
Of course, I want you to put spaces in. So and then we said, Well, what a square root of a two.
32:54
So we said square script, square root prime. Well, what a square root prime two.
32:59
Well, that takes my current approximation, which is initially a zero, which is actually the two and think generates and it does.
33:05
It does whatever it has to do, blah blah blah blah.
33:11
And somewhere in here, we refer to the extent we. And so this is a nested function.
33:15
All right. And the nested function just so happens the nested the function needs to know this x because there's X things like it's fixed,
33:25
you know, it's Oh, I'm going to Typekit the square root of 71 place.
33:32
The 71 is always fixed, so every time I need to look at the base case, I need those is a square close to 71 yet and if not, carry on and try again.
33:34
So we say, remember what we said? We said this x was in scope everywhere inside the body of this function,
33:42
so it wasn't necessary to pass the X in to the helper function because it can see it anyway, because it's a nested function.
33:48
Now think what I might have done in the lectures was I said, Well, why don't we start off by this at the top, most level?
33:56
And you can do this, and I guess the point about this is that all these functions do the same things you can choose.
34:04
You can choose.
34:09
But if I left it to the top, most level, you just got to remember that of course, the X isn't in scope anymore, so I've got to pass it in.
34:10
So perhaps I might pass in here.
34:18
And then on this one, all I have to do is that and that's probably the best, but that's probably what I started with was something like that.
34:20
And of course, you know,
34:28
down here in my recursive call to square root prime because I would have had some square root when I'm going from one approximation to the next,
34:28
you know, the X, it's the same X that has to get passed in.
34:40
And then I've got some expression here, which would be the the next approximation, and that was the nature of the iteration.
34:43
So the point about that is scopes are in the notes. There's a discussion about scope.
34:52
Which was somewhere over there. It was this is a really bad example, of course, because I think what I was taught,
34:57
the point I was going to make is so they appointed the slaves to teach you about scope and it's called static.
35:06
Scopes called lexical statics can be interesting. The scope is to do with the layout on the page if you like.
35:13
It's it's a syntactic feature language. So. So what did I say?
35:18
I said that X and Y here these two. These two argument variables were in scope everywhere in the body of this function.
35:22
So everywhere in here, imagine drawing a box around the body of the function anywhere inside that box, the X, I can use the X and the Y or.
35:30
Yes. If I wrote X or Y, then then that is this that is the scope of X Y.
35:40
So there is an issue. What if there's a name wasn't there? You remember this?
35:45
And the point of the exercise was, Oh golly, I've got a local variable here y, which is the same as the name of the argument y.
35:48
And then we had this discussion about, Well, if you've got to choose which ones should Haskell choose and Haskell chooses the innermost ones,
35:55
you're actually what it does is it picks that version of Y because y here is also in scope in exactly the same part of the programme.
36:01
Y is in scope everywhere here, just as is the X.
36:08
The argument X of the point is in scope everywhere that so this is this this this example was contrived to tell you what to show you.
36:12
What happens if you have nine classes because you could start making decisions, so try not to use for of them something there are.
36:20
Sometimes there are good reasons that name clashes. Actually, it's it's called shadowing and sometimes there's nothing wrong with it.
36:25
But generally speaking, just just spare a thought for the person reading your code.
36:31
And are they going to be confused if you use the same name twice?
36:37
Why so, so scope is really important in scope enables you to define, you know, things like this,
36:42
these variables or possibly even functions as we see in the square,
36:48
which refer to something in and outer scope, as we saw with the square root planting.
36:51
Right. So I thought maybe we should do. We shouldn't have a result or not.
36:58
Right, so let me just I'll leave that in just a comment that I might be useful later on.
37:04
Dummy, there's a question you've got to do that now. Yeah, just two really quick ones.
37:12
First of all, with regards to errors, if they ever ask us to calculate an error and they're not specific,
37:18
should we calculate the absolute error or relative error or the answer is always to use the relative error?
37:24
OK, that's that's always the right thing to do. OK, thank you.
37:31
One. Do you prefer? Or is it advisable to use the net?
37:35
And I'm like the one we saw earlier or the square root you've written here.
37:41
So I actually think the question was is is it better to lift the thing to the topmost level or is it better to nest it?
37:48
I definitely nest it in this case. OK, because you know, why would you have a why is it useful to have a function,
37:57
which is the thing you're trying to at the square root of and the current approximation? I mean, that's useful for the square root function.
38:03
It's not something that you use. I'm not going to get a GHC prompt and start using square root prime online.
38:10
So that's that's that's the reason.
38:14
So I think this this is wide nested functions are handy because it can't they height you hide them from the outside world.
38:16
I don't want this. I don't want the outside world to see these functions. So this the scoping rules kind of hide the function, if you see what I mean.
38:24
OK, but this one back put it in back in the workforce.
38:31
So I've got something like go back to that.
38:38
So that can't be seen from the outside. Well, on the other advantage, of course, is that X is in scope anyway,
38:41
so I can just get rid of that argument and it will just work beautifully so well if I can.
38:46
So I took I need the X, but that refers to the outermost X, you see? OK, thank you.
38:51
Yeah, that's good. Now this is a slightly in you think.
38:56
Well? That's wonderful. Don't do this in Python, because it doesn't work.
39:00
That's a long story. Python is a thing called dynamic scoping, and it's just a very, very serious bug in the language design.
39:08
This is why one of the reasons why Python is a dreadful programming language.
39:18
There are lots of reasons why Python is a wonderful programming language,
39:21
and there are quite a few reasons why it's a dreadful programming language, and that's one of them. Anyway, go away and read that on your own time.
39:23
It's not particularly relevant here because we're in still doing Haskell programming, right?
39:28
So that's. That's that, and it was like it was going to show you I was going to say, let's let's do something else on scope, so let's see.
39:33
OK, supposing I like this function, I've got a function of X.
39:44
So from what we know about scope and nested functions. Supposing I were f of x equals.
39:51
Let's say you just want me to find a production, so I say of Y equals X plus y and supposing I just want to return.
40:00
Gee, that's completely fine. What's the type of that, in fact?
40:11
So I say, well, if I ask for the type of that was, the type of athlete says it's a no way to age way,
40:19
so I could freeze the ATP and I could give it a type signature. Oh, somebody said, should I put type signatures in or should I?
40:26
If you put the tights, if one of the reasons I might want to put a substance in his because I really do want this function to work on it.
40:34
And if I don't say that, it'll assume it's not my way to wage weight, which is perfectly fine because it's preferential.
40:40
If for some reason I really do want it just to work within it, then I would put some signature in there.
40:45
And then then I get that. So do you think, okay, what's the value of f- of three say?
40:54
Well, a three is a function, isn't it? And for three is a function, so.
41:00
So let's just think so this oh, I see how you remember this and of course, the world of Curry Haskell is a whole the language.
41:09
So it's it's curried, which means that you can partially apply a function and give it fewer arguments than it's expecting.
41:15
So if you look at this type signature here. And it's not obvious when you look at the definition, this is a function of two arguments,
41:23
actually, which generates a third, which generates a result of something.
41:30
So give me two minutes, I'll give you a third one, which is the result. So you think, okay, so think so.
41:34
There's there's a work called Arrietty. What is the arati of the function? The arrietty of that function is to write an unquestionably.
41:40
So then you look at the definition of the function.
41:48
And it starts to get rather scary, doesn't it, because you think wait a minute, if this point is rising too, why is it only?
41:52
Why is there anyone else on the left hand side? Well, the answer is always it's because you get back a function, isn't it?
41:56
So it's really, I think, second piece of advice this morning is go on and refresh your memory on functions and higher order functions and
42:03
partial application because the only way it has to you can build a function is to partially plug an existing one.
42:13
So if I come back to the command line in here, so Haskell's higher order, so if has a meaning, what's the type of this?
42:19
Well, that's just a function from end to end to end.
42:25
So f is a function of parity to you.
42:28
Give me to inform and give you a third. All right.
42:32
So but that means I can partially apply, yes, if I give a three, what's the title of that?
42:36
Well, that's a function. OK, so you've given me one of the so I get back a function.
42:42
Of the other one, so in fact, this type signature here when I say that.
42:49
But let me let me go up and do it in here that that bracket so I can put the brackets in if I want.
42:55
This is this might be really helpful because bracket thing in funk,
43:01
bracketing in tight works, the right because function application is left associative.
43:05
We've covered that before. So um yeah.
43:10
So that's again, what is the type of bet for three? Well, that's just so it's so it's the type of f is, is that?
43:16
Now, of course, when it renders the Typekit, remove the brackets because it's the same as this thing up here because these brackets are optional.
43:21
So you're looking at that signature, you can sort of see the white hub partial application works, can't you say?
43:29
Oh, see, f is a function of getting one end gives me a function.
43:34
It's twins, so it's another way of function waiting for another int, which will give me the final result, which is sense in here.
43:39
So although F has got Arrietty to. Because it needs to it's to calculate the third.
43:47
It does nonetheless take its arguments one at a time. This is the proposal application thing.
43:54
So so for three, this thing here is a partial application of this name.
43:58
In fact, this. Is a partial application of that is a partial application of.
44:02
Well, I've given it no arguments.
44:07
And that's the partial application before I've given it one argument, and I can complete the application by giving it a second one, whatever.
44:10
And what's the answer going to be? It's 9:00, isn't it?
44:19
Because and why is it nine, because if I put brackets around that, which means the same thing, obviously whatsoever for three out of three.
44:24
Is a function g where G of why is exposed, what so you can sort of think of this as being a f of f effect?
44:35
Yeah. So here's the tricky thing, isn't it just as with the square root example, here's a nested function.
44:45
It refers to something which sits beside it, sits in an outer scope, this isn't defined inside,
44:53
it's defined up here, but it's OK because it's still in scope, isn't it?
45:00
Because the scope of that act is everywhere in the definition that function so.
45:04
Oh, I see that X in there is just the X that I passed into F. So you can sort of think of EF three,
45:08
which I've written that it's sort of like it's a bit like, Gee, where I've got to remember that every time I see and Malcolm was right.
45:14
This is not Haskell syntax, but I said, Gee, well, let's remember that X equals three.
45:22
Yeah, and I give that function with the six year. So that's that's the way you can see that the way the partial application and scope go hand in hand.
45:27
So if you're watching functions, if you're watching nested functions with a bear in mind the scalping rules and you've also got a bear in mind,
45:40
that something that might be useful to you is if you've if you've written a function bit nested or not,
45:48
and you can possibly apply those functions and there's partial applications will always have a meaning.
45:51
So you can do you know you can do things like Map B C mapping the mapping a partial maps f of three.
45:58
That's the function, actually, if you unpick this, this is the function adds three things, isn't it?
46:05
So if I give it three, four five, then it's just going to add three to each of those.
46:09
But that's exactly the same, you know, I can't.
46:15
This isn't valid syntax, but you know, it's it's mapping G where X equals three, and I can't write that.
46:17
But unfortunately, it's the same thing.
46:27
Yep. Good. So that scope? Kobe wanted to say about that.
46:32
So I thought, well, we'll have a break and I'll fire up the the.
46:41
One of the lab exercises also be useful to look up this morning,
46:47
and you can go away and think of some questions to ask me and we'll come back and revisit this and let's have a break until, say, 10 past 11.
46:51
So you've got seven minute break. All right.
46:57
I'm back, I have just closed this thing session for the you just check that it's the microphone still working hand up.
57:45
Thank you. Very good. All right. To carry on.
57:55
So I thought it might be useful to look at the something like this.
57:59
I could have picked any number. This is the calculus exercise. She should be able to see so if I go.
58:05
Oh, was it gonna? Hang on a minute.
58:15
Oh, yeah. OK, we're back. Yeah, so there's a data type here which is representing expressions.
58:25
What have we got? Right, so there's a there's a set of primitive functions, this is an expression language,
58:31
and what you were asked to do is to implement symbolic the differentiation over this type.
58:40
So let's see, we've got some primitives.
58:47
Which turn out to be some of the promises you get in the in the berries high school type classes, both in classes and our expression type was what?
58:51
Well, it can be a constant with constructive balance, so that's a double.
59:03
It can be the identifier of a variable or it can be the application of one of these primitives to a list of expressions.
59:07
So in general, these things could have in this case has got one argument.
59:16
This has got two arguments and so on. We could have functions with three or four or five arguments, depending on what the primitives are.
59:21
So in general, we solve this problem here by having a list of expressions here.
59:27
I guess we could have had a unitary operator which takes the function in a single expression or a binary operator,
59:31
which takes the function and two expression. But actually, we've just we've just gotten away with a single constructor here.
59:37
There's always many, many different ways of doing the same thing. When you're designing these data types.
59:42
So why am I showing you this? Well, I guess really just for this.
59:47
If I if I asked you to write a function over this data type, which, for example, gave me,
59:52
I'm not going to run this function, but I'm just going to show you how it would work.
59:59
So supposing I wanted to count that function, which generates the names of all the variables in a in an expression or programme.
1:00:03
So let me just tell you that that takes an expression. It's going to generate a list of identifiers and identifier.
1:00:10
And here is a string, of course, that you know there could be that could be a type synonym, you know, name equals strain or something.
1:00:16
It depends on how the exercise is being set up, right?
1:00:25
So that's what we're trying to do. So in this very simple example, we'd say something like, well,
1:00:29
what are the what are the what variables are there in an expression which is just the constant, just the vowel of some?
1:00:34
And I don't care what the thing is because I'm going. The answer was just the emptiness. There are other variables in that programme.
1:00:40
It's just a constant. What about all vowels in? Well, how about an IED?
1:00:45
V is the name of the variable or wherever we choose I or something.
1:00:51
Right? Well, that does have a variable. It's got exactly one variable.
1:00:55
So that must be the answer, isn't it's the singleton list, because the point about this is use the types to help you.
1:00:58
You know, it's got to generate a list of strings. Well, that's the string, because you can tell from here, it's a string.
1:01:05
Therefore, to generate the right type, it's got to put a turn that string into a singleton list.
1:01:11
Right, so all those of the final one is the application of some function.
1:01:15
Well, the functions don't have variables. Those are just names of primitives. I don't really care about that.
1:01:22
So I'm just going to underscore that out. What I do care about this is these now why?
1:01:27
Why do I know? That I got to do something with these.
1:01:32
And here's the answer, because this function. Is this function here given an expression, miss, tell me all the variables in that expression,
1:01:38
so if I'm to voice a function instantly to go over a whole programme,
1:01:48
the whole expression, you know, which of course has got nested expression, I've got to look too far in this data type.
1:01:51
I've got to say right, where in the state do I see XPS? And here they are.
1:01:58
In this case, there's only one loss of X-Men as the arguments of those functions.
1:02:02
So it could be that I've got a programme which is just already something which which case is caught by this rule.
1:02:05
It could be that it consists of a whole bunch of expressions sitting in argument positions,
1:02:13
and those expressions recursively contain references to to these, I deconstructed.
1:02:18
So I know from just just from the type I know I've got to look in the 80s, that's the point of the semester I'm trying to instil.
1:02:24
So therefore, I've got to find the names of all the variables in the A's.
1:02:30
Well, the A's is a list of expressions.
1:02:35
So you think, Oh gosh, how do I if I've got a function which given an expression, generates a list of names, lists and terrible names?
1:02:38
And I've got a list of expressions. How did I said, Well, it's a map, isn't it? So why don't I just map all of us over the A's?
1:02:47
Problem solved. Well, not quite.
1:02:54
Because if EAS is a list of expressions and this function is being applied to each of those expressions, I must get back a list of list of strings.
1:02:56
Yeah. Because each in the A's is giving me a list of strings.
1:03:08
So therefore the map will give me a list of the wrong type. But of course, it's easily fixed.
1:03:12
All I have to do is to concatenate the results and outputs the answers so I can just check that that Typekit OK when I load the programme.
1:03:17
For some reason, I can't tell. This morning, I can't send the warnings out despite the fact I've told it.
1:03:27
So it's just given me warnings about the my type classes are not fully populated.
1:03:31
Just ignore the warnings. But anyway, that the type is so it's certainly no certainly confirmed the fact that that that functions, that function.
1:03:35
So of course, I could give it, you know, and I suppose I could I could manufacture an expression.
1:03:43
I don't have any expressions of lying around, but so I try and make something up.
1:03:48
OK. The application of. Bear with me, right?
1:03:53
So add Mo, OK. So the application of the ad function to two arguments they represent is represented as a list.
1:04:04
The first argument being, let's say the first one is a constant five.
1:04:15
And the second argument being an IED with the name of the variable X.
1:04:23
So that's that's that's something that does X plus five, whatever that might mean, that's an expression X plus five.
1:04:28
So what are the what's that? Well, yes, it works marvellous.
1:04:34
So that and of course, if I've got two arguments which the two x, the two arguments are both ideas.
1:04:38
Why then it gives me those two, but of course, here's the message, right?
1:04:45
So this can be any old expression, so this could be yet another app of another function with two arguments.
1:04:50
Let's just do one negation of one argument, and that one is also an I.D.
1:04:59
It say so. Right?
1:05:06
So that jolly bow. So the point is that this function has got to look for every expression it can.
1:05:09
And to help me to help me get this function right?
1:05:15
I looked at the data type, I said, right. I'll get to it because a bunch of us let us go through and look for all the experts.
1:05:21
No, no, no, no, no, no. Oh, there's an X. So that tells me how I should recurso.
1:05:27
I should recurs into the argument list of the app constructor because that's
1:05:31
where the XPS line just to reinforce that if I just change this extended this.
1:05:35
Supposing I wanted to write conditional expressions so they aren't, you know, just a conditional expression like we have in Haskell.
1:05:40
If, well, let's let's pretend that the Boolean is false and true.
1:05:46
Represented by vowel zero and vowel one, it doesn't mean we can make something up.
1:05:55
So but just supposing in general got something like that, so we evaluate the predicates,
1:06:01
and if the predicate is a zero say, then it's really there's a one that's true.
1:06:05
Therefore, we evaluate that expression. Otherwise, yeah. So we could have a rule for writing an interpreter.
1:06:10
We could extend the interpreter in the exercise, but I'm not concerned with doing that here.
1:06:14
But what I would need to do now is I'd have to change my all bars function, wouldn't I?
1:06:19
Because my all vowels now can turn out or do it up here.
1:06:23
So it's still got the thing at the top of the screen. So all bars, I would need a run out, but conditionals?
1:06:28
Because why? Because oh my goodness. The aliens an next as an expert, as an expert.
1:06:34
So if I'm trying to find all variables, I can look at those expressions as well as all those expressions.
1:06:39
So the the message is use the data type to tell you how to recursive whatever it takes to help you,
1:06:43
given if you've got to do something over the whole day to type it, the type tells you it helps you to know, make sure you don't miss anything.
1:06:48
So I know that each of these expressions will call them P Q and all conventional way of naming the three,
1:06:55
the three, the two arms and the predicate of a of a conditional, if you like, well, what are we going to do?
1:07:03
Going into all bars of P because P is just another expression can be a good expression.
1:07:09
I don't know which one it is. I've got to do that and then I've got to generate all vowels.
1:07:15
We'll see what I'm about to do in a minute. Q And then I've got to generate all those of on that.
1:07:21
The question is how do I join them together? Well, I can use the types. Yeah, this thing here will generate a list of strengths.
1:07:27
So if I've got three lists of strings and I want one list of strings,
1:07:36
which is the answer, then clearly what I need to do is to concatenate them together.
1:07:41
All right. So and again, although I'm not going to run the programme that Typekit, so yeah, I could do, I suppose.
1:07:47
So I'm sure I brave it Typekit expression, which is a conditional. So I've got an f of.
1:07:56
Well, I could just have a constant goodnight say and vowel one a 1.0.
1:08:04
That's true. It doesn't matter what the programme does. What matters is where, where the variable named, Oh,
1:08:10
this could be an expression where I've got a variable lying around, which happens to correspond to a predicate.
1:08:16
So I could say I'd pick one and then my two arms are, Oh, let's keep it simple, and I'd ex say, and then maybe a vowel.
1:08:20
17. So what's what's that?
1:08:33
And the answer's next.
1:08:36
And it's the right answer, because I remember to recurs into each of the expressions, the each of the sub expressions in my data.
1:08:38
So that's that I thought would be useful. Oh yeah, let's just go back and tell you the programme up.
1:08:46
It's always quite nice to put the constructors in the same order that they appear in the in the in the data type.
1:08:53
So I probably like it like that. Yeah.
1:09:00
And of course, if it happened to be, if it's a different problem and I happen to have that.
1:09:04
So the first two rules. Gave me an empty list.
1:09:08
Well, yeah, then of course, you can apply a little optimisation to that.
1:09:12
You could say, Well, let's delete those two cases because they both they both behave the same.
1:09:15
We'll have a capsule at the end, which says that all bars of whatever you like in that case is just the entry list.
1:09:19
So depending on the problem, you might find that right and functions like that. That's OK.
1:09:27
So it's a passport programme is idiomatic court used to seeing and catch all patents within the schools at the end of the list of things.
1:09:31
In fact, we'll see an example of that. Probably when we do the X-amount exercise, later one comes up.
1:09:40
I have a question. Yeah, sorry. Could you add number to the beginning of all of the concatenation of all there is just to eliminate any repetitions?
1:09:50
Let that be. OK, so supposing.
1:10:01
Supposing I go back to the what I had to start with, so supposing I wanted the three variables without right, it's a good question.
1:10:06
So what I could do is something like this I could not that if I didn't want.
1:10:15
So what I could do is I could not this lot could one, and I begin to worry when I see that because that.
1:10:23
And this is where you've got to be careful. Does that solve the problem?
1:10:34
He answered my question, does this solve the problem? If someone this isn't right, why isn't this right?
1:10:44
Can someone see what's not right? You need it now.
1:10:50
And every single one of these battles, I'd have to, not everywhere.
1:10:54
So notice here, I'm just using Tomcat and I've forgotten to know. So then I have to open up everywhere.
1:10:58
And then you think, Oh no, wait a minute. This is like the link thing, isn't it?
1:11:04
So how about every time I recursively touch an expression and it's up expressions and expressions and expressions like not not.
1:11:08
Not, not not. And that's expensive. So in something like this particular problem, I'll tell you what you would do.
1:11:14
You wouldn't do that at all if you if you were going to use not to solve the problem.
1:11:22
What you should do is this you should go make this a nested function.
1:11:26
All right. So I'm going to put that in our work laws.
1:11:35
And what I'm going to have here is, oh, come on, concentrate.
1:11:43
What I'm going to have here is I'm going to call all of us, I say so.
1:11:47
All bars of some expression e equals right.
1:11:51
So now I'm going to use my help a function. I going to change the name of my.
1:11:56
So I guess they have to substitute old votes for Prime.
1:12:03
I don't call it helper, please. All right.
1:12:11
So that's changed the name of the helper function, right? So now I can call us prime on eight and then I call it still is the not the answer.
1:12:14
I'm I'm I'm done. And so that's the advantage to that.
1:12:23
Can you see is I'm going to go through the expense of generating this great long list of duplicates and I'm going to not exactly once once.
1:12:26
So that's that's one way you can solve the problem.
1:12:34
Now there's another way of solving the problem of kind of, I guess while we're on the topic I've told you about,
1:12:36
Union didn't know if he wanted to generate lists without duplicates, I could forget.
1:12:41
Well, let me go back to the original function, I guess, and all I have to do is instead of doing plus plus here, I guess I'd have to.
1:12:46
Union wouldn't do it. I'd have the union that.
1:12:54
With the results of, well, union, but and and that so that's that's in this particular this rule, this is this has replaced the.
1:12:59
So. How about that so that the DUP and certainly so and of course, then I'd have to consider using concrete here.
1:13:15
I'd have to do a sort of union, all type of thing. So it kind of depends.
1:13:23
You know, you got to. That would that would solve the problem now is.
1:13:31
Is this is is using a union? Is it the same complexity as he is not?
1:13:39
No, you have to think about it. Tiffany question. And can you hear me?
1:13:44
Yes. And we were able to use Conker Map instead of like having them as two separate functions.
1:13:51
I did not tell you that. Yes, of course. Yes. So in here? Yes.
1:13:57
Sorry, I didn't tell you that, did I? Let's go back to the original version.
1:14:01
So this version says, and this might be what you want.
1:14:05
This version says, I actually want to see the duplicates in there because I want to count the number of times I've codex referred to Xia.
1:14:08
So that would be disastrous to nab it then because I'd lose that information. So it maybe this is exactly what I want.
1:14:13
So yes, I'm sorry I meant to say this. This is this is actually the same as that.
1:14:18
This is a very common pattern is that you map a function,
1:14:22
then you realise you've got a list list of list of things and you want just the list of things or list of things you want.
1:14:25
Just one of the things I guess you would use concrete maps is exactly the same.
1:14:29
So Conquer Map is contact dot map. This is relaxing.
1:14:33
You can think about nausea. In the exam, if we were to, like, forget what you said and we would use, not every recursive call would be taken away.
1:14:38
Yeah, it would be. So we tend to be quiet because if you've written the function, which goes over a list twice rather than once,
1:14:50
that's fine because actually sometimes it is just easier to do that. In fact, there might even be a situation where, you know,
1:14:56
we get you to walk over a list twice deliberately because it just makes the programme is structurally more straightforward.
1:15:02
It makes it. Perhaps it makes it easier to understand. It makes it easier to maintain. It's a common trick.
1:15:09
So I'm actually going up to something to watch rather than once is often absolutely fine, and sometimes it's the right thing to do.
1:15:13
But what's not right is to take a linear time function, you know,
1:15:20
one which just simply drops down a list and suddenly converts into an n squared or cue or an exponential.
1:15:24
And so you've got to be careful with knobs because that could happen.
1:15:31
So it just depends on what the, you know, what the problem is, what the instructions are, the instructions might might say, don't worry about it.
1:15:37
It's fine because you know, it's it's a small problem.
1:15:44
We know we know that the size of the input is small and finite and and we don't care if it's got the wrong capacity.
1:15:47
So follow the instructions, really. If it's and if there are no specific instructions, then just think, Well, it's better if I nab ones, isn't it?
1:15:53
Because there's nothing in the problem that says I? Necessarily should.
1:16:02
Well, there's nothing, there's nothing it says that was thought understood what I'm fishing for.
1:16:10
I guess the point is you have to make you have to make a judgement. Something like that is going to alert a little market.
1:16:17
Wait a second, why is this this this? This propaganda suddenly come from all to order n squid?
1:16:24
Because there's a length everywhere. There's enough everywhere. You think that's not right?
1:16:29
And then you think, Well, actually, it's OK because it's a tiny little problem. And even the question might give you a hint.
1:16:33
You know, feeding frenzy is not everywhere if you want whatever. Right?
1:16:37
So that's the next thing. What else is on my list? I'm sorry.
1:16:44
Quick question. What is the instance thing at the top? Do again at the top of the programme?
1:16:48
Oh. We are here. Yeah.
1:16:54
Oh, oh, this was just part of this exercise. There's a whole bunch of little this exercise is partly about day starts and partly about type classes.
1:17:02
So, so presuming there's a class in the upper class in stringing you somewhere.
1:17:11
Was there a built in? I can't actually remember this. But what am I doing?
1:17:17
Forgotten Jews have forgotten how the this site worked, so. And a usual thing.
1:17:32
Let's just have a little look. So just trying to remember the this is a built inside glass.
1:17:49
It's got a number. So what is this stuff? What's this fauna?
1:17:55
So this is this is a mechanism for this is this is this is a mechanism for turning strings into anything.
1:17:58
So from string? That's right. Yeah. So so I might want to turn the string into a number, for example.
1:18:07
So I so I can't remember what it's been used for here in southern Lebanon.
1:18:15
Is it like to convert a string into like IDI string?
1:18:20
Yeah, here you see here it's being used. So if I say.
1:18:23
From string is the usual triggers, isn't it?
1:18:30
So say from String X, it'll say I don't know which actually means if I save from String X and I say, Oh no, I want the exact instance developments.
1:18:33
Oh, you mean you want it to be turned into an ID? Yeah.
1:18:41
So I could create an instance which turns a list of digits into a number, in which case I say I want it to be named.
1:18:45
And then then you could say, Oh yes, the intercontinental say something like from string.
1:18:51
I don't know what it says. Lexuses can. You can you write.
1:18:56
Can you write something that would do a? Does it? Does it?
1:19:00
If I do that one in, oh, I have no idea what I might want is, yeah, I might want to reach that function.
1:19:03
So it says, Oh, hang on. The first thing here is a digit, and therefore I would assume this is a number.
1:19:11
And therefore, instead of using the just wrapping it and I d I would actually read it using something like the read function.
1:19:16
So I can say read one two three and I can cause that to an end,
1:19:24
and that gives me the number so I could actually have a slightly abridged version from String, which inspects the first characters.
1:19:31
Oh, it's a digitalising. It's a number in which case I'll apply. Read to it and then I'll wrap that up in inside a particular vowel.
1:19:36
Oh. In which case I have to use the double instance with the study, so I could do something.
1:19:45
There's something to be seen before. You can feel free to play with it and then actually say, Well, interestingly, do I need to cut you?
1:19:56
I need to tell the Haskell type system that read one to three means double here.
1:20:03
Well, actually, no, I don't, because I know that the argument of every vowel must be a double.
1:20:08
So since I write that said, this thing in brackets has got to be a double anyway. So as you say to Haskell, read one to three.
1:20:13
Please turn it into a double, says it's already a double. I know this.
1:20:19
You don't need to tell me it has to be a double. Otherwise it's an incorrectly thought expression.
1:20:24
Simply just do the right thing anyway. So yeah, this this might be helpful.
1:20:27
I don't know. Ryan. Will we ever have to define a class in high school?
1:20:31
No, I can tell you you. We don't do. We've never done that.
1:20:39
It's just I think one day we might. The reason we haven't asked you to define your own data types and type classes.
1:20:44
It's it's really I mean, it's typical. It makes it easier to test your test your programmes because we can generate we say,
1:20:51
Oh, this programme must generate and then have a have an instance of a data type.
1:20:59
We can do it just a simple quality check. Whereas if we don't know what those two cups you are defining, we can't define a test for it.
1:21:04
We'd have to rely on you to define your own test and then it would all go horribly wrong. So it just makes it easier.
1:21:11
Right, so that's that's that's this expression thing.
1:21:19
Was there another one? I guess.
1:21:23
Well, I was going to do with. OK, well, let me let me pass it back to you then, have you got any other?
1:21:30
We've got about another 10 or 15 minutes on. Is it an Old Town road?
1:21:35
Is that the teens and. Oh, so you're right.
1:21:40
All right, good, good, good. So let me summarise then and then if you got any further questions,
1:21:47
so what you what I think you should practise is have a look a quick look through
1:21:55
the sort of things we talked about you'll find in dated things you got list,
1:22:01
which is, you know, things like sorting and partitioning unionism and dissect maybe might be useful.
1:22:05
What have we talked about this morning, maybe from maybe from just, you know, all these things might be useful to?
1:22:13
We've talked about, in particular, higher order functions is something that is going to come up quite a lot in this exercise.
1:22:21
So and and in scope, because how are the functions?
1:22:31
As we've seen with functions generally about how the functions in particular, they often sit in nests,
1:22:36
they sometimes cities function sometimes and often such a nested scopes that they have part of a where clause, so on.
1:22:41
So therefore it's worth practising that and particularly with men.
1:22:47
But how do we have it? How do we ever build a functioning house? How do we build a functional runtime and pass the function around?
1:22:51
We'll be staffed by partially applying an existing function, so all functions are built by partial application of existing functions.
1:22:56
And I wonder whether.
1:23:04
Akash, there's a quick question, I was going to just flip back to what we did earlier today, but ask you a question now in case I need the screen.
1:23:07
Yeah, I had a quick question. Even if you may not be asked to define your own data types or type classes, would we be asked to look like, for example,
1:23:15
here where you have to like, instantiate a specific type as a type of a specific type class device to do that and not to test or not?
1:23:23
No, no, no. I'm not going to get you through the. We kind of set the titles up for you.
1:23:33
If this were a second level course, of course, we absolutely would get you to.
1:23:41
You know, we'd be much more hands off, wouldn't it?
1:23:46
We'd say, here's a problem go go away, design those it times to solve the problem, and we might one day do that.
1:23:48
But at the moment we don't. Ryan.
1:23:53
What do you mean by going about higher order functions, big astronomy, just anomaly, revised iota functions for everything?
1:23:59
Or is there a specific thing that we need to know? OK, let's go.
1:24:05
Let's go. Let's go back and. See, I couldn't read immigration.
1:24:10
What's it objecting to? Was it worth subjecting to, I must have missed.
1:24:23
Okay, so they also overloaded the. Right, so did I have.
1:24:32
Oh, yes. So what so the question is what what I think, of course, is what do I specifically mean about power water functions, but what specifically?
1:24:40
So this is probably good. This is probably a good example.
1:24:47
Because it's got say, this is an example of so this this thing if you want, I think if you understand this function.
1:24:52
You've understood the two things, which I think, but the takeaway messages from this morning,
1:25:01
which is higher order functions, partial application and scope.
1:25:05
So here is a function to just understand that type signature is exactly the same as this type signature.
1:25:08
If I take the brackets, you suck at the site because the function application is left associative.
1:25:15
So when you pass the apply, you always give the arguments left to right.
1:25:19
So you must give up its first argument and then you give it a second and then you give its third answer.
1:25:23
So it's always a left or right left to right thing, which is why the bracketing works that way round.
1:25:27
I guess one of the thing I could say is, how about this?
1:25:32
This this is this will be also useful in connexion with the question, and that's a where clause right now.
1:25:36
You also would know that. But to do this, it would just comment that out for the time being.
1:25:43
Let's do that now. I thought I could do also is I could.
1:25:58
Let me just let you just copy that down here and we'll start again. Right.
1:26:02
So there's my function. So it's another way I could write my function. If I could write it like this, I could say if.
1:26:06
So F of X equals right.
1:26:15
So instead of using a where clause, I could use less expression, good not to say let, but it's round the right way now.
1:26:20
So let G of Y be a function of X plus, which gives me a function which gives me X plus y.
1:26:26
And I've got to think about a nice way to light up my left. Nice. So how about like this?
1:26:32
Or, you know, pick your favourite convention you might have it which like these are basically for you.
1:26:36
That's fine. So in what I've got, I've got over just g in this case right now, that's the same thing.
1:26:42
Just to verify that I can be like, What is it complaining about?
1:26:53
What is it complaining about? However, I turned. The local G.H.
1:27:02
Oh, it's probably because I probably says I know it had something to do with the warnings, I think.
1:27:14
I'm so sorry, let me go back. And.
1:27:20
All right, so let me just read like, well, okay, that's fine. So, so I can define this, this f function using that expression, that's absolutely fine.
1:27:30
So I can just confirm that I can get what to look at the three and six or something. And that gave me nine.
1:27:37
I could even write this so I could say X plus y plus z, and I could even define that here.
1:27:42
And that's absolutely fine also. So I can say what's something again?
1:27:54
For three, six, but this is all just tied up in the next two to the end of it,
1:28:01
so it's X plus y plus two because that is two in this case, what else was I going to say about it so?
1:28:05
Well, I could even do something like I could have a cut of this.
1:28:12
I could have a programme. Which isn't is.
1:28:19
Well, let's just let's let's get to actually get out of school to further talk format.
1:28:25
So we've got a programme so I could actually obstruct the whole thing and I could say let.
1:28:33
Oh, so I guess this goes back to what I was saying just now about the expression, an example in the calculus exercise, you know?
1:28:38
What have we got? We've got a data type with some expressions, which are experts.
1:28:46
So. So in defining the data type, I get some expressions to Type X.
1:28:51
So because on that day, we let expressions. There's no reason at all why everywhere I could have an expression, I can put a let's say, for example,
1:28:56
I could say something like, I'm going to try and construct the example of a top with a specific value or ethnicity.
1:29:04
So actually let f. Pro X equal.
1:29:10
And I could say, let I'll take that out, because they let you right in.
1:29:18
So that's that and down here, I suppose I could have in what was my example, f of three.
1:29:27
And six, so.
1:29:36
Well, I got something that spoke to.
1:29:43
Oh, come on, it's frozen on that. My can you still hear me?
1:30:00
Yes. Welcome to my world.
1:30:15
Someone's just killed the machine I'm on, thank you very much, I was just done that.
1:30:27
That's absolutely lovely. Thank you. Smashing, let me start another session. Let me just take the bear with me.
1:30:31
This is this is this is quite useful. I think we just conducted this.
1:30:37
I'm just going to have to fire up my this session again with a different machine.
1:30:47
No idea. I had a horrible feeling with the glorious Virgin Media getting my Walkman.
1:30:51
Oh no, wait a second, we do have a problem now. I would make.
1:31:03
Yeah. Oh, oh, it's interesting the Shell servers come down.
1:31:21
A CSG doing any maintenance this morning, I wonder. Bear with me.
1:31:30
Everything's down. Let me try one other option.
1:31:41
No. I guess you can still hear me.
1:32:02
Yep, you can still hear me, right, so I think all this,
1:32:18
I think there's something I think something has happened on this issue of pull all these shell servers down, so I can't let me tell you what.
1:32:21
Let me be creative. Let me come back to share my screen with you again openly.
1:32:27
But. Can you see the virtual whiteboard?
1:32:35
Yes, I think you can order on the virtual whiteboard. You get the idea. So what I was doing there was something like I had a programme.
1:32:42
And I said my programme was I wanted to let I wanted to find this function.
1:32:58
To the left. G Y equals x plus y in.
1:33:07
So the point about that is that. Is that this thing here is income brackets, one, if one that's an expression?
1:33:22
Which gives me back a function which adds extra things, doesn't it?
1:33:32
Do you look at the structure this you said this, this thing here is what's called a Freberg that they act and that this means that once on Know X,
1:33:36
then that thing in brackets is a function which adds X to things. Give me a white x two.
1:33:43
What so what I was going to show you here was something I can say in and now we can go back.
1:33:48
Three. So I can put brackets around that for one, that's a function which by definition must add three to things now here.
1:33:56
So if I give that one a function has three things to sic, then that should give me.
1:34:04
No. So there's something wrong with the programme, I couldn't tell you what it was, just died on me.
1:34:09
All right. All right. So that's a that's a pretty face that that's actually something written you might not be right is a where clause,
1:34:14
but actually written using that expressions. So just just to clarify that if I come on to the command line and if I go something like if I say.
1:34:22
Oh, well, OK, so what I have to Typekit actually is an expression, so I can't say x plus one.
1:34:39
X equals two or input brackets run, he won't accept that as an expression.
1:34:48
It's because where is a special piece of syntax, isn't it?
1:34:54
It separates the the right hand side of a function from it's from the the sub definitions which are in the workforce.
1:34:58
So it's called a clause, not an expression. So, for example, I can't take that in at seven to it.
1:35:05
That's broken. But if I use expressions, I can so I can say something like this, I can say let x equal to.
1:35:11
In exposed one, and that's clearly means three, right?
1:35:19
And I can put brackets around that, and that's absolutely fine because let let expressions are expressions, so I cannot add that to seven.
1:35:24
And indeed, I guess what would I get to? I get so I get 10, I guess, because that's the difference in workplaces, unless it's great.
1:35:30
So I think the point of the example was so this this is somebody else.
1:35:38
We what what do you need to practise with regards to the of function, this sort of thing?
1:35:41
And particular noting partial application is a partial application about at the
1:35:46
three is a partial application event because it's it's a function of charity.
1:35:51
So even though it's only got one argument in here on the right hand side, this thing in here, this is a function.
1:35:56
So just being aware of the fact that when you write something like that, you're the right hand side of there is an expression which builds a function.
1:36:03
So if given three is a function and it's a function which is expecting in this case,
1:36:14
that little fact that to give me they aren't the final, it's annoying. So that's what I think you should practise.
1:36:20
And then you'll be fine. Good.
1:36:28
Well, I think I've oh, there's a couple of questions,
1:36:35
and I think we're going to pause and it will come back to and we'll go through the example exercise.
1:36:37
Richard, quick question before we stop.
1:36:42
So it's when us besides the polymorphic type insurance best we do tomorrow, which other test is most closely related?
1:36:45
Do something good on Wednesday and we should be revising? Well, yeah, I yeah, you asked me this.
1:36:54
So um. Oh sorry, I've lost everything now.
1:36:58
So so I know you said memorisation and the constant propagation what's, for example, which one out of them this?
1:37:04
Should be paradise. Um. I.
1:37:12
Let me have and think about it between now and 2:30, I think this would be number seven would probably be a good one.
1:37:23
Right. I just wonder whether I'm just looking through the list.
1:37:32
Oh, let me have I'll have a quick look at the specs and to see if anything. Oh yes, that would be doing that will be useful to you.
1:37:42
And I'll come back to you this afternoon. Evelyn, Okay, thank you.
1:37:47
And what materials would you recommend that we use to practise partial application in this specific instance?
1:37:52
Oh, I think just make up your own examples I saw I'm fortunate I can't show because the passive thing has gone down right now.
1:38:00
Let's see if I can construct something on the whiteboard.
1:38:08
So you've seen that a lot. And.
1:38:15
Oh, I don't know. I mean, just to just to stop, just start making things up.
1:38:24
Okay, I've got a function. OK, well, let's let's or even people that you could do.
1:38:30
Well, how about this, what was the function of just how they said this was f of X equals a?
1:38:37
She of Y equals y plus two x plus y.
1:38:44
And she went on. And then you could say something, I leapt out of it.
1:38:48
And then you say in this is the one I had was a three and then, well, f a 360 go to my wife.
1:38:58
That's a partial application left to three. And then the function I get back, I could play that.
1:39:05
The sector that I've just said that, then you might think, Well, then maybe there's another way I can work.
1:39:08
So what can I get? Can I get rid of this? Can I somehow? Can I rewrite this?
1:39:15
What's another way?
1:39:19
Supposing I look for this is I'm not happy with this programme in the way I looked at the square root programme, so I'm not happy with that programme.
1:39:20
I don't want the square root thing to have this tool to use this X that this was in scope.
1:39:24
I want to lift it to the topmost level for some good reason. What would you do?
1:39:29
How would you do that here, for example, there's nothing you might practise. You might say. Well.
1:39:33
I could say maybe this, I could say maybe let f of X equal.
1:39:39
She of Wallace. Well, let me let me start again.
1:39:49
And so maybe you can take that away, and that's a way.
1:39:58
And then this is my this is my GHG command line thing.
1:40:02
So I think I do something like that was what we have.
1:40:06
That's what we started with, wasn't it? Let it be something anyway? Right?
1:40:10
So supposing instead I could do something, I could say, Well, I could define F of X here.
1:40:14
And rather than having the the G defined locally to be using workforce or let go, let let expressions I've got here, I could bring that.
1:40:21
What did I do with with the Newton Square with I brought it up to the utmost level, didn't I?
1:40:30
So that it sat there and then. But of course, I can't just do that.
1:40:35
If I if I just wrote a g of Y equals one plus X. And I said F of X equals.
1:40:39
G. This is broken, isn't it, because Hesco will say, what's that?
1:40:49
So just as he would do in the in the square, which example, so we fixed it by saying, Oh, well, OK,
1:40:59
actually the poem, I've got to give you the X there and I've got to put the X in here and then it's absolutely fine.
1:41:06
Yeah. So you could do something about that. But you can also make other examples.
1:41:11
So I could have. I could have to make something, so go f of x y is G.
1:41:15
A partial application of G to X plus one a g of z m n equals and plus end to the Z.
1:41:25
An upper. And then you could say, well, h.
1:41:39
Well, I thought maybe to replace the idea that something odd. So then you say, okay, I can make it, so that's what that's what.
1:41:44
So given given this fellow. And this throws away the it doesn't lead to why this okay was just the point.
1:41:51
It doesn't actually need that white. It's OK. But it does pass the X plus one to G.
1:42:00
Well, so if it passes the X plus one to G, then essentially G is now got a Z, hasn't it?
1:42:05
So we've got those two, but we're not missing the M and the and so this thing in here.
1:42:13
Must be a function of emanating. So, so in other words, if I if I come to the command on and I say F.
1:42:20
All three one that is this thing in circles where the where the.
1:42:31
The X is three, therefore this is GS been getting four.
1:42:40
Therefore, the Z is a four and therefore this is a function of these two arguments, which will give me an plus enter the Z.
1:42:44
So this thing in here is a function of two opens.
1:42:53
So if I give this to two, then this should give me, so let me say the G that f a three one is the same as.
1:42:57
G4 and G4, this is the same as G4 and two two, I know I've got all four arguments.
1:43:08
So the answer is two plus two to the power of four.
1:43:13
Which is why or something she thinks of, well, I mean,
1:43:20
if you make up examples and play and play and play and and supposing I said that instead of Jeeves instead of this type type,
1:43:24
these interjects, then just play do any harm. I said it, but supposing I gave it seven.
1:43:32
So now instead of this. The jury here has been given two arguments in which case is expecting one more, which is this little fellow in here.
1:43:42
So in fact, this thing down here would now be incorrectly typed because it's got one argument more than it needs.
1:43:54
But if I just take one of these arguments away. It should be recognised where for three one is G for seven.
1:44:00
So this thing here is that's G-force seven, and that's being applied to two.
1:44:09
I'll put the brackets in. And that's the same as G. Four, seven two.
1:44:16
Aha. And now we can evaluate that because I've got three arguments and this becomes seven plus.
1:44:20
To take the path for which is, whatever, 23. So I me.
1:44:27
Stunned silence.
1:44:40
All right, let's have a break, and I'll come back at 2:30 and we'll go through as much of the extra mile as we can get to in two hours.
1:44:43
So if you haven't already had a go at it or finished it and then do so between now and 2:30 and have a lovely lunch break, Tahrir.
1:44:50