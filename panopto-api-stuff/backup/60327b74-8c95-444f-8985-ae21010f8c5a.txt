ID: 60327b74-8c95-444f-8985-ae21010f8c5a
Title: Java - 2022-01-18
Category: Java
Lecturer: Alastair Donaldson
Date: 18/01/2022
OK. Welcome back, everyone. Nice to see you all again.
0:06
Before we get going with the technical material, I just wanted to know about the video recording from last time.
0:09
As I mentioned briefly on edge them, I remember that. I was going to use Microsoft Teams, there was all this kerfuffle with Teams not working.
0:15
And then I started a Zoom meeting, kind of, you know, in a slightly panicked state.
0:23
And it turns out because I started that Zoom meeting from this little gadget over here.
0:28
As a result, it to the age of three or eight owns the recording.
0:33
So only lecture at the age of three or eight can share it with other people.
0:38
Unfortunately, I just get the same view that some of you I think maybe I think maybe if you were in the Zoom meeting,
0:41
you can automatically see the meeting.
0:47
So anyway, I've put some feelers out to try and work out how a meeting can get re assigned so that I can become the owner of it.
0:50
And then I'm sure I'm on Panopto. So bear with me on that.
0:57
I wanted to use that opportunity to make the point, though, that these lecture recordings sometimes don't turn out very well.
1:02
Like in the lecture gave a couple of days ago, Zoom crashed off with you, for example. So please do use them.
1:08
I mean, I'm preaching to the converted here because we're all in the room.
1:13
But please do use the lecture recordings as a bonus or a backup or revision aid.
1:16
Please don't get into the habit of depending on the existing and being of high quality because occasionally things happen.
1:21
And then. We're going to now move on to the second topic of the course,
1:26
what we covered last time was encapsulation looking at the problems that can arise when you don't properly use visibility modifiers in Java,
1:31
public, private etc to make sure that internal implementation details of your code is hidden.
1:38
And now we're going to look at the most fundamental topic and object oriented programming, which is the topic of polymorphism.
1:44
And in Java Polymorph, it polymorphism is polymorphism is provided by interfaces.
1:52
So we're going to look at Java interfaces and how they let us achieve polymorphism.
1:59
You might remember high school type classes from last term.
2:05
So Java interfaces do bear some resemblance to Haskell type classes, but they're actually fundamentally different.
2:09
And a bit later on in the time, I'm going to do a brief section on the relationship between Java interfaces and Haskell type classes.
2:16
I don't want to get into that from the get go because I know maybe some of you find Haskell pretty tough on a really weird in Java,
2:23
and you don't necessarily want me reminding you of some of the more advanced features of Haskell.
2:28
We're just getting going with Java. OK, so interface is a polymorphism.
2:33
It's about trying to separate the specification of functionality from its implementation and allow us to be
2:39
able to treat objects of many different types uniformly thanks to having specified what they have in common.
2:44
And what I'm going to do is I'm going to work through this using an example. Can I just say I'm not sure you're sharing the screen?
2:51
Like, probably on Zoom? I'm sorry. I'm not.
2:57
Yeah, it's quite a yeah.
3:02
There are so many things to do simultaneously, so the people are here to see it.
3:07
I need to plug in and you really think it should be good now I could go to an.
3:10
OK. Apologies for that. I don't think you missed anything particularly important in the first like say, thank you.
3:16
OK. Thanks for pointing out. Right. So let's imagine that we are building an application that's going to manage a bunch of documents,
3:23
things like web pages, maybe, and the things that's going to manage a code page elements.
3:32
And this is a. A toy example for the purpose of introducing you to Java interfaces.
3:39
So I'm not going to go into any real details, I'm not talking about building a proper system with the user interface.
3:44
So let's start pretty simple and imagine that we've got a text box page element.
3:50
So a text box has got a width and height. It's also got a unique label, and then it's got a maximum number of characters that can fit in the text box.
3:55
Let's imagine we also have a menu as another kind of page element and a menu like a text box has a width and height.
4:05
It also has a unique label and in addition to menus, got a list of options.
4:11
So the options you'd see if you clicked on that menu and finally said, OK, we're going to add some more page elements in a minute.
4:16
So what might the text box costs look like? Well, we might, for example, have a number of fields width, height, ID and maximum number of characters.
4:24
And as from last year, we would mark these fields as private to obey encapsulation.
4:34
And it's also typically a good practise in Java programming to make fields final.
4:39
What final means is that after it's been initialised, a field can't be changed again.
4:44
That is a way of ensuring that your objects are immutable, and we'll discuss a bit later why immutable objects are usually desirable.
4:50
Immediacy also is important and has a place, but input for immutability by default.
4:59
So final fields are typically good. OK, then we might have what I call the obvious constructor here.
5:05
So we've got a constructor that takes a parameter for every field,
5:11
so width parameters or a height parameter, etc. and just plugs each parameter into its corresponding field.
5:15
So this dot width becomes equal to width is height becomes a good height, et cetera.
5:21
And a quick note here when we say this, don't with this refers to the object being constructed.
5:27
So when the constructor of text box. This refers to the text box that is being made, and therefore this dot width refers to that field up there.
5:38
Whereas just width refers to the width parameter here and in a constructor is usually good practise if you are plugging fields directly in.
5:47
It's good practise to name the parameter the same as the field, and then use this to disambiguate between the fields and the parameter.
5:57
OK, then we might have a method for getting the width of a text box,
6:06
and maybe that gets guesses for some of the other properties on our menu class, but look remarkably similar.
6:09
We would have width, height and string with height and ID fields.
6:15
And then, in addition, a list of strings for the options of the menu and the constructor might take,
6:21
say, the width, height and ID as explicit parameters. And then perhaps make the options be an initially empty list.
6:27
A couple of things to note here, because there isn't an options parameter.
6:36
I just got width, height and ID. There's no need for me to write this two options here.
6:41
I could have just written options becomes equal to new ArrayList. The reason I personally prefer to use this is because it looks consistent.
6:46
It's obvious to the eye that the fields of the object to be initialised there.
6:54
So I think trying to go for consistency when you're programming is good, but strictly is not needed in a couple of other notes.
6:58
When we say list of strings here, what we're saying is the options is GO has got to refer to something that implements the list interface.
7:06
Here, when we say new ArrayList, we're saying the kind of list I actually would like is a list is implemented in terms of arrays.
7:18
So the actual implementation of the list uses arrays and those kinds of lists have got some nice performance properties.
7:26
But the main point here is that I'm separating.
7:32
What my cost is able to do, namely manipulate lists from the specific kinds of list it implements that it uses.
7:36
Name the array list. So this is another example of encapsulation. OK, but the key point here is we've got these fields.
7:45
And when we make a menu, we plug it with Hiten ID and the list of options is empty.
7:51
And then we might have better methods for the obvious fields, and then maybe we would have an adoption method where we can be given a string option,
7:58
and we can add that to the list of options that the menu exposes. I maybe get options method that's going to return the options list to users.
8:07
OK, so very simple here. Nothing particularly exciting going.
8:18
And now our document manager costs is going to be able to keep track of various text boxes and various menus.
8:22
So how's that going live? What we could do is we could have a text box field, which is a set of text boxes.
8:31
This is going to be all the text boxes that the manager is aware of.
8:39
So if you're using this application, you've made five text boxes to be five things in the set.
8:42
And similarly, you may have a set of menus that the document manager is keeping track of.
8:48
And when we make a document manager.
8:53
Let's say that we initially have no text boxes and no menus, so we set both the text boxes and menus fields to be new empty sets.
8:56
And again, a quick aside, we've got the business here of when we declared these fields textbooks as in menus,
9:06
we use the set interface and when we actually initialise those fields,
9:13
we create empty hash sets, a hash that is a particular way of implementing a set.
9:18
But our document manager should be able to work no matter how the set has been implemented so long as it is correct, except implementation.
9:24
So here we're saying that these fields need to be set. And here we're saying kind of in a whisper.
9:33
By the way, we're actually making a hash set here. But the point is that we've got the operations of a set aside disposal.
9:39
And then if we want to add a text box to the document manager,
9:48
then we could use an add textbox method, which takes a textbook and plugs into the text boxes.
9:52
And if we want to add a menu, then we would have a correspondingly similar method.
9:58
OK. Very simple so far. Are there any questions, though?
10:04
I mean, I would say the code is pretty simple, but nevertheless there are maybe some nuances given you so feel free to ask.
10:07
Yes. But. You mean you mean here when I say new have.
10:12
So despite and. The.
10:23
Yeah, I mean, the return type of the function can be whatever you want it to be.
10:36
OK. But it is less here.
10:41
And then what the what the compiler would do it when it compiles your programme as it will say, Oh, you're trying to return options.
10:43
What is options? Options in this field? What's the type of that field, its list of string?
10:48
Does that match? Yes, it does. So if you? For you, this is yeah, we're going to come to that in kind of detail later in the course, but briefly,
10:53
for now, ArrayList is a cost implement the list in place and that means every ArrayList is a list.
11:06
Right, so an ArrayList is always usable when a list is required, but not vice versa.
11:13
If you needed an ArrayList, you could just pause any old list because you might be doing something very ArrayList specific.
11:18
If I made this, you change up a rapist, then the code wouldn't compile because the compiler would say, you're protecting options, what is options?
11:32
Options is a list and not necessarily in a rapist. And the code wouldn't compile.
11:39
Now it's so happens. If you read the code carefully enough, it will be in a list when the programme was actually executed.
11:42
But just from looking statically at the declarations in the programme, that information is not available.
11:50
And furthermore, part of the reason for declaring that it's a list is saying I don't want any part of my programme
11:55
to depend on what kind of businesses I want to be able to change that new to the new linked list.
12:02
Or I knew my favourite list without making anything change my programme from a functional perspective.
12:07
OK. That's correct. But. Not really, I mean, you could technically do that.
12:13
You could do that and you shouldn't and you should not do that. Yeah.
12:25
Your programme would be if we changed that to ArrayList and that to ArrayList, the programme would still be a well-formed programme.
12:29
It would be a poorly engineered programme. Yeah. OK, any other questions for all this business about ArrayList less than subtyping?
12:36
We'll go into that later. There's a tension when teaching between.
12:44
It would be simpler for me to show you this if I did it the bad way this is released because I would have discussed this problem,
12:49
but I kind of don't want to show you bad code in a second outfit. And ask a question before we move on, you already have.
12:53
But so basically, can we not just declare another function inside?
13:00
One of the public functions? It's basically a job, and you can't declare a function within a function,
13:06
you might be familiar with Python, where inside a function, you can define another function in Java.
13:11
So that's why I like it. OK. I don't I don't see how that's relevant.
13:16
Which, by the way, feel free to ask your relevant questions, but I'm saying that.
13:22
Could you explain? Did you ask that question with respect to this particular discipline?
13:26
For example, if you want to make another function within the art option?
13:32
So you are saying that it wouldn't work. Yeah, you can see in here you couldn't write like another function here.
13:39
Yeah, that's that wouldn't be legal Java, right? OK. But could you like define a clause within that function?
13:45
Then within the class, you declare a non function myself?
13:53
Very thoughtful when you can do that. You can define what's called an anonymous clause.
13:58
And that anonymous clause has functions. But I mean, you don't do that if you had a very specific use case in mind.
14:03
OK, OK, OK. Right. So our document manager, then it's got textbooks as a menu and it's got a method and text box.
14:09
You give it a text box, it puts it in. The text box is set. And similarly, an ad menu method.
14:17
OK. So so far, this looks fairly boring and fine.
14:23
Now imagine we wanted to do something slightly more interesting, which is find the height of the tallest page element.
14:28
So we've got these menus and we've got these text boxes, and maybe we want to work out like,
14:34
could we say we want to know what is the tallest one so we know how much space we might need?
14:39
Well, we could quite easily write a method. Max Height and document manager that would figure this out.
14:46
It would say, for example, I'm going to say that the maximum height I find so far is negative one as a placeholder
14:51
to say I haven't yet seen anything and then iterate through all of the text boxes.
14:58
So for every textbox T in text boxes, if the height of T is bigger than the biggest height has also far, then update the result.
15:03
I'm ultimately going to return to be the height of this text box.
15:14
So that would get us the tallest text box and then we can have all the menus as well, and we could do the same thing we could say.
15:17
If the height of this menu is bigger than the tallest height we've seen so far, i.e. bigger than all of the text box.
15:24
If you saw on any menus we've seen so far during this loop, then update result to be the height of that menu.
15:31
And at this point, I hope you all agree. Results is going to be the height of the largest page element that the document manager is managing.
15:38
So this looks to me like a correct or correct piece of code. What is bad about this code?
15:45
Yes, please. The two folks are fairly similar.
15:53
Exactly. I'd go further and say the two folks are almost identical.
15:59
The only differences are we've got tax boxes, menus, text box menu and we use a different name for this character.
16:02
But the structure of the lease is exactly the same. Right? So the computations we're doing here are identical in both cases,
16:10
going through a set and looking for something in that set this larger than some some
16:17
existing value and duplication in software engineering is normally a bad thing.
16:22
It can make code hard to maintain and hard to reuse if you have lots of duplicate bits of code in your system.
16:27
And if you find a bug in one of the bits of code,
16:35
then you need to know about all the other similar bits of code so you can correspondingly fix the bug in this place.
16:37
So that's kind of the, I think, the most compelling reason why code duplication is a bad thing.
16:42
I think it's important not to be obsessed with code duplication sometimes if it's a rather trivial bit of functionality.
16:47
Sometimes it's just simpler to duplicate in a few different parts of your application, then extract it out into some class.
16:53
Sometimes it can be hard to think of a name for a cost to capture some little piece of functionality you want to share.
16:59
But broadly speaking, if it's easy to avoid duplication, you should.
17:05
OK, so this isn't very good. Now, let's imagine we wanted to have another kind of page element and image.
17:09
So the details don't matter too much here,
17:16
but what I want you to note is that an image has got the same things that menus and text boxes had with heights and IDs,
17:19
but it's also got a file name, which is going to be the file containing the image data.
17:24
We have the obvious constructor where we just plug each of those parameters into the corresponding field,
17:28
and we have a bunch of methods to find an obvious way.
17:34
And then there would be some image specific functionality, which I'm not going to show you here.
17:37
The point, really, is that there would be a getter for wit to get to the heights.
17:41
Maybe it gets a file name and then maybe a bunch of things to do with actually reading image data into memory,
17:46
which are not important for the point I want to make him. OK? A quick aside, in these examples, I've said we'd have debtors' for these fields.
17:52
I just want to make sure it doesn't come across. Like I'm saying, always have guesses for your fields.
18:01
I'm just using get methods in this example, as I mentioned briefly last time, getting methods and especially setter methods.
18:07
They're not things that you should just have by default to your classes.
18:14
You should think carefully do I really want to give people access to that field or is that something that there's no good reason to do that?
18:16
OK. And now in our document manager, what we could do is also have a set of images.
18:24
We could have an add image method that will add a given image to the set of images.
18:31
So these additions to the course and then in our max highlight methods,
18:35
as well as looping over the text boxes and menus to find the largest page element, and I need to leap over the images to go through all the images.
18:40
And if we find an image whose height is bigger than the biggest height we saw so far.
18:47
Then we update our result. And then finally, we turn it.
18:53
I can't look at this creaking noises coming from a lecture theatre or from Zoom.
18:58
But it stop now, you. If you're in line, if you could meet yourself, if you're not asking a question, that would be much appreciated.
19:06
Right, so this is becoming duplication, Hal, I mean, maybe columnist is HAL is an exaggeration, but it's getting worse.
19:13
We've added another kind of page element and I we got even more of this duplicated code, so that's not good.
19:21
So let's just recap what the problems are.
19:26
Then there's quite a lot of duplicate code in the document manager because we had to have these set declarations that are quite similar,
19:28
these ads methods that are quite similar.
19:35
And in our methods of finding the tallest page element, these loops that are basically the same as each other.
19:37
So that's not good. Another problem which may not be so obvious to you is that the document manager needs
19:43
to be explicitly aware of all the kinds of page elements that exist in the world,
19:50
and that's definitely an undesirable feature.
19:56
It's quite common in a software application to want to be able to have the ability for third parties to add components.
19:59
So it's quite common in computer games for it to be possible for some contributor
20:05
to be able to add their own levels or add their own new kinds of characters.
20:09
It's quite common in music production so that we use something like pro tools or logic.
20:13
It's quite common for third party producers of devices to be able to add their own customisations and menu options.
20:17
So we don't want to make it so that an application needs to have complete knowledge
20:25
of everything that's ever going to happen in that application's lifetime.
20:28
If we introduce a new page element, we've got to change the document manager, which is annoying,
20:34
but also it means that no one else can contribute their own kind of page 11.
20:38
So some company wants to have some fancy sort of page elements that could work with our system.
20:42
They have to contact us and say, right, can you add support for this, can you add another set to keep track of that kind of page element?
20:48
Can you add more loops to work out which page element is tallest in the context of on?
20:54
You can see page elements.
20:59
You're much nicer if it were possible to make the document manager agnostic to the specific kinds of page elements it was working with.
21:01
OK, but let me show you something even worse. They say we want to have a way of saying, is this page element taller than that page element?
21:10
So maybe you've got a text box of the text box and we want to know which of them is taller or we've got
21:17
a text box in image and we want to know which of them is taller and you've got things set up currently.
21:22
We would have to do something like this in our document manager.
21:28
We could have a toll of that method that takes textbooks in the textbooks and returns, whether A is told to be.
21:31
Then we don't have a textbook menu case. And then we'd have to have a textbook image case.
21:39
On the menu textbox case, et cetera, and there will be nine of these methods in total.
21:46
We'd have to have methods for checking every combination of different page element types.
21:51
If we want the ability to ask for any two page elements, is this one told him in that one?
21:56
So makes sense. Yeah, and that's going to be problematic.
22:02
If we had 10 page elements of one of these methods, if you added one more page out of one hundred and twenty one of these methods.
22:06
So it's going to be quite painful to to maintain this kind of a brief note here.
22:12
I've used the static keyword here.
22:19
What that means is that I'm not calling this taller than method on a page element I'm not saying is a dog's taller than B.
22:21
What I'm doing instead is I'm just calling the standalone method taller than I'm saying.
22:32
Does the taller than method tell me that a is taller than be?
22:38
So with a static method? You don't call it on a specific object.
22:42
Just call the method and you pass it all the parameters it needs.
22:46
With a non static method, you always call the method on an object. You're always doing.
22:50
Exact method name for some ex. OK.
22:55
OK, so this is really bad, the methods are all the same. This is called overloading.
23:02
We're providing a lot of overloads of these methods and we got to provide an overload for every possible combination of dominance.
23:06
So if we had any page elements of N squared of these methods, so that's clearly not scalable.
23:13
OK. So what do we really want? Rather than watching you hear what we really want is to exploit the fact that a text box is a page element,
23:22
a menu is a page elements and an image is a page element.
23:32
So they've got a lot of things in common. They've got width, they've got heights, they've got IDs, but they're not the same height.
23:37
For goodness sake. Well, that was fun for those of you online, then how audible that was.
23:45
But we had some terrible drilling below. Probably not. As soon as a week of reconvene, it will happen again.
24:07
OK, so these things are not the same, but they're similar, they've got a lot in common, but they've also got fundamental differences, right?
24:15
Like any, they just got a phone in a menu, has got options textbooks, has got a maximum number of characters.
24:21
So it would be nice if we had a way of talking about any old page element.
24:26
So we can say.
24:31
Given to page elements, I can tell you how they relate or hear I've got a set of page elements, it can contain a mixture of images, menus, text boxes.
24:33
So, yes, it would be nice if we had that ability.
24:44
And the solution to this is to define a page element interface and then to have a different classes implements that interface.
24:47
OK. So how do you do this? What we do then, is we say interface page elements, and we would typically we typically make classes and interfaces public.
24:57
If we'd like to be able to use them throughout our whole application,
25:05
we would make something not be public if we just wanted it to be visible in its own package.
25:09
I don't go into the details of that too much in this course. It's not that important and it's a bit bit Java specific.
25:14
So Interface says this isn't a class you can't directly create a page element.
25:20
Instead, this is a blueprint telling you a page limit needs to have these methods.
25:27
If you want to be a page element,
25:34
you've got to say I implement the page element interface and then you've got to provide implementations of get height, get width and get to it.
25:35
I don't know this worth me investigating this. I mean, it's one of those things where.
25:53
I'd have to go outside and find out where they're doing it, and I don't know.
25:58
I remember one time when I was lecturing, someone came and started setting up catering for a meeting.
26:07
They were like clanking plates and cutlery around. That was easier to deal with. OK.
26:11
Let's persevere. Right? So the page element in space says to be a page element.
26:18
You've got to provide these three methods and notice that these are just method signatures.
26:24
There are no implementations provided. They're just signatures for methods.
26:33
This is really annoying and what's wrong about it?
26:44
It's nothing to do with COVID or remote teaching, it's just a problem that could have happened to any other year.
26:46
Yeah, but has that happens to happen this year when it's already a little bit more difficult than usual to teach?
26:51
OK, let's crack on proposed, right? OK. All right.
26:56
Talk amongst yourselves. If we start banging the floor. And.
27:05
So we are going to be all these next couple of weeks.
27:44
So it's not OK.
28:57
We won't hear from them again, except I couldn't find them, so we probably will.
29:41
But I've said I sent someone to look for them, so. Apparently, the contractors have all been told that no such work should happen during teaching as.
29:47
OK. This is a bit like a comedy programme, I'm going to try and explain this one more time. Wait for it.
29:59
By saying in today's page element, we're saying you need to have these methods to be delivered.
30:07
But the key thing is is it just methods, signatures, they don't have bodies and an interface doesn't have any fields.
30:13
There are some caveats this there are things called default methods and interfaces, which I'll cover later in the course.
30:22
An interface can't have a static method because a static method is just kind of like a method that's
30:27
not associated with any objects and not really any reason why it shouldn't live in an interface.
30:33
OK. And an interface kind of have constant fields, final fields.
30:38
But even those caveats aside, an interface has a bunch of method signatures that have bodies and it doesn't have any fields.
30:42
As a result, you can't say. He becomes sick with a new page element.
30:49
You can't make an instance of an interface. But by the way, implicitly, the methods of public and interface, implicitly, all the methods of public.
30:54
So what is it in space then what's the point of it? It's a group of related method signatures without bodies.
31:05
And the idea is that those methods signatures specify a set of capabilities that any class implements implements in the interface promises to provide.
31:11
So if you implement an interface, then you are promising you will provide an implementation to every one of the methods mentioned in the interface.
31:23
You'll probably provide more methods, in addition, that are specific to the cost you are,
31:32
but you will provide an implementation of each one of those methods from the interface.
31:36
So let's look at how this would change our code if we wanted to document the fact that a text box is a page elements,
31:42
we'd say that text box implements page element. So this is a promise.
31:48
It's saying I text box will provide at least those methods specified in page elements.
31:53
So then the cost will arise before we'd have these fields. We'd have a constructor and then we would have the method get with because we must.
32:00
The reason we must is that page element is an interface that has a method signature int get width.
32:12
And we've said we implement page elements. Therefore, we must provide a method with that exact signature.
32:18
And we've got to provide a body for that method, too. So we provide this. Get with it.
32:24
We must provide get height.
32:28
We also must provide get ID and then we don't need to provide get max chores because having a maximum number of characters isn't a page element thing.
32:31
That's a text box thing. We are a text box, so we should provide this method.
32:43
Clients of this class probably depend on it,
32:48
but we don't need to provide this method in order to obey the promise that we would implement the paid element interface.
32:50
Does that make sense? So this is extra specific to textbox, not required.
32:57
And just in case you were wondering, I mean, you can't really put method side by side in Java, obviously this is just to make this fit on the slide.
33:05
OK. Then in. Or something to.
33:14
OK. Right.
33:22
So suppose we were to remove the get max charged method, then this code would still compile because removing that method doesn't break the promise.
33:24
If there were other causes that tried to kill the method, then they wouldn't compile. But this clause, which compile on its own.
33:36
But if we remove Getty ID, then we'll get an error from the compiler. The compiler will say.
33:42
Something a bit complicated, it says the Typekit textbooks must implement the inherited abstract methods page elements don't get it.
33:47
So for now, don't worry, what I inherited means, don't worry,
33:56
we'll abstract means this is just a fancy way of saying You said you'd provide get ID and you haven't.
33:59
You're you're not a page element. I'm not going to compile you. So we can't remove that because it's required by the page out of its interface.
34:04
OK, so. Yeah, like I said, the compiler checks whether the promise is being fulfilled by every cost.
34:15
So whenever you say that your cost implements an interface that will be checked by the compiler before the programme runs.
34:25
So unlike in Python, which I know some of you probably have programmed in where the programme can be continued
34:32
narrowly and then something turns out not to be available when the programme stops in Java.
34:38
For a lot of a lot of programme errors that caught at the time, you write the programme rather than at the time you run the programme.
34:43
Not all, but but for many of. OK, so like I said, read this message, as you said, you would provide clarity, but you haven't.
34:50
OK, in the case of menu, it's exactly the same. We say menu implements page element.
35:00
And then if we look here, then we've got these three required by page elements get it, get width, get height.
35:04
And then we've also got this method. Add option on this method is Gaussians, and these ones are extra specific to what it means to be a menu.
35:11
They're not required by the page element into this. And finally, image if we also make that implement page element,
35:19
then that means the image is promising to provide at least the methods that were specified in that interface.
35:26
And again, the width, height and ID methods. Those are the ones that are required.
35:33
If we commented any of those out, the cost wouldn't compile and then get file name is a extra method that is specific to what it means to be an image.
35:38
This is not required in order to implement the interface. Any questions about this making sense?
35:46
Hopefully, it's a pretty simple concept to grasp and was nice is this simple concept actually lets us do some quite powerful things.
35:54
So at the moment, the situation actually looks slightly worse rather than removing any duplication.
36:02
We've got a new source file for this interface and we have to write some extra code.
36:08
We have to say implements page elements at the top of each of these classes. So so far, the code isn't looking any better.
36:12
We've not changed any classes yet. But what we can now do is something really powerful, which is we can talk about text boxes,
36:18
menus and images collectively just by calling them page elements.
36:25
And if we want to do operations that don't care about the specifics of the page element they're working on.
36:31
We can describe those operations at the level of the page element interface.
36:38
And then we don't have any of this horrible code duplication. So let's see what it looks like, the document manager.
36:43
You recall it used to have three sets, a set of text boxes, a set of menus and a set of images.
36:50
Well, now the document manager can just have a set of page elements. So we have this field page elements.
36:56
It's a set capable of containing any sort of page elements.
37:01
So in particular, it can contain text boxes, it can contain menus, it can contain images.
37:06
It can contain anything that implements the page element interface. So that's much simpler, it means that we don't need to have three different sets.
37:10
We can make the sit empty on initialisation. OK.
37:20
And then the ad methods we before we had ad textbox ad menu, ad image,
37:24
and we would have needed to have introduced additional ad methods for more page elements.
37:29
When I, we just have what we just say ad page elements that takes a page element and plugs it into the set.
37:33
And we will never need another one of those methods,
37:41
no matter how many page elements classes we decide to create in the future or third party developers decide to create.
37:44
So that's pretty good. OK.
37:52
And in particular, we can incorporate more page elements without changing the document manager before we needed to add another one of these sets.
37:55
Each of the different page element types we had. But now we've got something capable of holding any kind of page element.
38:04
So as we add more types of page elements, we don't need to change this document manage across.
38:10
Even better, the Max height method cannot be implemented and a much cleaner way.
38:19
We can just have a single what we say go through all of the page elements in page elements as you age to refer to an arbitrary page,
38:24
elements to go through every one of them and ask Is its height bigger than the biggest height we've seen so far?
38:34
And if so, then update the biggest height could be seen a return at the end.
38:41
So what's really cool here is that this issue? Every time we do leap iteration, it will be a different element of the set.
38:46
And some of the elements of the set will be text boxes. Some of them will be menus, some of them will be images.
38:54
So this e will be referring to lots of different types as the programme runs.
38:58
So why is it OK to assume we can call it here?
39:03
Why is that all right? I mean, if it is, we don't have actual pay, gentlemen objects, we've got objects of particular clauses.
39:09
Yeah. Exactly, we know for it to properly implement Page 11, it has to have that message.
39:17
So therefore that method will exist if the user had misspelled that method name or forgotten by that method.
39:26
What would have happened? Compiler, thanks a nice few months that the code wouldn't compile, so we have a guarantee that when we call get height,
39:31
there will be a method available code get high no matter what the actual type of E is at runtime.
39:43
Yes, please. That's an excellent question, the question was,
39:49
does that mean we've lost the functionality for the other types of page item and the
39:59
specific functionality doesn't mean that that functionality is unavailable forever.
40:03
But what it means is that we can't exercise that functionality in this loop.
40:08
So right now, we're going through the page elements that really will be menus,
40:12
textbooks and images that really will have methods like adoption or get file name.
40:16
But at this level of abstraction, we can't see that those methods exist.
40:21
We can't call them all right. So I'd like to think about this a little bit like having different pairs of glasses.
40:25
You can put on one pair of glasses only. Let's see here.
40:30
We've got the page element glasses on, and that means we can only see the things the old page elements have.
40:33
OK, and later on, of course,
40:38
we'll look at how you can use casting when you need to to go from something like an interface type to a specific class type.
40:39
So I'll come back to that detail later. But back then, there's a question I'll come to you in a minute.
40:45
Yeah. You're going to get a midnight, by the way, this thing of using negative, what is the initial value?
40:50
Isn't that nice? First of all, it's a little bit hacky. So a different solution is to have a Boolean code first.
40:57
And you might say something like. You know that you could set this to whatever you want.
41:05
You could have a bully in court first. And in the first is true, you just set the result to be the first that you see and then you set first a false.
41:12
That's typically a nice way of doing it. But if you want to admit what you could do is you could use it to the max maximum integer to say initially,
41:18
assume the minimum height exceeded the biggest possible integer and then anything you really see will be smaller than that.
41:25
That's something you see quite often. And there was a question close to that.
41:31
Yeah, yeah. It was part of my job doesn't have pattern matching,
41:35
that's one of the I think really nice things about functional programming language is
41:41
functional programming languages is pattern matching in object oriented programming languages.
41:46
The kind of polymorphism I'm going to show you in a moment is typically what you do instead of pattern matching, but they're not directly comparable.
41:51
Right? Well, it was really more like a brute force enumeration of all the possible combinations, so that overloaded thing was really bad.
41:57
You should never you should never write Java code like that. And I'm not going to show you why you don't need to.
42:04
Oh, I see what you mean, that kind of pattern matching, yeah. OK. Sorry, I think I misunderstood.
42:10
It wasn't a pattern matching as a language feature, but what happens is when in a Java programmer,
42:14
this is true for C++ as well and many other programming languages.
42:20
When you call a method or function, the compiler says, OK.
42:24
Do I know that? Do I know about that? Is there a function of that name?
42:30
And there might be many functions of that name and then it says, OK, well, do I know of a function with that number of arguments with,
42:34
in this case, two arguments, and it might be like, Oh, what I know of yet there are ten functions.
42:39
I've got two arguments that all have got that name. Then it says which ones are type compatible with the arguments I'm providing.
42:43
And it might be that two of them are type compatible. And then what it would do is it would pick the one with the most specific types.
42:50
OK, and it would call that one. So for those of you who didn't understand that there were.
42:56
And you just read what you said about the result being minus one, like the alternative, it was not nice about this.
43:02
Is that what I mean? If there are no page elements, we're going to return minus one.
43:07
It's a little bit nasty to return minus one would probably be better to use optional ED and say which is like maybe in high school.
43:12
So we'd say if if you call this on, if there are new page elements, you get back an empty optional to say,
43:22
I don't have a result for you because I can't say what the maximum height was because there weren't any of those things, right?
43:29
So minus one is kind of acting as mine is when he was acting as the oh, there wasn't a hike to the report value,
43:34
and it's generally speaking a bit hacky and nasty to have special values of a type that you use.
43:41
You know, you've got to you'd have to write comment saying if minus one is, that means that there were no page elements.
43:47
And typically, if you have to read comments to explain the way something works,
43:52
there might be a better way you could have done it using the type system. It's not a big deal.
43:56
I mean, I've written this kind of code plenty of times and I'm still alive.
44:00
Ali, considering that page elements would have a height, what have we said the result of the height of the get out of the first page element?
44:05
Well, that was kind of what I was suggesting with that approach of using a Boolean saying first.
44:16
OK, here we've used java's enhanced four to say go through all of the page elements.
44:20
We're not indexing into the list using an integer.
44:28
We're not saying for IE equals zero i.e. less than page elements, dot size IPOs plus and then using Page Element Dot get ie.
44:30
Here we're going through the page elements in whatever order they appear.
44:38
So in this loop, we don't have a way of asking, is this the first iteration of the concept?
44:42
Is this iteration zero because we don't have an integer loop counter, so you could get around that by introducing an integer depends.
44:48
You could get around it by having a Boolean. That is true of initially and you set to false on the first loop iteration and never set back to true.
44:55
There are various ways around it. OK, but I mean, let's not get too high up on the details of this disappointing.
45:01
The main point I want to illustrate is that now we didn't have to write three volumes. We did four envelopes for and different kinds of page elements.
45:09
We've been able to just write one volume that can handle all the kinds of page elements that exist.
45:16
And the key point here is that this loop depends on there being a get tight method and there will be a get tight method because e whatever it
45:21
is at runtime is guaranteed to be a clause that implements page element and page element has got to get height method in its required methods.
45:30
So the class that implements page element that a particular E will be of will have a method of the right signature.
45:39
OK, so that's a lot simpler. The duplication is gone.
45:49
We don't have to loop separately over a bunch of different types, and then this method will work unchanged if we add more kinds of page element.
45:52
And as I said before, during execution, this E parameter, this this variable in the loop will refer to page elements of particular specific types.
46:01
But they're all going to have that required method.
46:11
And then the nicest thing of all is that this tall of that method where before we had any square, it's different overloads of the method.
46:15
Now we can just have one method we can say.
46:21
Paula then tells us where the pay gentleman a is taller than page element B and A and B just both need to be page elements,
46:24
i.e. they need to be objects of classes that implement the page element interface.
46:33
But those classes don't need to be the same.
46:39
So a when this method is called could refer to an image and be could refer to a text box because both of those classes are page elements.
46:41
And of course, that page elements A will have a get tight methods and B will have a get his method.
46:50
Those will be the same method if A and B both images. But they'll be different methods if they and about text boxes.
46:56
But the key point is that the method will exist and will be cold. Yes, please.
47:03
Is there a way to confirm that on?
47:07
You can't do that without. Yes, you can do that in Java if you use generics. Right?
47:16
I'll come to that quite near the end of my teaching briefing. Briefly,
47:21
what you'd say is you'd equip this market with a generic parameter T and you'd
47:24
say T extends page element and then you'd use T and T that instead of page.
47:29
That would be saying AB both.
47:34
We've got to have type T, the same type T and T has got to be a subtype of the page element because, well, it's kind of like the type cos in Haskell.
47:36
Yeah, but it's not really the same. So and as I mentioned, I've got a I've got a dedicated think about type classes and interfaces.
47:47
A bit later on, and I'd rather not get into the details now just because I know some people.
47:53
But the thing about virtue is the level of kind of understanding and ability vary so much across the class.
47:58
And I think as academics, we need to be a bit careful not to kind of go too deep, too early.
48:03
By the way, it looks like either they just stopped or my mate, Jeff did the job.
48:11
OK, so this is a really big win.
48:18
Before we had all these overloaded versions of the method, if we had any different page elements, we'd have squared versions of the method.
48:20
And this one methods devices, and it doesn't matter how many kinds of page elements end up existing, this one method will continue to work.
48:27
So to use the document manager costs is a little main method where I'm going to show you some code.
48:36
So maybe we make a text box with with the with the ID first text box and a thousand twenty four as its maximum characters make another text box,
48:41
make a menu file menu. We add the open option to the farm and the save is up to the farm and they can image crocodile,
48:52
which would have like a crocodile JPEG because its name. And they make it Duncan, the manager.
49:00
And what we can do here is we can add TV1 TV to phone a file menu and crocodile.
49:06
We can add those old to the document manager by calling the ad page element method.
49:11
And each time we call that method, we've got a potentially different type being passed as the parameter.
49:17
So these two calls the type of the parameter is text box in this call, the properties file menu.
49:24
Then that call the parameter is crocodile. In all cases, those parameters obey the requirement.
49:29
If we go back and look at the signature of ad page element,
49:36
it's it can accept anything implements the page element interface because TV one is a text box,
49:38
because text books does implement the page element interface, that's all good.
49:45
And similarly for the other calls.
49:49
And then what we can do is we can say the maximum height of the maximum height of any page elements is Dr. Mahmoud Adult Max Height.
49:52
All right. And what that would do is the maximum height of any pendulum is 512.
50:01
Because if we look the crocodile image, it got 512 512 and the other elements were smaller.
50:06
OK. And then if we say, is file menu taller than crocodile and then do the result of calling taller than on file menu and crocodile,
50:13
then we'll get false because file menu is I told the farming 50 tall crocodile is five hundred and twelve total.
50:24
So notice that this toll of on here is choosing. Sorry, we're passing it.
50:34
File menu and crocodile because they're both page elements. This works out just fine.
50:40
And a quick aside, is not ready to do with interfaces is if you notice document manager jobs taller than that's how you call a static method,
50:46
you call it a static method by writing the name of the class. That method lives inside that adults, then the method name and then the arguments.
50:56
So when we did DM max height as a non static methods to max height is a regular methods of document manager,
51:04
so you need to call it on a document manager DM dots.
51:13
We call DM the receiver of that method, whereas taller than is a static method, you don't call it on any particular object.
51:17
You just call it and you use the name of the class to effectively disambiguate between it and any methods with the same name in other classes.
51:24
Yes, please. You don't use two curtains for this purpose involving a job with only the only use case
51:33
for two columns is when you want to pass a reference to a method and in the next slides,
51:43
I'll show you the syntax for that. Yeah, and I think it's a bit weird that they use that syntax.
51:48
I mean, that's too cold and just so C++ ish. I was a bit surprised to see it creeping up in Java.
51:52
I don't know. I don't know. I was actually. Right, right.
51:58
OK, I have a question. Yes, please. So we're relying on the fact that both classes have a specific method because they belong to the interface.
52:05
For example, the good height. But let's see that the get height methods in each class don't return the same type.
52:15
So what is the name of the function or whatever method that the class implements?
52:22
The only thing that matters or or the return type as well, amongst other things?
52:28
Yeah, that's a really good question.
52:34
So the question was what if all of the courses is implementing a particular interface do have methods of the right names,
52:35
but those methods don't agree on, say, their return types? Or maybe that argument takes, would it then work to just assume this method is available?
52:42
Could it go wrong because you call it, but actually there is a method with that name, but it doesn't have.
52:49
It doesn't take those arguments or it doesn't return the required results.
52:54
The answer is that when you say you're going to implement an interface, you don't just have to provide methods with those names.
52:57
You have to provide methods with exactly those signatures. So in this case, you need to provide get with the returns and take zero arguments.
53:03
You can't provide a get that say we're a float instead or returns a string instead.
53:12
Does that answer your question? Yes, thank you.
53:17
Yeah. And it is not completely true. Right.
53:21
So there are when you when you.
53:25
Do inheritance in Java, you can actually provide methods that have got slightly more general types than what their interface required.
53:29
But I do think it's worth us getting into the details of that.
53:35
That kind of main message, which is almost always what matters in practise, is you have to have things with exactly the same signature.
53:37
And that includes the public and private options for the method in an interface.
53:44
All the methods are implicitly public. OK.
53:51
So in an interface to declare public or private all methods, the methods are implicitly public and it's those methods that need to exist.
53:56
OK? A more recent versions of Java. There is a use case for having private methods in space extremely rare to do in practise.
54:06
I'll briefly explain later in the course why you'd want to do it.
54:15
But for the vast majority of code you'll ever see, interfaces just have methods that are implicitly public,
54:17
and they're the methods that need to exist in all of the implementing classes. Good questions.
54:24
I'm going to get a question because I need to face this foe. So see, when you are tackling declaring an interface,
54:31
can you also require the class to have specific properties like require the car, the cars to have a particular field, for example?
54:38
You have particular fields? Probably. No, you can't, you know, just mandate that the class has got methods.
54:47
Methods, right? Yeah, right. Okay. OK, I'm going to I'm going to crack on for a few more minutes because we had so many interruptions.
54:51
And I'll get to a logical stopping point and then we'll take we'll take a break. OK.
54:59
So I already mentioned by the fact that here we're calling add page element with classes of different types,
55:03
but this works because they're all page elements.
55:10
OK, now, suppose you wanted to check in document manager that I'd passed in with the with the pages we managed to really unique.
55:13
So remember every page Edmund has got a unique ID field and it's got a Get ID method that we can use to inspect that ID.
55:23
So we might want to make sure as elements are added to the document manager,
55:30
let's make sure we don't ever see two elements with the same ID because that would violate that property.
55:34
So this would be quite easy to add, right? We could say that add page element is going to have it's going to go through all the page elements.
55:39
And if it finds that the idea of the new page element is equal to the idea of an existing page element, then it's going to throw an exception.
55:47
It's going to say, well, something went wrong that violated this property, that it only to be unique.
55:59
And then assuming that an I.D. wasn't found with the in the existing page elements, then we could add this to the set of page elements.
56:05
So the point here is that. E could be any sort of page element because it's a page element.
56:15
It will have a get it sealed.
56:21
And if the existing page element, maybe a completely different type of page element, which it will have a guest ID method,
56:24
I said field a couple of sentences about the method in both cases because they'll both have get ID methods.
56:31
We can compare their IDs and complain if they're the same.
56:37
So, yeah, this is quite powerful, it means that we can do this check regardless of the kinds of gentlemen's.
56:41
OK. Is it easy to add far the page out, so if we want to add another page element like radio button,
56:49
for example, and what changes do we have to make to the document manager to make that work?
56:55
And we think of any changes we need to do. I mean, we need to make a new radio button cost. None at all.
57:04
None. Zero changes. So this is really nice. So what are the advantages of these interfaces so far?
57:09
They help us manage the complexity of our application by letting us treat courses that are fundamentally different.
57:16
As being the same as each other with respect to the functionality they truly have in common.
57:24
So I'm not saying that we're pretending all courses are the same in all equal.
57:29
What I'm saying is that if a whole load of costs is actually have some properties in common,
57:33
then by capturing those properties in an interface and then using the interface
57:37
whenever we want to talk about any object of a class implementing that interface,
57:42
then then we can do that nicely and it can avoid a whole load of code duplication.
57:48
OK, so this means that we do this by having methods common to all the classes specified in an interface.
57:53
Every clause implements the interface and the client code could just refer to the interface without knowing or caring about the implementing classes.
58:01
So previously, in the first version, I showed you Document Manager was a client of text box and it was a client of menu
58:11
and it was a client image and we'd have to made it a client of new page elements.
58:19
Now, Document Manager is just a client of page element interface,
58:24
so it's insulated from the details of the classes that happened to implement that interface.
58:29
OK. And the key thing that we'll talk about that later the course is that the methods
58:35
it gets cold at runtime when you do a method does depend on the implemented class.
58:39
But whether the method is available or not is known when you can follow the programme.
58:44
And this is a form of polymorphism, which means treating.
58:50
Objects or data of different types as if they had the same type.
58:54
So this is a form of polymorphism and it's kind of the the key form of polymorphism used in object oriented programming.
58:59
Every object oriented programming language has something akin to interfaces in Java.
59:05
Syntactic details might be very different. But there's always some notion of being able to capture the common operations whole of otherwise
59:10
disparate classes have under an umbrella that allows us to work with this classes uniformly,
59:19
OK? Notice, though, that there's still duplication.
59:26
We had to get wet, get high and get it implemented identically in text, box menu and image to interfaces.
59:28
Don't help us remove the need for that kind of duplication.
59:37
And we'll see later on about how we can use inheritance to get rid of that duplication if we really want to.
59:40
OK, here's a checklist for you to read through in your own time. Let's take a 10 minute break, and then I'll get on with the next slides.
59:48
Can I ask a quick question? And.
59:58
OK, so I'm not giving you an introduction to Java interfaces, and there's going to be a lot more to say about Java interfaces as the term progresses.
1:00:15
However, what I want to do now is completely switch gears and talk to you about how to do a degree of functional programming in Java.
1:00:24
When did that? For two reasons. One, you're going to use it in your lab next week, and two,
1:00:31
it's good to sort of be equipped with a bunch of basic features of a language before going deep into any of them.
1:00:36
So we're going to switch gears and talk about functional programming features in Java,
1:00:42
and then we'll come back and look at more object oriented features and do a deeper dive on interfaces after that.
1:00:46
The main thing we're going to look at during this exercise is streams,
1:00:55
and what streams do is give you the ability to do functional programming in Java in a much,
1:00:59
much less elegant way than you can do it in a pure functional language like Haskell.
1:01:05
But nevertheless, the ability to use some of the nice features from that paradigm.
1:01:09
And the key thing in functional programming is that functions are first class citizens, as you know from Haskell.
1:01:14
You can pass a function as an argument to another function, and that's a very powerful thing to do.
1:01:20
And you can use operations like map and filter to process lists using functions to
1:01:24
decide how to transform a list or functions to decide which elements of it is to keep.
1:01:30
So I'm going to show you how you can do those things in Java. The Streams API was introduced in Java version eight and.
1:01:35
It's interesting.
1:01:45
They were quite difficult to fit into the language, adding streams to the language required, adding various other capabilities to the language.
1:01:48
In particular, they required adding something to interface is called default methods, which will go into details of later on.
1:01:55
And a theme I've mentioned earlier on and that will come back to a few times in the course is that it's
1:02:01
really important with a widely used programming language to make the language backwards compatible.
1:02:06
A lot of code written Java, and that code still needs to work. So there may be decisions that with hindsight.
1:02:11
Would it be good if things would be done differently when going to add a new feature to the language later?
1:02:18
But it's not possible just to go and kind of break a whole load of existing code
1:02:22
in order to rectify those bad decisions from early in the languages lifetime.
1:02:26
Simon Peyton Jones, he's one of the main contributors to the Haskell programming language, is given quite a few talks at Imperial in the past.
1:02:31
And one thing I thought was really interesting was, he said,
1:02:38
that one of the reasons Haskell is being quite successful in terms of being a nice language is that it's been popular enough to survive,
1:02:40
but not so popular that it can't be changed. He shows a nice graph of most programming languages live for a few months and then die.
1:02:47
People think, Oh, I'll create the programming language,
1:02:54
and the user base is one third language and the language dies and you get some languages by industry that don't really work out that well.
1:02:56
And then you get languages like C and Java,
1:03:03
which have been around for a very long time or even old languages like COBOL, Fortran and scientific computing.
1:03:05
There is actually a lot of code in the world written in those languages, and it's really difficult to change those languages.
1:03:10
And then you get something like Haskell that is actually, I think, becoming a bit more fixed now as it gains popularity.
1:03:15
But for a long time, it's been a bit of an experimental language that's been quite malleable.
1:03:21
Well, Java has not enjoyed the ability because it's been a pretty successful language from its inception.
1:03:26
So when streams were added to Java, they by necessity ended up looking a little bit clunky.
1:03:31
So streamers feel a bit like job is lists, but they're actually fundamentally different.
1:03:38
They're more like sequences in Scotland.
1:03:43
And there's a nice article here giving you a kind of summary of the ways that streams differ from Java collections.
1:03:45
But let's get a feeling for how they work using a number of examples. So first of all, in Java, if you were to go from a collection to a street.
1:03:50
It's quite easy. You call a method called stream. So suppose we've got a list of strings,
1:04:01
my string lists and we'd like to get a stream from that list of strings and we just call the stream method on the list of strings.
1:04:07
And I, we've got a stream of strings. What is a stream? Well,
1:04:15
a stream is a collection of items potentially ordered in the case of a stream we got from a list
1:04:19
that we ordered in the way they were from a list or potentially unordered if they came from a set,
1:04:26
the items that are available. Potentially only once.
1:04:30
So imagine a stream of data flying past you. You can expect the data as it flies past you.
1:04:35
You can transform it as it flies past you.
1:04:39
You can collect it into a collection as it flies past you, but you may not get a chance to look at it again.
1:04:41
So stream based programming is quite good if you want to say work with data that's coming from a live data feed.
1:04:47
Say a social media stream you want to be able to process.
1:04:53
I don't know all the tweets in a Twitter feed, but you don't necessarily have the capacity to iterate over that data again and again.
1:04:56
You want to process it as it comes in. But when we want to do functional programming, it's quite common we actually do have a collection,
1:05:02
we want to turn it into a stream so we can do some functional things on it and then turn it back into a collection again.
1:05:10
So in that case, you use stream to go from the list in this case to the stream of strings.
1:05:16
And then this is really clunky. If you want to go back from a stream into a collection you call the collect method.
1:05:23
That's not too bad. My string stream, not collect. But then what you've got to do is provide a collector object that knows how to collect the stream.
1:05:30
And if you want to pass, if you want to collect your stream into a list, you do collectors dot to list.
1:05:39
OK. So what I'd advise you to do, first of all, is don't really worry too much about quite what's going on here.
1:05:46
Just know if you do want to go from a stream of strings to a list of strings, you just need to call collect a pass in collectors dot to list.
1:05:52
And as you get more, experience the Java programming. Have a look inside that and try and understand actually what's going on that.
1:06:02
OK. So. Why would you do here is go through a number of examples with you and try and give you a feeling for how you use
1:06:10
dreams in practise and more importantly than creating them and collect them how you do functional operations on the.
1:06:21
The set's interface also has a stream method that turns a set into an unordered stream.
1:06:29
And then if you want to collect a stream that came from a set back into a set to use,
1:06:35
collect and you pass collectors to sex as the collector knows how to turn the stream into a set.
1:06:39
So let's use a bunch of examples to see the features the streams have in practise.
1:06:48
ActionScript of places, yeah, you can't get a stream is just a bunch of data collected knows how the data will arrive in some order.
1:06:56
And if you do, collectors dot the list and the you will get a list that contains the elements from the street in the order that they arrived,
1:07:06
and it will be distinct from it will be destroyed from the set of elements that you started with.
1:07:14
Yeah, when that first step is to.
1:07:18
Actually, the yeah, this is a class,
1:07:26
and then that is a static method of the class so that the class has got a static method that returns an object that is a collector.
1:07:32
Yeah, sorry. And we don't want anything to use to collect this stuff.
1:07:42
Yes, you do. Yeah. And we'll look in some code examples in a minute, but what you need to import that.
1:07:48
Least, does it make it's to the streets adjacent to the street?
1:07:55
That's true. Well, the in the collection's framework, you can't turn a string into a string.
1:08:05
You can try to listen to a stream of content assets into a stream and contain any collection to a stream.
1:08:12
And if you take a set and turn it into a stream, you get an unloaded stream.
1:08:16
Whereas if you don't listen to a stream, you get an audio stream. These differences can be important depending on what you want to do with the stream.
1:08:20
Here we go. OK. And you can have like duplicate objects.
1:08:29
Sagan didn't have duplicate object and you have duplicate objects in the stream.
1:08:33
Yeah, you can. So, yeah, if you if you take a list, a list can have duplicates if you stream, unless you get everything that's in the list.
1:08:38
In the same order, it was originally in the list, including duplicates. Yeah, OK.
1:08:45
So I wanted to show you a couple of ways that we could double the elements of a list.
1:08:50
So I'm going to go into intelligence, and what I'm going to do is just, I'm going to make a new package here.
1:08:55
I call the package streams. And here I'm going to make a class.
1:09:03
Code demo in this lecture, I'm not really going to be doing kind of traditional object oriented programming,
1:09:11
a more showing you how streams and functional programming features work in Java.
1:09:18
So I'm just going to do all of this stuff in a class called demo,
1:09:23
rather than making lots of different classes and do a lot of programming in just one file,
1:09:27
which is fine for showing you how the functionality works, but not particularly good software engineering practise in general.
1:09:32
OK, so what I'm going to do then, is I'm going to write a method for doubling the elements of a list.
1:09:39
So I'll say here static double list elements.
1:09:45
And what this is going to do is it's going to take a list of integer. And I'll make it return.
1:09:50
List of integer, as a result, the code is in compiling because I've not imported the list interface and what you can do with any IDs is
1:10:02
use a shortcut to help you so an intelligent you enter then only out and to look out and to import costs.
1:10:10
And I can import list doesn't know which list I want. Don't want list from the UTIL package.
1:10:21
I do. What do I want? A list from the abstract windowing toolkit? Well, definitely the UTIL package.
1:10:27
So you need to know what you're doing now. OK, so what we do here is, we'll say, list integer results equals new ArrayList.
1:10:31
I know the array list just got imported there thanks to my I.D.
1:10:43
Knowing what I wanted to do, given me an altered copy option and me accepting it and the import happening automatically.
1:10:47
And ultimately, let's return that.
1:10:53
OK, and then what I'm going to do is I'm going to go through all of the entities in this list, so I can say for integer I integers.
1:10:58
Results to add items to. So let's just check that that's working out your main method.
1:11:09
And I can say blessed integer. My integers.
1:11:20
Because list of one, two, three, four, five and then system out of print, Alan.
1:11:29
Double list elements might introduce, so we should expect to see two, four, six, eight 10 get printed.
1:11:42
OK, fine. So we saw a two, four, six, eight, 10 tonight, so that was using less imperative programming, but we step by step did our computation.
1:11:55
We had a 40 where we marched through the elements of the list.
1:12:04
Average this element, we doubled it and added the result to our new list, so I'll show,
1:12:09
you know, how we could do this in a more functional style using a map operation.
1:12:14
But maps are only available, mapping is only available on streams. So what I'll do is I'll copy paste this function.
1:12:19
And I'll call it double list elements with Stream.
1:12:28
And obviously the body. So all we want to do here is we want to say, well, we're going to go from our insiders.
1:12:34
To a stream. They want to do something.
1:12:43
And they wanted to collect. To list.
1:12:49
OK. Are we going to return this whole thing?
1:12:58
So we want to say we're just trying to introduce into a stream. We do some operations on that stream and we'll collect the results into a list.
1:13:02
And that's what we'll get a return. Now the question earlier, I can't remember what it was about.
1:13:10
What was it used to do with these reports, the collectors? Someone someone asked me to import collectors.
1:13:15
And yes, indeed, you can see here that. It added It's going to be automatically by an import of Java utils stream collectors.
1:13:21
Yes, please. It's. Is it important to.
1:13:30
Is it OK to import anything you need? Do you mean like doing a star import like import Java Util star?
1:13:37
Yeah, I mean, if you need to use a list, if you don't import programme would compile. You'd have to implement your list from scratch otherwise.
1:13:48
So we do when we programme, we do rely heavily on our collections frameworks.
1:13:55
Yeah, no. Maybe if you're if you're working on some development projects, maybe that there's some library,
1:13:59
there's non-standard, provide some things that you'd like to use and whether or not you want your project.
1:14:05
And I depend on this library, that might be a discussion to have with your collaborators.
1:14:10
But using the standards libraries of the programme and and you're working in is absolutely normal practise.
1:14:13
OK. So what we're going to do then is a map operation on a map, a function over the stream.
1:14:20
And the function we want to do, the function on a map is basically time is to right.
1:14:31
So we can't do this in Java.
1:14:36
Unfortunately, it's not times to, but that's roughly what we want to do on a map function that multiplies by two over this this string.
1:14:38
So what we'll do then, is we'll make a little function called times two.
1:14:47
So you can say static int times to its X return x times two.
1:14:50
OK? And it brings out a B side. You know, I'm using integer and using integer here.
1:15:00
OK, in Java, Int is what's called a primitive type is a type that's built into the core of the language representing 32 bit integers.
1:15:07
Integer and contrast is a wrapper type is a class, and it's got a field of Typekit, so it's a wrapper for the primitive type you control.
1:15:16
Click on it. I'm not sure whether we'll get to see the source code for this class.
1:15:26
Yeah, we can see the source code, right, so you can see that we've got this clause integer.
1:15:32
It's got a lot of constants like the minimum value and the max value.
1:15:36
And if we scroll down, you see there's a field private final value, which is the value of the integer.
1:15:39
OK. So the reason the integer exists is that int it's not a class type and therefore here X is not an object.
1:15:46
X is a primitive value, whereas this list integers can only store objects,
1:15:56
so collections in Java can install objects, you can't have a collection of primitives.
1:16:04
So if all of the primitive types the language includes object wrappers rack
1:16:09
those primitives inside an object so that we can use them with collections.
1:16:14
And as of version, I don't know, like quite a long time ago in the language,
1:16:18
this support was added to let you use primitives and wrappers mainly interchangeably.
1:16:23
So when a method requires an integer with a capital, I.
1:16:29
And you pass it and say two, and the compiler behind the scenes will make a new object rapping about it for you.
1:16:33
And similarly, if a function needs an input parameter and you pass an integer object,
1:16:40
the compiler will silently insert a call to get value that will actually take the value wrapped inside the integer and pass it to that parameter.
1:16:45
So you don't need to worry too much about this, but I thought it was worth mocking them.
1:16:53
So we've got these times to United, and what we can do here is we can pass a reference to that methods to the maths method.
1:16:57
So we can say gamma, which is named of lost and then colon, colon and then times to say,
1:17:05
Hey, we're passing the times to method as an argument to mark.
1:17:12
So we're saying return integers stream dot mark times to dot,
1:17:17
collect collectors to list so tiny and turn entries into a stream map the operation of multiplying by two over them and collect them back into a list.
1:17:22
Sort of for quick, quick question. Of course. Do we have an arrow function in Java?
1:17:32
The arrow function in Java? Are you talking about lambdas? Are you allowed to say Yes, we do.
1:17:38
We'll come to that shortly. OK, so let's just check the reasons, do you get to say,
1:17:42
why did you have to do like colon colon or that instead of like, I'll let you go over that in a moment?
1:17:48
So let me just check the eye and get two four six eight 10 six.
1:17:52
These operations are performing the same computation. Why did you do colon them?
1:17:57
So here what I'm doing is I'm saying I don't want to call the Times two method.
1:18:04
I'm not saying call times two. I'm saying Matt needs a function that is going to mark over the stream.
1:18:08
And here I'm saying I want the times to function from the demo, cos that's the function I want on colon.
1:18:15
Colon is the syntax that the Java design is chose for saying which method you want when you're passing a method reference to a function.
1:18:24
Right, and I suppose the reason they did it is that demo could have if we did a demo block times two.
1:18:33
That's not that's not legal syntax here. But if Demo had a field write code times two, then that would mean the times to field a demo.
1:18:41
Two dots could be a bit confusing. So code on code isn't used for any other purpose.
1:18:50
And as one of your colleagues mentioned, it's used in C++ for somewhat similar purposes.
1:18:55
So the syntax probably uses. OK, so these are this is maybe not exactly the code I coded up in intelligence, but roughly.
1:19:01
And here we are mapping with a method reference. Right.
1:19:12
So by writing this method called Times two, by passing a reference to Times two, we've said to the map function,
1:19:16
I'd like you to call this function for every element of the stream and retard a stream of the map results.
1:19:25
So what's happening here is that from this list integers, we're getting a stream of exactly those integers,
1:19:35
and Mark is giving us a stream comprised of integers from that stream after they've had times
1:19:40
to apply to them and collect is receiving that stream and bagging everything up into a list,
1:19:47
and the list is being returned by the double elements function.
1:19:53
OK, so to go into a bit more detail, if you've got a stream of some type a like stream, string my stream.
1:19:58
And then if we've got a method that accepts something of Taipei and returns something of type B.
1:20:07
For example, First Letter, which takes a string and returns a character by giving the character zero of the string.
1:20:14
This is a function from A to B, where a string B is character.
1:20:22
Then if we map the method over the stream, we get back a stream of bees.
1:20:27
So if we have a stream of A's and we map. That stream using an A to B function, we get back a stream of bees very similar to how in Haskell,
1:20:33
the signature for a map requis takes a list of A's and a function from A to B and gets back a list of bees.
1:20:42
OK, so if we do my stream dot map example code colon first letter,
1:20:49
then we get back a stream of characters that would contain the first letter from every string.
1:20:54
It was in the stream. Well, it's pretty vocal about how many illegals this method seems times to just so we can do a method reference call.
1:20:59
That's kind of overkill. So let's have a look at how we can use the lambda targets more concisely with someone asking a question on Zoom.
1:21:11
I'm yeah. Could I ask a question with regards to streams? Yeah.
1:21:20
So with regards to the CSA, we take the time to function as an instance.
1:21:25
What? What was it on time comparison of the imperative implementation and the functional implementation?
1:21:30
Well, the computational complexity will be the same. The same amount of work is being done overall.
1:21:37
It's likely that there will be a bit more work involved in doing the streams implementation
1:21:42
because behind the scenes there is some kind of indirect function calls going on.
1:21:46
OK. But you know, you're not going to see a fundamental difference in performance because of that extra overhead.
1:21:50
So, yeah, I suspect there would be a little bit more overhead in using the streams approach compared with using the imperative for live approach.
1:21:59
But as I mentioned in the first factor, premature optimisation is the root of all evil.
1:22:06
So I strongly advise you not to worry about performance unless you actually need to.
1:22:12
So if you're writing a really high performance application, I mean, might you might not want to write it in Java.
1:22:16
If it's super high performance, you might want to write it in C++ instead. And even if you're writing in C++,
1:22:22
try and actually work out where the time is being spent before you start worrying about whether the code is efficient.
1:22:26
OK, fine.
1:22:33
Do what we can do instead of using a method reference is we can use a lambda, an anonymous function providing the operation we would like to use.
1:22:34
So I'm going to go back to intelligence here and I'm going to get rid of times to.
1:22:43
And instead. Of passing a reference to Map.
1:22:50
Well, I'm going to do is I'm going to say Item Arrow Item Times two, right?
1:22:54
So what this means is take item to item times two.
1:23:01
That is the way this function is defined. So this is avoided us giving the function a name.
1:23:06
So we didn't think of a name for the function. It's also a US introducing a function that potentially other bits of our code could call.
1:23:11
And that might be a good thing or a bad thing. It might be that we don't really want them to call the function.
1:23:19
So by not giving it a name, we're not allowing them to.
1:23:23
Or it might be that this is going to occur all over the place, in which case it would be better to have a function and use method references.
1:23:26
So there's just an alternative syntax here. The compiler is working out.
1:23:31
That item needs to be an integer for this to work because integers was a list of type integer.
1:23:36
Therefore, after we applied Blockstream, we get a stream of integer.
1:23:43
And therefore Mark needs to take integer to something.
1:23:48
So it's a must be integer. And it sometimes too is for integer two.
1:23:51
OK. And in Java, you can specify the types of parameters if you want to actually do this.
1:23:57
So rarely that I'm ashamed that I can't remember the syntax I think you would do.
1:24:03
Hmm. Maybe do the interior first. Now I need it, OK,
1:24:09
so it's easy you can say what the title of the lambda parameter is actually
1:24:15
extremely rare to needs to do that an almost always obvious from the context.
1:24:20
And so I don't recall it off the top of my head. So this works just the same.
1:24:25
And just to show you, if I would change this to two times three, then we should see in the second list three, six, nine, 12, 15, etc.
1:24:32
OK, so this is an example of mapping using a lambda. And there's nothing special about using item we did,
1:24:43
he could he have done x most x times two items or X is just the name of the parameter to the lander.
1:24:52
All right. So let's have a look at mapping strings to integers, so we might have a function to integer.
1:25:01
It's going to take a list of strings, a return, a list of integers under the assumption that the strings have got integer value.
1:25:10
So they've got a string might be one zero for the integer 10, for instance.
1:25:17
What we could do that is, we could say a stream of strings and we could map the pause in its function from the integer class to to the stream.
1:25:21
And that will give us back a stream of integers which we could collect into a list if one
1:25:31
of these cores and fails because the one of the strings is not convertible to an integer,
1:25:36
then an exception will be thrown.
1:25:42
And we'll yeah, but just as would happen if you would go through, say, the strings in a loop and try and convert each to an integer you present.
1:25:44
And alternatively, we could use a lambda that calls parse it.
1:25:54
So here I've passed into your colon. Colon isn't a reference to the present method.
1:25:57
Here, I've said. An anonymous function that maps an s to interject, pause and s so which of which do you get preferable here?
1:26:04
Style wise. Places. The method reference, I'm why do you think that?
1:26:15
Not having to introduce another sanction, right? Yeah, so I agree, right?
1:26:27
I would say that using the the method reference is better because we really do want to pause it over the stream.
1:26:31
So and that function is available directly. We can use it unmodified. That's exactly what we want.
1:26:39
So this is exactly we want to do. This specifies the same functionality in a more roundabout way,
1:26:44
and it offers it's unlikely that it offers the possibility that we could end up making a mistake here.
1:26:50
And I don't know. SE plus hello or something, right?
1:26:55
We could we could do something silly here, which we can't do that. So we're not naming the item that we're mapping in that case.
1:26:59
So method references make sense if the method you want to map just is already exists.
1:27:07
Lam does make sense if the message doesn't exist yet, and for whatever reason, you don't want to make it exist,
1:27:12
maybe because it would be so trivial not to be worth it or because you actually don't
1:27:18
want it to now become another message that your programme could call or generally.
1:27:21
OK, I want to show you something quite cool, which is mapping using an instance method.
1:27:27
So say we've got an object of type like Class A right and an inside a there's a method called Fu the return something of type B.
1:27:30
So Fu here looks like a zero-carbon method, a method from no arguments that we're trying to be.
1:27:40
But if you think about it because Fu is an instance method, i.e. not a static method, you've always got to call Fu on some object.
1:27:47
You'd always do x dot fu. You never just do fu.
1:27:55
So you can think of the receiving object as being like an implicit parameter to Fu.
1:27:59
So we can think of a zero argument method on an object of Taipei returns.
1:28:05
B, we can think about that as being a transformer from an A to B, and we could use Fu to map a stream of A's to a stream of BS.
1:28:12
So to give you an example, the string class has got a method to uppercase that will return the same string, except every.
1:28:23
Alphabetical character will be turned into uppercase if it wasn't already.
1:28:31
So if we've got a set of strings, then we could implement a two upper method like this, right?
1:28:35
So two upper, it's going to take a set of strings. It's going to stream them and then it's going to mark.
1:28:40
Using the two uppercase method of string and then collect them back into a set.
1:28:47
So what's going on here? Two uppercase. So we're mapping from string to string here just to uppercase.
1:28:52
Take a string to a string. What does it look like? It right?
1:29:00
It takes looks like it takes nothing to a string, but actually you always call to uppercase on a string.
1:29:03
So from that point of view, you can see it as a string to string method. I think maybe I will.
1:29:09
I'd like to just make that point in slightly more detail using a little coding example.
1:29:15
So. I think the main here, right, but say I do static.
1:29:24
Two upper taking a set of string. And if I would do is get a return set, Mr.
1:29:36
If I would do return strings, don't stream. What map?
1:29:49
String to upper case. Collect.
1:29:56
Collectors to set. So that's the that's the stuff I showed you in the slides.
1:30:02
And if you're having trouble understanding what I said about why is it OK to remember that in the spin class, we've got so costs string?
1:30:06
And in that class. Somewhere. You'd have.
1:30:18
String strong string to upper case.
1:30:25
Somewhere in the stream course, we have that method declaration. So our method looks like it goes from nothing to string.
1:30:31
But what I'm arguing is it really goes from strength to strength because you
1:30:38
always call it on a string and to try to make that point a bit more explicitly,
1:30:42
I could rewrite this in a lambda as follows. I would do say s arrow s got to upper case.
1:30:47
If I write it that way, then I think it's more obvious, right? For every industry, we're going to call s dots to uppercase.
1:30:58
And an equivalent way of writing that which intelligence is encouraging me to do is
1:31:07
to replace LAMDA with method references that do string quote unquote to uppercase.
1:31:10
OK. Something that is quite rare,
1:31:16
but I think is kind of cool is that you can think of a constructor as being a method
1:31:21
from its argument types to the type of the thing it constructs and in particular,
1:31:28
if a course be. He's got a constructive that takes a single parameter of Taipei,
1:31:33
then we can view that constructor as an HP transformer and we can use it to map a stream of these to a stream of bees.
1:31:39
So, for example, the integer class has got a constructor that takes a string.
1:31:47
And what that will do is it will throw a number format exception if the string doesn't contain integer data.
1:31:52
Otherwise, it will make an integer wrapping the the value of that integer value inside that string.
1:31:57
So this will pause the string. I'm retired it a suitable integer.
1:32:03
If the string indeed has it got integer contents, so we could use that to map strings to integers.
1:32:08
We could write a two integer method that takes a set of strings,
1:32:14
returns a list of integers just to note here that we can stream it from a set and collect it into a list if we want.
1:32:17
And what we're going to do here is we're going to stream the strings and we're
1:32:27
going to map the integer constructor by doing integer code and code on new,
1:32:30
and then we're going to collect that into a list. So if you want to pass a constructor as a method reference, you do the quasi colon code on new.
1:32:36
All right, and then, well, the compiler will do is it will say, OK, we're trying to map.
1:32:47
Over a stream of strings, does integer have a constructor that just accepts a string?
1:32:52
Oh yeah, it does. It's got this constructor. So that's the that's the function I will use to do my mapping.
1:32:59
So quite unusual, but I think kind of nice. All right.
1:33:05
Something not so nice is actually that constructor where you make an integer from a string,
1:33:09
that construct is actually deprecated and so fine to use it in an example when you are lecturing,
1:33:14
but not good to use it in code, you're actually writing in the real world. And a quick note on deprecation I mentioned how would languages.
1:33:20
It's really difficult. This balance between keeping backwards compatibility and also letting languages
1:33:27
evolve and deprecation is one way of trying to help manage that problem.
1:33:31
The idea is that the language feature appears to have been a mistake with hindsight
1:33:38
or if a particular function in a library is something we wish we had provided.
1:33:43
We can say this function is deprecated, which can mean it's its usage is likely to lead to errors like it's a dangerous thing to use,
1:33:47
or it may be changed or completely removed in a future version.
1:33:55
Some languages will give a warning and say in five years time, we're actually going to remove this from the latest version of the language.
1:33:59
Heads up, you've got years to potentially change your code, but sometimes it does take years to change big applications.
1:34:05
Well, maybe this is just a better, preferable alternative you could use. That's the case in this example as pies, for instance.
1:34:11
Or maybe it's obsolete, so it's just not regarded as useful some baggage we'd like to eventually remove from the language.
1:34:17
OK. And I want to know that man returns a stream and we can apply not to that stream again.
1:34:25
So for example, if we had an emphasise method, it's going to take a list of strings,
1:34:31
then what it could do is it could make every stream become uppercase that were retired, a stream of uppercase strings.
1:34:37
And then we could map a lambda that will enclose every string in asterisks that were written on another stream of strings.
1:34:44
We could collect that into a list. So this would transform hallow programming to cross into hello programming to cost with a yelled.
1:34:50
OK, so no, here you could write this as a single map and you can use a lambda to go from SW to spot to uppercase enclosed in asterisks.
1:34:58
So sometimes you might find it easier to read your code if you're showing these different transformations as different mapping steps,
1:35:10
there's not really a right way to do this here. OK.
1:35:18
Is 15:47.
1:35:23
No, I really hope to have gotten to the end of this decade slides by the day because you're going to do functional programming in your lab next week.
1:35:25
Unfortunately, we lost a lot of time on Tuesday with all the teams kerfuffle and I would say
1:35:32
probably did lose like a bit more time because of that annoying drilling today.
1:35:36
So I could go on for like one or two more minutes, and I'm trusting you again on Tuesday.
1:35:40
So I think you should be able to make a good start on your functional programming
1:35:44
lab next week with what I've told you even before I teach you on Tuesday.
1:35:47
But we'll definitely get the material you need for that lab finished on Tuesday,
1:35:51
so apologies that we're a little bit behind schedule and let's just use the remaining one minute just to get slightly less behind schedule.
1:35:54
OK. We can also do filtering on streams to kick out elements of a stream that don't satisfy a particular property.
1:36:02
So a predicates over a Type C is a method from that type to the Boolean saying whether this method,
1:36:10
whether that an element of that type satisfies the predicate or not and what strain has is a filter method that takes a predicate method,
1:36:19
and it returns a stream only containing elements that satisfy the predicate.
1:36:28
So elements that don't satisfy the predicate get filtered out.
1:36:33
So I kind of like to think of streams as a production line where I need a mapper or a filter,
1:36:36
OK, and I'm watching here and these things are flying past me, and they may only be available.
1:36:41
They may only be available once.
1:36:45
If I'm a mapper, I'm doing something to every element as it flies past, you know, like change it, change it, change it, take it, take to change it.
1:36:47
And if I'm a filter, then I'm kind of looking at them and some of them I'm squashing, right?
1:36:53
So anything that doesn't satisfy the product, I squash it. And then the next stream.
1:36:56
This return could be consumed by another macro or filter and the next stream.
1:37:00
Its return could be consumed by another map. And.
1:37:04
This mental model, I think, is useful because when I say the mat returns, another other stream and filter returns,
1:37:09
another stream that might make you think that all of the data gets processed and then there's a new stream that gets processed completely.
1:37:14
But actually, it's possible for the streams to be implemented in a way that avoids that data could be being processed in parallel, for example,
1:37:21
by the early elements of the stream can be being processed by future stream
1:37:28
operations as later elements are being processed by early stream operations.
1:37:32
OK. So filter it takes a predicate and filters elements of the stream.
1:37:38
So for example, if you were going to filter out offensive words, you I have a programme like this filter bad words.
1:37:43
It's going to take a list of strings and it's going to take a set of bad words.
1:37:49
And what we want to do is give back just the sub list.
1:37:54
It doesn't contain any of the bad words. So what we could do is use alarm to have, he could say, stream the words and then call filter.
1:37:59
And as our predicate, say, we keep the item if it's not contained in bad words and then collect the whole thing into a list.
1:38:07
So if we love object oriented programming, hate functional programming,
1:38:16
then we might say we've got these bad words like Haskell, Moon Funked Oakamoor and Lambda.
1:38:20
Maybe we quite like Whack-A-Mole because it sort of cheats a bit and it's a bit less pure. But we definitely do want the other things OK.
1:38:24
And then filter by Boyd's job and has lambda capabilities. Then that would eliminate the word lambda, right?
1:38:30
Because that's in our list of bad words. I speak completely in jest here.
1:38:37
I taught concurrent high school last time to Veritas, and I really enjoyed getting into Haskell, I think is a great language.
1:38:41
OK, but anyway, that's how filter works. So on that note, have a good rest of the week.
1:38:47
See you next week. What we know that.
1:38:52