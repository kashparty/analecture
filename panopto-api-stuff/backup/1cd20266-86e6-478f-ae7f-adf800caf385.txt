ID: 1cd20266-86e6-478f-ae7f-adf800caf385
Title: idb-topic-08-sql-set-operators
Category: COMP40007 - Introduction to Databases (Autumn 2021-2022)
Lecturer: Peter McBrien
Date: 08/12/2021
This topic looks at the operators provided by Eskil to specifically test for membership of and the values held in sense,
0:02
the most basic set operator is the inn operator,
0:14
which allows you to test if a particular value belongs to a set in ask you well, set up a notice to notice by using round brackets,
0:17
so the list 100 one is in fact describing a set of values contained in those two to account numbers.
0:25
And this query here will be checking for those rows which are in the account table,
0:34
which both have type equals current and have a number appearing in that set and of course, will return just to count 100.
0:39
For the example, bank branch data base dataset you've only seen.
0:46
So this query got the new normal circumstance where the values in the set are going to be generated by a subcommittee.
0:52
The sub query must return only one column in order to generate a set of values which can then be tested against using the in the inner query.
1:01
Here will be generating the numbers from the movement table,
1:11
which have an amount greater than 500 and therefore contain 100 101 twice and one one nine.
1:14
This is a matter that 1+1 appears twice. It has the same semantics because here I'm just testing whether the number
1:22
appears in that set of values and hence the effect of this query will return
1:27
again just to count 100 because it's the only account number that is both type current and appears in the set of values 100 101 and one one nine.
1:33
This query is equivalent to doing a joint between account and movement, where I'm checking that the amount is greater than 500.
1:48
But of course, if I approached the query in this way, I might find that some accounts,
1:57
such as Account 101 for our dataset will, which will be matched more than once against the movement table.
2:01
And therefore, I need to insert a distinct against the account number to avoid duplicates being turned to make it equivalent to the original query.
2:09
Now let's look at what happens when we use negation. With the set operators.
2:19
The most popular answer when this was run before is C, and indeed that is the correct answer.
2:31
And that's because here the Nottingham query is not equivalent to doing not join.
2:38
In particular, when I run the enquiry query, I get the set 101 one hundred and one one nine.
2:44
And if I look at the set of current accounts that exist in the database, that is the set of values.
2:51
One hundred one two three one two seven and one two five,
2:56
I find the only account 100 is not in that sense and therefore I gather the count is in that
3:01
setting and therefore one two three one two seven and one two five are going to be turned.
3:10
Whereas if I wrote it using the Join First of all account, one two five would not be included because it does not join with the movement.
3:15
Typekit has no movements at all.
3:25
And secondly, I would be returning account 100 because it does have a row with has a mount that's not greater than five hundreds.
3:28
For two reasons, I get an answer different from the left hand query.
3:37
The Exists operator allows me to test whether a set is empty or not.
3:45
So, for example, if I consider the query on the left, which is attempting to find a customer names which do not have a deposit accounts,
3:52
I can see that the semantics of the inner query are to list the customer names of people who do have a deposit
4:00
account and therefore the out of query will be testing for some names which do not have such a value.
4:08
And so I find that Boyd and Bailey are going to be returned,
4:14
and that would be equivalent to running query where I test this set of values generated for each customer to which of time,
4:19
deposit and share the same customer name are empty.
4:29
Let me explain this so-called correlated sub query in a little bit more depth because they are complicated to understand.
4:33
So here what happens is conceptually at least you go through row by row of the outer table and execute the inner correlated query.
4:41
So considering the first row of the account sabre, which contains the C name Mac Brian,
4:52
I would execute the sub query in the sub query now takes an alias of the account table,
4:59
calls it deposit accounts sort of sit down to have typed deposit and then checks the C name of deposit account.
5:04
That's the descent. The ambiguous reference to see them will bind to deposit count equals the name of the outer account table.
5:13
And of course, there is a row where we have McBrien, Brian and deposit.
5:22
Therefore, this set here will return. One row, then not exists will fail.
5:27
And therefore, Matt Brian cannot be returned as a value for the app to a query.
5:32
Whereas if I consider boyed when I come to Boyd as an account,
5:39
the inner query will generate no values because there's no instance in deposit account which both has time deposit and the name the.
5:44
And therefore this is an empty set and Boyd can be returned, as can be.
5:56
It should be noted that when you look around for queries, using these operators not exists will be far more common than accept,
6:06
and that's because not exists has been in the school language for far longer.
6:14
So in particular, queries of the form select from account except select from another table can be rewritten as select from the first part,
6:19
except with a where clause that tests of the certain parts of the query does return no values via a correlated query,
6:30
which is matching the first part.
6:43
So here the number is going to be referring to the numbers in movements and comparing it to the numbers in the account table.
6:46
The last set operators I want to introduce are the sum and all operator,
6:59
and what these allow you to do is check if the value matches all the values in the set or some of the values in a sense.
7:06
Listen, consider this query, which is intended to find branches that only have current accounts.
7:14
Again, we have a correlated sub query, so we consider this row by row and as we go through the first row of the branch table,
7:20
which is 56 in the example dataset running the sub query will generate made the set of types which have to sort code equal to 56.
7:28
And of course, that will include current and deposit and therefore the current equals.
7:39
All the values and set will fail because count doesn't equal deposit.
7:46
Come on to select look at 34. It generates the set,
7:51
which contains just one value current and therefore the all operator will succeed because current equals all the values in this set,
7:57
and therefore it will be returned to the branch. Then on to the second example here.
8:07
Using some, the correlated sub query works in a similar way that we go through each row of the branch,
8:14
but now we're testing whether the value on the left equals some of the values generated in the set.
8:22
So considering Saltcoats 56, the the sub query generates current and deposit.
8:29
Of course, there are both current and deposit values for sort code 56 and of course, deposit equals some of those values.
8:35
Equal equals one of them, and therefore Saltcoats. The branch is 32, so 56 Wimbledon will be returned.
8:45
A future date will not be returned because I do not find deposit in the set of types generated for source code 34.
8:52
But Strand will be returned because I find deposits in the set of types generated for source code 67.
9:01
OK with that, do you have enough information to attempt the worksheet on set operators?
9:10
And I suggest you try this as an exercise where you connect to the PostScript database and as you generate queries for the worksheet,
9:15
you try them out on the Post Quest database.
9:23