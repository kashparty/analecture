ID: 107d69dc-39c0-4459-9a17-adce00cd0dab
Title: Haskell data types-20211026_090324-Meeting Recording
Category: Haskell
Lecturer: Anthony Field
Date: 27/10/2021
OK, good. So welcome back. So we got to the end of the higher order functions, but I thought just before we move on,
0:11
I would just go back and look at one example we studied earlier, which is the where is the function?
0:18
It was me.
0:28
Thirties, so look at this example here on slide 106, you see that there is an example of a partial application of L.N. using the map function.
0:34
And what we're doing, those are saying is, is the character e a member of Know the strings.
0:42
No, no. Again and yes. So you get false, false and true for obvious reasons.
0:48
You might think, well, you can see what you've done, that you've frozen the E and you're asking whether e that fixity is a member of three strings.
0:53
Of course, there's another way I could do that.
1:02
I have a problem which is kind of the other way around, where instead of fixing the thing I'm looking for, I fix the string.
1:04
I'm looking in SPER with me so I can see it.
1:09
I can fix the string, I'm looking.
1:13
And so supposing instead I wanted to do something like this where I'm trying to get the element of so instead of the instead of the character,
1:15
I'm looking for being fixed, maybe this changes. So maybe I've got.
1:26
So I've got. Something like that, so that the search character changes, but.
1:33
The thing I'm looking in is fixed, so, for example, the string, I mean,
1:42
might be fixed in this particular problem, so that might be something like cat and cat here.
1:46
Yeah, so I would expect to get here, true, and I expect to get here false and not expect to get here.
1:53
True, for example. Now, the trouble is, if I tried to construct a map for this thing, something of the form map.
2:00
Does it over? Well, what I'm trying to do is to map it over A and T now, because those are the letters,
2:09
the letters, the letters I'm looking looking for are now changing. Well, I can't just write cat in here.
2:16
Because it's the wrong way round, because L.M. says, you give me an item in this case,
2:24
you give me a character and string and I'll tell you whether I can see the character in the string.
2:29
Well, that is wrong now, because now that I've got the string first and then one by one, I'll ask for A and T, that's what I want to do.
2:32
It was with an element. So of course, for example, if I said L.M. Cat.
2:43
And then that would just be a typo. Yeah, that's wrong, it's a typo.
2:50
So is there some way I can fix this? Well, an obvious way to fix this would be to go and do something like, well,
2:56
I could define an island function where instead of having an item and a list and I say is the item I work,
3:04
it's like it's about the same function where these two things the other way round.
3:11
So I X and X's Pantex, I could define the function the other way round, perhaps primate's.
3:15
So it's a different function. Yeah. And you know how to do that. Now you could write a function that does that, perhaps using some girls and so on.
3:20
There's a bit of a pain isn't it. I'm not saying have to invent a new function,
3:26
which is just a simple variation of an existing function in order to solve a problem that I can almost solve using the conventional apparatus.
3:30
So what you try, if you think about what you're trying to do, is construct a version of Islam where the X and the X of flip the other way round.
3:37
So X is X. So another version of Islam where the two arguments are reversed, if you like.
3:44
Well, it turns out there's a wonderful harbourer function which does this, and it's called flip.
3:49
So Flip says it's defined. You can pretty much define it.
3:54
Actually, I'm going to get a name clash, but pretend I'm defining it so I can say, well, Flip says,
3:58
you give me a function and it's two arguments and I will apply the function with the arguments the other way round.
4:05
So in other words, you can think of Flip F.
4:14
As a function which given its to operate, I think you think of what flyhalf means now flip because you know, I come down here.
4:17
Well I won't, I won't. It's actually already defined in the past by just coming out.
4:25
Just segment. Oh for goodness sake.
4:30
OK, so now come down here and. Well, actually, it's OK, I can say what's.
4:37
So what is the type of flip? Just have a look. So this is the built in flip looking at now so it as I'd expect.
4:43
Here comes a function of two arguments and I debate to see it just to protect us against other problems like a in the
4:49
bay and just doing an application it takes to be in the air and then applies the function with its arguments reversed,
4:56
as you would expect. So that's literally how it's defined in the in the you can go and look at it.
5:02
So how might we use it to solve our problem? So what was the problem?
5:10
I was trying to construct I was trying to get on top it out now, trying to get a cat, and then the next one was in Cat.
5:13
This is what I'm trying to construct and then go out of teams for one and then, OK, so I'm trying to do that and get true, false, true.
5:27
You'd expect so what? I'd like to be able to do it.
5:38
It's clearly a map in there because I'm doing the same thing to every element of a list.
5:43
There's some sort of map going on. I'm mapping some fun mission over the string and see the characters.
5:47
And then. And then.
5:53
And then t and what I like to do is an element here, but I can't use the alarm directly because it's all like arguments would be the wrong way around.
5:54
So here's the trick. I just flip it and then I give it the string that's fixed which is the cat and that pops both Truffaut's.
6:02
And if that's at all alarm, I mean, I think this helps a lot because, you know, it's left dissociatives.
6:12
You can just do that. So the way to think about it, if you put the brackets inexplicitly.
6:17
Oh, I see. So flipping them is just like heaven, except it takes the victim to the other way round.
6:22
So rather than taking the item in the search list, it takes the search list and then the item.
6:27
And that's exactly the order I need for this plot. So that actually gives me the same result.
6:31
Now, you may find Flip useful in this week's lab, which is why I mentioned OK, let's go back to the slides.
6:35
Anything on that? Because I'm going to move on to the next topic. Which is this one?
6:43
OK, so we've seen enumerated types and I showed you these and you're using the colour on this week or some variation.
6:50
This I've got the American spelling that most attacks like this are the original the original language used.
6:58
By the way, I came from poor textbook, which I think I pointed out at the beginning, of course, but we've updated it since.
7:04
So we should now spell it with the British spelling. Right.
7:11
So we've seen these sorts of things before and hope you that they're clear now.
7:15
It turns out that constructor's when when we define this stuff, these constructors don't have any objects.
7:19
They're just Constance's a set of constants of a particular type. But in general, they can take arguments.
7:25
They can look like other functions, except, of course, they don't have any rules. Their job is just to construct.
7:30
So here's a really simple example. This is a fantastically useful data type. It's called maybe it's polymorphic.
7:34
So so the way we do this is to say, OK, here comes a new data type and it's called maybe and it's polymorphic.
7:40
So it's actually parametrised by a type variable. And it has two constructors.
7:48
One is just a constant, which is nothing, and the other one is called just and just takes a thing of Tobei.
7:53
Now, the way to think about the maybe it's a it's a wonderful way of encoding results or back values,
8:00
which it was computations, if you like, which could fail. And if they fail to give you the idea as you give back nothing or they could succeed,
8:06
in which case you wrap them in a just so we we we know when we if we got a computation which delivers a maybe when we look at the results of them,
8:13
we know whether it failed or not. We're looking at a constructor. And if the constructor is nothing, oh, something went wrong.
8:22
And of course, what that means depends, of course, on the context in the application.
8:27
But somehow that's the that's the sort of consumer being told that something went wrong when we when we attempted the computation.
8:31
And if instead we get back to just something, then the something is the result of the success of some successful computation.
8:37
So that's typically how we use it. Of course, there are many other ways of using the data type, but that's typically how we think about it.
8:44
Right. So nothing is just similar to this.
8:51
You know, nothing is just a constant constructor. So I know nothing is therefore an object of type.
8:56
Maybe, in fact, if we go and ask what is the type of nothing?
8:59
That's what it says. Oh, it's a maybe something I don't I don't know what the something is,
9:05
but I know it's a maybe something so nothing can be is a constructive for any maybe talking that we can use maybe in a different context.
9:09
So just is therefore a construct that we can think of it as a function.
9:17
So this is now a constructor function which says you give me an A and I'll give you back and maybe I.
9:21
And again, you know, when you when you're playing with this, when you're trying to understand this, you can just ask, what does he think?
9:29
The type of justice? Oh, it's a function that takes an Angasi back and maybe.
9:34
Well, of course, that's exactly what, you know, similar to something that you'll accept as an argument,
9:37
sort what's true, for example, which was just a bull.
9:42
So it doesn't take an argument. It just gives me back a bull because data bull is also true.
9:46
Right. Whereas data maybe is nothing or just.
9:52
So therefore just should take it and give you back. And maybe it's just a simple generalisation.
9:56
Things we already know, I guess. OK, there are no rules. So there is a no there's no rule for computing.
10:00
Nothing, there's no rule for computing or just just X is just X.
10:06
It is, it is already a normal form provided the X is normal.
10:10
OK, and the other thing to bear in mind is that they are implicitly defined in a data definition,
10:15
so before this line of code, neither nothing or just existed, I get to choose the name, but maybe the nothing in the just.
10:21
You can choose any names you want when you're defining your own data types.
10:28
And as the trick, of course, is that is to choose good name so that someone reading a programme has some clue as to what's going on.
10:30
So we we don't we don't give them silly names. No, we don't.
10:37
OK, so so maybe it's fantastic. Useful though, a bunch of functions associated maybes and Hasker,
10:43
which again you will find you will crop up again and again and again in exercises and lab tests and practise tests and so on.
10:47
Here's here's one of the most popular ones. The most common ones is the Look-Up function.
10:56
So I can imagine I give you a table of key value pairs and here it is here that I haven't
11:00
put the type in here deliberately because we're going to work this out later on.
11:05
So here's a table of key value pairs, which is either empty because it's on modelling the table as a list or so.
11:09
That is the pattern which matches only the empty table, the empty list and the table consists of key value pairs.
11:15
So if the table is not empty for the table, the list is not empty, then it must be of the form key value KHK Komova,
11:24
which is a pair pattern that must be that must be sitting at the head of a bunch of other key value pairs which constitutes the rest of the table.
11:30
That's all that's an arbitrarily large know the usual stuff. This is just pattern matching, but this is not the usual trick.
11:39
I know from the type of a table I haven't written to type in here, but I know that every element of the table has a key value pair.
11:45
So if it's got at least one element, it must match the pattern Komova.
11:53
But there's no way there's nothing else that could possibly be called an irrefutable pattern.
11:58
Nothing else could possibly match. Right.
12:01
So here is the idea.
12:05
The lookup says you give me a key I'm looking for and it will search through the table until it finds a matching Kariya matching key inside the table.
12:07
So when we find a matching key, when the key matches the key,
12:14
we just return the success and we say successful by wrapping it in this just constructor.
12:17
Otherwise we will try again. So in other words, what you do or what you always do in this situation, we simply because into the tail of the table,
12:23
the title of the list, and if we end up running our developments, we just say nothing.
12:30
And that tells us we failed to find the key anywhere in the table. And when the consumer, the function call looks at the result,
12:35
it knows whether the lookup succeeded or not because it looks to see and nothing or adjusts, and that distinguishes the two cases.
12:41
So here's an example where we couldn't find an X in the table because we get nothing.
12:48
And here on the second example we were looking at before and sure enough, there it is, the four is bound to in the table the string.
12:54
So you are so we return for Repton that just so Billingsley's Gabriel question.
13:02
Uh, yeah, so in this case, why could you not just equal the why would you need to use just be.
13:12
I have to on the right hand side, there must be something of maybe maybe I should have put the type in here, but actually I want to derive it later.
13:21
So they look at the look up is going to give me one of these one of these maybe things.
13:30
So either it's got to return nothing or just something. Otherwise, it's a type error, isn't it?
13:36
Yeah, kind of like me. Why do you need to the first rule gives me a maybe something.
13:43
Therefore, the second rule must always give me a maybe something so I can't just return envy in that case.
13:49
But like, we could just also do a similar function that just gives like that doesn't have to give that type maybe.
13:55
Well, the is the thing, supposing I didn't use them, maybe type and I ended up with looking for a key in an empty list, what would you return?
14:07
That's the problem, isn't that you can't think of it, it's a bit like saying, what's the minimum?
14:20
You can't say you can't say that there's nothing obvious that you can return if if you happen to know it's a list of,
14:25
OK, you're mapping, there are no strings to Aints or something. Yeah, I suppose then in that case you will return minus one.
14:31
But that's pretty unsatisfactory. And also it is a polymorphic function.
14:38
So is it what it is. But what we'll see later. So we should be able to deal with arbitrary key value pairs, key pairs of arbitrary type.
14:42
Can we return the empty list? Well, no, because the entry is, well, the empty.
14:51
We can't return the empty list here because if I'm to look, for example, so I'm doing a lookup of a number,
14:58
supposing I've got one maps to four of two maps to four and three maps to one, nine maps to nine member states, doesn't matter.
15:07
So that's fine. So I would get back if it wasn't wrapped in one. I could give I get back to one year.
15:20
But if I say what I look up three in four, if I can just say what to look up three in the in the empty list.
15:24
Right. So so if you imagine that just wasn't there then.
15:32
OK, yes. I can see I can return to number one there. But what would I do in that case.
15:35
Well. If I didn't have the maybe type, what would I deliver?
15:40
You can't say I'll deliver the empty list because then that delivers a number one and now you're saying that's going to deliver Lentulus again.
15:44
It's the wrong type. So the nice thing about the maybe type is it brings all the things into the same type by wrapping them in either nothing or just.
15:51
I mean, think about it, if it's not obvious, just go in in general,
16:02
set an arbitrary table of key value pairs of arbitrary types and I say, look up an item in that table and I give you an empty table.
16:06
What value can you possibly construct that would make any sense? And you can.
16:15
Schengen.
16:21
So why we don't have, like, maybe it like Functio had and function to [INAUDIBLE] because they could possibly have like a. a child and a corsaro.
16:23
I didn't actually understand what you said. So can you say it again, so why, like preload, Functio had its head saying head.
16:36
Yes, it's not used maybe, but.
16:46
Oh you mean to say, you know, well, OK, so what we said with the head of an empty list at this point and this is an error message.
16:50
Yeah, yeah. Yes, it's true. I mean, they could have designed it so that it returns in that case, just the.
16:57
Well, OK. In that case would return nothing. Yeah. Good. Good point.
17:06
I guess there comes a point where you say, well, there's a there's a there's a sort of you assume a precondition that the list is anonymous,
17:14
in which case you don't need the maybe thing or do you assume that you do not assume the precondition.
17:21
In which case then I guess you have to return the sense then to return as an obviously very good question.
17:26
And I guess the answer is they say, well, let's just have a precondition here.
17:33
So, you know, every time you use that until you don't always want to have to unwrap it, maybe, you know,
17:36
if you could imagine if you said Matt had over what was my favourite random access
17:41
memory wasn't it doesn't matter what the three strings are or something like that.
17:47
Matt not head over. Oh, so I haven't put that.
17:53
So that gives me the first item of each of those lists.
17:59
Well, if I got back for each of those, maybe, which is either nothing or just, it'd be a bit painful having to unpack them.
18:02
So I think people say, well, look, this is what PED's designed for this sort of thing.
18:10
And we don't really want every time we use it to have to unwrap maybes. So it is a it's a decent decision they have to make.
18:15
And I don't think they probably made the right decision. So really, there may be danger. Time is when when you as a programmer have got a problem,
18:20
where you have a you have a computation that may fail or it may succeed, whatever that might mean, depending on the problem.
18:26
And you want to somehow carry that information around in your programme. So, OK, I'll leave it at that.
18:34
Otherwise, stop digging holes. Excellent.
18:40
OK, so so this is a look up at you, because this we use them everywhere.
18:45
Here's here's one way you might use them. You might say, well, I've got some function I want to know.
18:49
So I've got some know. Maybe it's got some organs X, Y, and here's this table thing here.
18:55
So maybe somewhere in the right hand side, I'm doing some work. I just need at this point, it did look at the facts in the table.
18:59
And then I want to this is the point of the example. Now I want to look at what comes back to the several ways we can do it.
19:06
One way we know about is to pass the result to an auxiliary function to help a function.
19:14
And the helper function says, OK, well, I know that when I do a look up, I see either nothing or I see just something.
19:19
And then I can make a decision as to what to do in each of those two cases.
19:26
So, for example, it might say that in the help, when you say nothing of return zero or 17 or the empty or something and it's problem specific.
19:29
So there may be some base value B which is returned when you say nothing and if it succeeds with the result raise,
19:39
then I'll do some computation on the rest and that computation is packaged up in some function.
19:46
G So you know, you can substitute being for whatever you want in general, but that's the sort of pattern I'm talking about.
19:50
There's another way of doing it of course, isn't there, which is I could go something like.
19:57
So I could cite.
20:04
So what was the example surfaces of if I went put the time and effort back there at the table and on the right hand side, I'm going to do a look up.
20:09
I just don't need the president is going to look up of X in my table and I know I'm
20:19
going to get back and nothing or just because it's packaged up as a as a maybe type.
20:24
So the other way I can do it in a case just like it's a case to up a group of and then I can have what I know I'm going to solve this year, nothing.
20:28
In which case I've got to decide to do that. Or I've got to adjust something, adjust X, say whatever, just result wasn't, I said.
20:38
In which case we do that.
20:51
So I said, well in that case, perhaps we would send somebody and this case will apply some function g to the result and away we go.
20:52
So for example, for example.
21:00
Oh maybe this one is a zero.
21:04
So if I can't find anything so perhaps I'm looking up a string in the list of string number pairs or string into pairs or something.
21:06
If I don't, I would just return the numbers here because that's fine for this particular problem.
21:14
Otherwise, perhaps I'm going to increase the value of the result. You said this sort of thing.
21:17
I'm trying to do it so I can I.D. a case statement or I can go and use a helper function.
21:21
I think this is this is a nice example of why cases of this is really what cases are for.
21:29
I'm sitting on the right hand side. How can I what a decent computation which is generating something which is wrapped up in some constructors.
21:32
Therefore, I want to inspect what's up now. So I'll I'll just use a case study.
21:39
Thus, OK, so back to that example.
21:46
So so that's why now it turns out that there is a bunch of functions in one of the modules called DataDot maybe,
21:50
which contains some really useful highwater functions for doing this type of thing, this type of computation.
21:59
But rather than having helper functions in case statements and lots of auxillary stuff with pattern matching,
22:04
actually what they've done is they've packaged that up inside some of these some of
22:10
these DataDot maybe functions so they can do I can solve the same problem in one line.
22:13
So here's one example. Well, there's a function called Maiti with a little M and it goes as follows.
22:18
Right. So let's look at the third argument first. What we're going to give it to me as a result of the computation, which has got a maybe a type.
22:25
All right. So when I look at the the result of the maybe I'm either going to see nothing
22:33
or I'm going to see something in the form just to call the bla y just y here.
22:40
So here we go. So the maybe says, well if you say nothing so it's got two or guess one is A type B and the other one is a Atabay.
22:46
So if I got a maybe A then I know that the Y must be an A, it's a typo.
22:54
So if I see a just y I know the Y is a typo. So what I'm going to do this function.
23:02
S job is to take the A. And converted into a B, so so when I use this, I can give it the F I need in order to solve my problem.
23:07
And if I hit the nothing case, I just return this is the best thing, is that so?
23:19
So if the function F takes an eye and gives me a B, the result must be a B and therefore on the first rule,
23:23
the there must also be a B, which means that the X must be happy.
23:30
So let's see how we can use that.
23:36
Well, perhaps I probably even said on this in the next slide.
23:39
So this area so the example above,
23:45
let's just go back and look at the example above this thing in here with the help of functions, quite a lot work, wasn't it?
23:47
Quite a lot of code. And likewise the case statement.
23:52
OK, it's OK, but it's still code have got through and I can do it in one line, one line by one line by doing this.
23:55
So I just use the maybe function. I say, oh, it is nothing, give me back the B and if it's just something then apply that G to the something.
24:06
So this one line of code here which uses the bill to maybe function a little and is exactly the same as that code, that.
24:15
Terrific. So you got maybe packed full of these really useful things and there's another one called from Just,
24:24
which says if you happen to know that your look up cannot fail and sometimes that
24:28
quite often and you'll see this even in the in the Lexus test and the January tests.
24:34
The problem is such that the look up will always succeed is by construction.
24:40
So it was like a precondition, if you like, the item will be in the table.
24:44
So we don't really have to worry about that, the nothing case.
24:48
So in fact, in that case, we can just use this from just thing and from just simply unpacks, adjusts and gives me back the X.
24:50
There's a bit of a dangerous function to use because you've got to be absolutely certain that the object to your hand is adjust X,
24:58
because if it's a nothing, it's actually going to block the programme with an error message being used with care, I guess.
25:04
All right. So perhaps we'll have an example in just a second.
25:11
Yeah, so. Yeah, so that's pretty much the same thing.
25:15
So let's let's let's let's have a crack at this and perhaps I'll just put that out on the tape this morning.
25:19
OK. Right.
25:31
So let's have a go. So let me have a look up now.
25:36
Let's do a look up. Of did I have a look of example back here, so you talking me, what is a nice little example?
25:40
So that's going to give me a puppetland Brackett's. I'm going to make the third argument in my court a little maybe.
25:47
So let's see, supposing I'm looking up a number and a list of no number popped into past say so in this case, I'm going to get back at just one.
25:55
So but in general, say, right, if the look at fails, I want to return nine, nine, nine.
26:06
And if it succeeds, I want to increment the value I get back up.
26:13
So there's a function which does that, which is the successor functions you see maybe is a higher order function.
26:18
It takes the another function as its parameter and. What's.
26:22
Oh. Oh, I see what's happening. So I'd forgotten somewhere, I think I've got a maybe in why do I always end up doing this?
26:40
Let me just hide that as well. Yeah, so I gave examples.
26:52
I see it was what happens, but posted examples from slides into here so it doesn't know which one to use.
26:57
Yeah, I should really fix this by fixing my module imports. Let's try again.
27:04
There we go. So in that case, what happened is the lock up succeeded in getting me back just once if I just get back into the lock up again.
27:13
Was that succeeded with just one and what I did was I extracted the one where the
27:23
what the maybe function was extracted the one and then applied that function, which case was a successful function, which by the one became a two.
27:27
OK, now, if it happens to fail, so supposing I change that three to a seven to look up will fail and I will get no, no, I see a jingshan.
27:34
Is that an old hand or is it a fresh hand? Oh, it's a fresh hunt, so, well, if we don't want a modified to reach out, we just want to be retried.
27:45
So supposing I didn't want to change it by doing something like the successor function?
27:56
Well, one way round is to just put it in here. You said why your idea of X equals X, how can any?
28:00
How can that possibly be useful? Well, you can do that. So let's get back to the one where it actually succeeds.
28:09
This is the one that succeeds, so instead of suck, I can put I.D. and that just gives you a fact.
28:15
There's another function which I haven't got on the slide here called from maybe.
28:20
So from maybe does exactly that says, well, it's only the nothing from maybe if it's something special you want to do in the case of nothing, tell me.
28:26
Otherwise, I'll just give you I'll just unwrap the just for you. OK, so that's one I haven't talked about.
28:33
Oh, it's because I have an imported data.
28:39
Yeah. It's getting through. There's one call from maybe which does exactly that.
28:45
Good. All right, so. And I'm just trying to think of any other I can tell you about basically the ones that we use most
28:51
commonly and maybe from just and from maybe that there maybe there's a whole bunch of others for,
29:00
you know, if I've got a list of maybes and I want to filter them in some clever way, then I I'll have a look.
29:05
There's a there's a there's a logical DataDot. Maybe I'd have a look through there and you'll find all sorts of useful stuff.
29:10
Good. OK, there's not a topcoat either, actually, so maybe it's a bit sort of it's kind of lopsided, isn't it?
29:18
It's nothing. Or just then it just takes an object of type.
29:27
Well, you might think, well, I'm doing a competition and the competition, rather than initially failing or give me a successful result of Taipei said,
29:30
well, I can succeed in two different ways and I want to know which in which way succeeded.
29:37
So maybe I succeeded in a particular way giving an object to Taipei or I succeeded in Mathabane game,
29:40
an object of type B, so there's a thing called either, which is a symmetric version or maybe if you like.
29:46
So it's premature both to talk variables. And there are two constructors.
29:51
The first constructor called imaginatively left takes off just Wrap's object of time and the other one rotates type B.
29:55
So this is sometimes useful if you get back to different types of thing and you want to be able to tell the call of the function, which of the two?
30:03
Which are the two in which of the two ways, if you like, the computation succeeded. So that's a bit of homework.
30:08
If you're interested to have a rummage around, then the idea to type.
30:13
OK, so let's just do a couple more things, then we'll have a break.
30:19
Right, so these data types, so I'll get back to the maybe data type, it's not recursive,
30:23
it's just a you know, it's just a thing which distinguishes two cases. But these constructor's these days attacks can also be recursive,
30:29
which means that the constructors can take arguments which have the same type as the the the type sitting, so to speak.
30:36
So here is an example of a list data type.
30:45
Now we know we know about Haskell's list at the time.
30:48
So I can Miraj, I can have a I can look up another version of lists called NIST, which again is polymorphic, as is Haskell's list.
30:51
So a list of typo. And so I need to construct as if I'm going to mirror the Haskell one.
31:00
So how am I going to mirror the the empty list, the square bracket construct constructor.
31:05
Well, perhaps I'll have a construct to nil nil or empty. Empty what.
31:10
Or how do I mirror the cons,
31:15
the colon or perhaps I'll call it S.O.S to make it clear it's a constructor for lists and we know that the type should therefore be a to list today.
31:17
And what do I get back when I invoke comes a something I get back a list with a capital.
31:27
So the important thing to understand is that this is a different type to hospitals list type.
31:35
In fact, you might imagine that in the period somewhere we've written something like this turns out not to be valid syntax,
31:40
but essentially that's exactly the way the data type would be defined if I could define it's actually built into the language.
31:46
OK. Oh, Jinsheng. The question is, so can we use cannot use data to define a type that does not have no but only have cows,
31:55
so it will never like at least it never stops.
32:07
Yes, you can do whatever you like. And if I hit the nail constructor, I can only build infinite lists, I guess.
32:12
Right. Because I can never terminate the list. Yeah you could, you could do that.
32:21
You could play with that. Sure. All right, so just one thing to bear in mind, if I let me just go to the cross here.
32:26
Have I actually defined electricity to some? I think I do. There we are. There's the data type in the script.
32:37
So just another thing to bear in mind is that so let's build a list.
32:44
So so if I wanted to build the list one to three in Haskell, I just using Haskell as I just do that now, if I want to date using my own Handmaid list,
32:49
I'd have to explicitly construct and use the construct to punch with one and I'd have to do a cons of two with a cons of three.
32:59
And then I terminate the list with the empty this constructor and that.
33:09
Oh yeah. Well that would do the same. Let me just fix that and I'll explain this tomorrow.
33:13
Watch the. What's he doing? What are you doing? So I'm just telling Haskell to to work out, to derive some printing functions for this, that's all.
33:21
We'll see how that works next week. So now if I programme, it says, well, that is the answer.
33:31
So these constructions, they just construct, there are no rules. They can't simplify that.
33:38
And that is their job. You know, of course, if one of these happens to be a Riddick's, then like, what was it, six minus three instead of three?
33:43
It'll always convert this into the normal form in order to be able to print them on the console.
33:53
Yeah, but OK. But the point is that the content they just construct.
33:58
So that's the first thing to understand in just the same way that the colon and the double square brackets just construct,
34:03
there are no rules for them. And the other thing is, does it make sense to say something like that?
34:08
Well, that gives me a well. And here we go. We can ask actually what is the type of that?
34:13
And it says, oh, it's a it's a list today for some number. It doesn't know whether the number that floats or anything, just as we know.
34:19
So can I say something like that? Well, is that equal to one, two, three?
34:26
What's that going to tell me? I was there.
34:33
Yeah, you think, well, it's true. Is it true? No, it's just a typo.
34:38
It's a type error because you can't you can't compare.
34:42
You can't ask whether a Haskell list of numbers is the same as a manufactured list of numbers that are two completely different types.
34:49
And we know that the type of X equals, you know, whenever I use this function,
34:57
those two things, the things on the left and right must have the same type.
35:02
So you can't mix and match, you know, either use the Hasker one or use this manufactured one, really, should you have a question?
35:06
So why would we use this kind of data type if if if if it's just a constructor?
35:13
So I don't have to build a list of we use the Haskell built in one.
35:18
OK, I guess one zero one example you might see is we I've kind of hinted about Stax, so you might imagine you want to put a stacked data type,
35:27
which is either an empty stack or or the result of pushing some item onto a stack of items.
35:39
And this is polymorphic. So perhaps I'll make this point.
35:49
So that's that's that might be useful, actually, even though it's isomorphic to hospitals lists, you think, why didn't you just use a list?
35:52
It maybe by using the name stack and empty and push. You convey more meaning in your own reading of programmes.
36:00
Oh, I see, this isn't just a concern.
36:07
You know, they're not I was actually pretty exciting, optimistic, and I use the push construct rather than the colon, this construct.
36:09
So you may find that's useful because just because of the use of the names.
36:15
But I wouldn't I wouldn't actually there's no point in reconstructing a list.
36:19
So I would never do what you see above the. But I suppose you could do, but it would be madness,
36:23
because then you'd have to write all the entire prelude and list DataDot list functions for the state of thought, and you just simply wouldn't do it.
36:30
All right, so they so I think that's probably explained we can now define functions over these lists or stocks or whatever it is,
36:40
because you will have to define this list in practise. I don't think that if you ever did, you could define a function length.
36:49
And of course, what you have to do now is to use the Nhill and Kohn's constructors rather than the square bracket and Colen constructors.
36:56
But the rules are just the same as they were very similar to what they were in the in the version before he looked at.
37:04
So, oh, you give me a new list. And I know this has no relevance.
37:09
Therefore, it's like the zero. You give me a list where the some item is constantly glued onto the front of some other list Xs.
37:13
Well, that's just one plus the length of the. So it's mainly the the, the, the, the functions on lists sort of isomorphic you like to get to.
37:23
The task was built, built in equivalence.
37:33
All right, I think it's time to break, let's celebrate until 10:00, too, and then we'll have another break about quarter past.
37:37
So go and get some security. OK, welcome back, Richard.
37:43
Is that an old hand or a new hand, that's all.
47:14
Well, I put it on OK. Thank you. Did you have a question?
47:19
Yeah, so, you know, he tried to compare like the high school built in this to your defined list.
47:24
Yeah, I was wondering if it's even possible to compare your defined list to your defined list because like what?
47:31
Make them part of the equals type plus. Yeah. So I'll give you a little preview.
47:36
So the question is, can I compare that with can I do something like that?
47:42
But the answer should be false. Should be followed, but actually it says, no, I can't do that because you haven't defined what that is.
47:46
You haven't defined this microsecond.
47:57
You haven't defined that function on LSD. Well, there is a quick fix for that, but we'll cover this next week.
48:01
But if you if you're stuck with this record you want to play, you can just do that says, oh,
48:11
please go away and derive the equals function based upon pursuing some obvious comparison of constructor's.
48:14
And if you then if you do that and then come back in here, then it will indeed.
48:20
But then falls for you. So there are some things you can derive.
48:25
Guess you would drive automatically and some things that can't drive automatically.
48:28
And that's what the driving statement does for you. So we'll look at that next week.
48:32
Good question. Right. Right.
48:37
Let's look at trees. So trees are if you think of I think about it, it's a generalisation.
48:41
But let's say we think about a list. The list have a have a sort of linear branching structure.
48:46
So I guess if you want to think about lists, sometimes we draw lists, as I said, like this.
48:51
And so on. So I think we can put items in the lists like that, so that's pretty much the way it's laid out in your computer's memory.
48:57
It's supposed to be a through another of our control. That actually is to think of it like the the console.
49:06
Once it gets through, it's the console, one with the console to with the console and so on and the console some no n with the empty list.
49:12
So it's yeah. It's linear, but you can sort of think of it as a tree, like being a tree, being things with two branches.
49:25
But it's actually this is a sort of degenerates tree if you like. It's just a linear thing.
49:31
So what a tree is and they use them instead of just having things that are always guaranteed to have this sort of spiral,
49:36
linear structure can actually allow you to build a true, true two dimensional branching structure.
49:41
So a tree is a generalisation of list, if you like, where each node, instead of having just one sublist, I can have two somethings.
49:46
And those subthemes, of course, are trees.
49:53
So we say that the tree is either an empty tree, which is a little black boxes in here, or is an internal node.
49:56
And if it's internal, it must have two sub trees.
50:02
So that instinct is what I just said is sort of instinctively, oh, that's that must be a recursive data type, doesn't it?
50:04
Because if a tree can be a node which has to substories, then a tree is defined in terms of substrate.
50:11
The tree is defined in terms of itself. OK, so there's lots of different ways of building and using and tree and storing things in trees.
50:16
So I guess the assumption here is that these nodes are going to store values so that can put the values in those nodes.
50:27
But of course, I could have nothing in the nodes and I could simply store the values in the leaves.
50:34
And they're both perfectly valid trees, which is different perhaps of using two different things.
50:38
So why it is important, it's because the distance between the top of the tree and the believe,
50:46
what we call the leaves of the tree in the ideal case is only logarithmic in the number of elements stored.
50:52
Whereas if you think about a list, the the the worst case, if I'm for example,
50:58
if I'm looking and I'm looking up an item in a list, I may have to wander all the way to the end of order to find it.
51:03
So the worst case would be that that search would be linear in the size or at least the worst case.
51:09
It would be the same as the size of the list.
51:15
So if I've got a million elements, I may have to do a million checks and the define whether an item is in my list or not.
51:18
Whereas if I'm lucky and I can produce a perfectly balanced tree and we'll see later that if we have a perfectly balanced order to trees,
51:24
then something like a search could happen and logarithmic time rather than in linear time.
51:33
And it's logarithmic because if I've got any items in a tree, the depth is logarithmic.
51:38
In fact, in this case, if I store items at the nodes, then I'll tree within items.
51:43
Has it turns out has log and plus one depth. And you can verify that.
51:48
Here's here's a tree with seven items. So I'm storing items in the nodes, not at the leaves of the tree.
51:52
And you can see that that's got a log of eight which is three levels, three or a depth tree.
51:58
Is that an old hand or possibly. Yes, it's one of our teams hands.
52:05
OK, so that's the ideal case. And so what we will be doing a lot more of this next year,
52:17
possibly actually in the springtime and certainly next year is trying to find clever algorithms
52:22
that will build balanced trees because balanced trees have this guaranteed logarithmic property.
52:28
Whereas if if you just build, we can still have a degenerate tree.
52:34
I'll draw you on if if I guess I end up with something which essentially isomorphic to so I could I could build this tree,
52:38
but I've got a left subtree is empty, the right subtree is a tree.
52:47
His left subtree is empty, you see. And that's exactly it's basically yeah.
52:51
It's that's pretty much the same as the last example I just drew you so you can still have trees
52:57
which degenerate quite badly and give the sort of linear time complexity rather than logarithmic.
53:01
So we do we do try to expand a little bit of effort instead of building those sorts of trees.
53:07
We will in fact sometimes spend an awful lot of effort trying to build balanced trees.
53:12
And I think I'm pretty. Yes. And next time I think there's in the Java lab where you get to play with these sorts of things.
53:17
So balanced is good, but hard to guarantee, even if it's unbalanced, you know,
53:25
you may have maybe that overall that the average complexity of your operations on entrees would be big,
53:30
maybe somewhere between linear and logarithmic. So he said loosely.
53:39
So even if Zambonis is often more efficient to use a tree than it is to use a less.
53:43
Right. So how would we build a true data type?
53:48
Well, let's see, it's recursive. We know that from what I've said.
53:52
So it's probably probably making a polymorphic is a great idea because in the same way that lists can store items of all types of trees.
53:55
So we need to think of some names of the constructors. So how about the little black box we call empty and the circular notable call Randeep Node.
54:03
So the empty construct hasn't carried nothing? Well of course I could carry items at the leaves of the tree as well.
54:13
That would do that in just a minute. I'll show you how we can do that.
54:19
And what is the constructor do.
54:25
Well, constructor stores an item of type A and I'm going to put it is the middle argument of the disconcert has three points.
54:26
So I'll make the the middle one and then the left and right substories. Well, they're both chisellers, you know.
54:34
So the Treva is defined in terms of a tree of a hence the recursion.
54:38
So there's no particular reason why I have to put the I in the middle.
54:44
I could put the front or I could even put the I at the end,
54:47
so long as I'm consistent and I put the I in the middle here just because it kind of mirrors the symmetry of the tree,
54:50
the items sitting at a node and then the left is the left and the right tree is to the right, which is kind of what we see here.
54:58
But it doesn't matter. You just pick one and be consistent. OK, so for example, the first one I guess might be a tree events or Tree of nums.
55:04
And the second one is a tree of characters. The third one is a tree of.
55:14
But again, tree of numbers. In this case, floating point numbers. So let's see, let's see how we might define the first.
55:17
Have I got trees in line and just see where we are. I should check this this morning.
55:24
Right. So I've got a data type there for trees and I've got some functions we're about to Reutter right on them.
55:30
So so I can say, tell me something about Tree.
55:36
And it says, oh, tree is defined to be that. And it's defined in the all examples, which is the one we were looking at.
55:40
So that means I can build. That tree, the one on the left, that is just the node with a five minute and 20 trees, and here's the beautiful thing.
55:47
Another thing about Haskell is that I can write down an expression which is a data type, which is a data structure.
55:58
So I don't have the right functions to generate data structures.
56:06
That's what the constructors do. So I can quite literally write a note of an empty tree with a five in an empty tree, and that is exactly helpful.
56:09
Let me just do my usual trick deriving just in case I need equals as well.
56:20
I don't think I do. So just so I can print it so I can write exactly that.
56:27
And that is No. Twenty five because it's a construct. These are just using constructors.
56:34
So that is already a normal form. So, so, so I can write an expression which corresponds exactly to that diagram.
56:40
And let's do the one the second one with the Jena K now, just a powerful example, that is a.
56:47
So a G at the top with an empty subtree on the left, a note at the top with an empty substrate on the left,
56:53
a G at the top and then on the right stuff to put in brackets.
57:04
I have to put this in brackets. In fact, that is a node which is got remind me a K with two empty substories.
57:07
So that's an empty subtree. But the letter character, Kay and an empty subtree, and that is exactly as it says on the tin,
57:17
that that is a this is an expression in terms of the know,
57:28
the empty constructor's, which gives this precisely corresponds to the picture which you see on the slide.
57:33
And I can do the same thing with C as well. So if you want to build.
57:39
A constant concrete data structure, you can just use the constructors to do it.
57:45
I don't have to write a programme to do what the constructors are for.
57:50
So, um, so in the same way that we like functions over, listen, of course, is not going to be bosomy recursive functions.
57:56
We've seen recursive functions. At least I can do the same thing for trees. I can write recursive functions over trees.
58:06
So what is the function which computes the number of elements in a tree?
58:11
Well, perhaps we'll call that size. It doesn't make sense to call it length, because length is that implicitly applies to a linear structure.
58:14
And what we've got is a binary branching structure as it was. What is the size of the tree?
58:22
How many elements are there in there?
58:25
So what we're specifically doing is counting nodes because from the data type, the each node stores and item type.
58:27
So we're counting the items we need to count and count the notes. It's the same thing.
58:36
All right, so here we go. So you give me a treat, I look at the tree and I say, OK,
58:41
what's a tree made from it's made from one of two constructors over the empty constructor or a node constructor.
58:49
And it it's a node constructed. There are three arguments on it to match on those three things.
58:55
And of course, I just do what I would do list, except I just just do it for trees.
59:01
So you give me an empty tree and I know that the size of the empty tree is zero.
59:06
You give me a non-empty tree, which I know is made from a constructor called Node, which has got three arguments.
59:11
So therefore I need three variables in my pattern.
59:17
The L corresponds to the left subtree, the are the right subtree and the X is the item sitting in the middle.
59:20
And in fact I don't need to name the X because I'm just competing sizes here.
59:25
So I could put an underscore in there, couldn't I. What's the size of that tree, was it?
59:29
Go and calculate the size of the left tree and the size of the tree and add them together,
59:34
and then I'm just out by one because I forgot to include the item X, so that was the one.
59:38
Plus just finishes the job. OK, so there are two recursive calls because there are two substories,
59:43
simple now going to do a little bit of a tweak now because if we go back to the first slide,
59:50
so we go back to there, these trees, do you notice how many empty trees are there?
59:59
If the tree has got three levels of nodes, one, two, three, four, five, six, seven, eight.
1:00:06
So this tree has got seven nodes. It stores seven items, and yet it's got eight empty trees hanging off the end.
1:00:13
These are the essentially the leaves. And you might think, well, that's a bit wasteful, isn't there?
1:00:22
Isn't there? In fact, there are there are more empty trees at the end of a balanced tree than there are nodes.
1:00:27
You might think it's slightly more economical in terms of memory, if we could tell you what the problem is.
1:00:34
Yeah, so the problem is. When I do that.
1:00:39
When I see that sort of tree, that is a tree that's only storing one item, you know, here's my item seven or something in the tree.
1:00:45
So how about this is an idea, rather than wasting a note and to empty trees just to store the item said,
1:00:53
why don't we have a new constructor which represents, let's call it a leaf and I'm going to draw a leaf as a ball.
1:00:58
So instead of that, I can do that. So if I have an extra constructor, I don't need to empty substories in order to store a singleton into a tree.
1:01:06
And the idea this might be more economical in terms of space, so, you know, if I've got a tree here and my all my leaves have got something like that,
1:01:16
as you see in the binary case, I'm just going to instead build the tree and I'm going to put these little boxes at the end.
1:01:25
And if, of course, I've got a subtree which has got something like that or something like, you know,
1:01:31
some other subtree down in the then, of course, I still have to use the node because I need the two subjects.
1:01:39
But if I ever end up with a leaf, which is just a single atom, I can use my special box notation.
1:01:45
So I need an extra constructor to represent the box is the long and short.
1:01:51
Let's do that. So I'm going to augment my data type with a new thing and I'm going to call it Leaf and Leaf Store Single A,
1:01:56
but they don't have any substrates and that's where I'm saving the Schengen.
1:02:06
Is that an old hand thinking about I think is actually not efficient to add a new constructor,
1:02:13
because this could actually make the algorithm more difficult if you don't like, maybe insert a ornament to the tree or do something?
1:02:20
Well, I'll tell you what, if you just wait there, we're going to do exactly that.
1:02:30
And I think you'll see it's actually quite simple. Yeah, of course, if I was going to be changing the date stuff in order, for example,
1:02:33
to save my memory, then I'm going to have to do a little bit more work, perhaps. But I define my life functions over that day.
1:02:39
So that is certainly true. But hopefully you'll see it's actually very simple and it makes a nice exercise as well.
1:02:44
So it's good to practise Nexen.
1:02:49
He didn't have to be lazy and say we all the employees are the same, so they all went to the same empty tree and have ballot papers.
1:02:53
Yeah, yeah. And and that's kind of what it does.
1:03:04
But the point is, if I look at the representation of this thing in here, it's probably going to look something like this.
1:03:07
There's a there's a space for a seven and there are spaces for the term for the two substories.
1:03:14
And yeah, these are possibly zeroes. It is actually going to create pointers to another computer.
1:03:20
But I've still got these two in here. Even if I don't if if I ignore the space for these two things, I've still got the space inside the box.
1:03:26
So why have I have a box with three three things in it, an item and two substories when I can just have the item.
1:03:33
But if you just got the item, surely, like it can have different types, be different variants, be different sizes,
1:03:42
because if you pass one to a function, it needs to reserve enough space for like don't forget, there's a bit of information on missing.
1:03:50
When I when I draw this when I draw this box here with the seven inside it, it's supposed to be a seven.
1:03:58
Of course, I've got to know that's an empty not a note. So there is actually there is actually a tag here.
1:04:03
There's there's a piece of information which tells me. What the type of the item is?
1:04:07
Yes, you are better, but I had that anyway, so I have I even have that here.
1:04:14
So this says this is a A. constructor, for example, as opposed to an empty constructor.
1:04:19
So, yes, there's always a bit of housekeeping required to know which of the three constructor or the two constructors I'm talking about.
1:04:24
But I've still got these two substories in every single node.
1:04:30
And if I'm only storing a single, then I certainly don't need those two. So they have there has to be memory space savings.
1:04:34
And by doing this one way or another, I could point.
1:04:40
That's OK, right? So where was I so I'm going to.
1:04:45
So I've added my leaf constructor to the tree data types and I think, OK, well, how do I compute the size of a tree if there's this extra constructor?
1:04:50
Well, I just need one extra rule, don't I?
1:05:00
So all I have to do is say, well, if you instead of give me empty, if it's not legible, perhaps it could be a leaf now, which is some leaf with some.
1:05:02
I'm going to put the underscore in the. But.
1:05:10
Underscoring that because I don't need to name the ex, so there are some I'd say there's just there's a Singleton entry.
1:05:18
Well, how big is a single country? One. But that's not an awful lot of work to to get around the extra constructor, so it's actually really simple.
1:05:24
So let's come back to the next thing, so the next function is, let's see, how about a function flattens a tree?
1:05:38
So you give me a tree and I'm going to give you a tree if I'm going to give you a list of trees back.
1:05:44
So the way to think about that is and see if I've got a let's draw tree.
1:05:49
There's a node with two trees, possibly different sizes, and I'm going to flatten.
1:05:56
So I'm going to flatten the thing in that direction. So I'm going to take this and generate a list from all the elements of that.
1:06:03
So in these elements inside this tree here. They all appear in a linear structure in here.
1:06:12
So I'm going to do it in order. So left first, then the then done the right.
1:06:18
So that means that I get all them at those elements and then I get the item at the top of the tree.
1:06:22
Let's call that X, so that pops in there. And then I take all these items and I flatten those into another.
1:06:27
This is maybe longer or shorter, who knows. So these items in here get lined up in order in there.
1:06:34
So I produce a linear structure which is basically flattening like a huge Monty Python type foot press pushing down on the top of the tree.
1:06:41
And I squeeze everything down into a linear thing.
1:06:48
OK, so how do I write a function to do that? Well, it's interesting in its own right.
1:06:51
Let's try a new one about this.
1:06:57
So the Flat 93 is really easy. So we'll give you a hint about the temperature hasn't got the elements, therefore I'll do that.
1:07:01
How do I flatten a node consisting of an item X at the root and two subtract left and right?
1:07:08
He wanted to write whatever names you choose and we'll actually just pause.
1:07:14
Maybe we shouldn't use L for the left subtree. Which is what I did here, because the L looks almost identical to the one in it many a time,
1:07:20
we've stared at the programme thinking, what's wrong with that? You realise that someone stopped in [INAUDIBLE] instead of a one or vice versa.
1:07:33
So actually, I do try to avoid using others and identify identified. And the next example I've chosen to 192 or T.L. Antia would be OK.
1:07:38
Anyway, back to the story. So how do I flatten that?
1:07:47
Well, OK, this going flatten T1, which converts that to let's let's flatten T2, which converts that to a less.
1:07:49
A lot of it is joining the during the flattened versions together.
1:07:55
But you must remember to stick the X in the middle because it's in in order to reverse the tree.
1:07:57
So in order says go left, come back to the root and then go right.
1:08:02
So if I flatten in that order I flatten the left subtree, then put the X in if you like, and then flatten the right.
1:08:07
Well I can do that either using the columns here. I suppose I could also write another way of doing this.
1:08:13
I could write, I could say flatten T1 and I could apply that to the Singleton does that and that's to flatten the teacher.
1:08:20
And that's actually possibly a slightly nicer way of writing it because it sort of conveys the symmetry the problem, doesn't it?
1:08:30
And they both do the same thing. So both both are completely acceptable right now.
1:08:35
So, yes, OK, let's do that. That's fine.
1:08:41
There is a complexity issue which will come through in just a minute and I'll leave you to do the homework on that.
1:08:48
So let's have a go at this now, which you can see the Flatman function in here.
1:08:52
But now we've got this extra constructor which my leave constructor.
1:08:56
Let's see how we might do that. And that's the that's the code I just had.
1:09:02
And it's like, OK, well do is how do I flatten a leaf, a leaf for the capital with some item X.
1:09:05
Well that gives me back. OK, well that's a tree with one item in it.
1:09:14
Therefore the list I give you should have one item in it. How do I build a list with one item.
1:09:17
Well, we can just use that notation. That is the single to list containing the X.
1:09:22
Excellent. So that solves that problem. Now, just the question on this is, what about the complexity of this?
1:09:28
It looks OK, doesn't it, but actually, this isn't a very good way of solving the problem.
1:09:38
Another little challenge for you to take home. Ponder whether in your spare time, let me explain why it isn't a good solution to the problem.
1:09:41
So supposing I've got a tree with an.
1:09:50
Let's see how I'm going to draw this. OK, well, just to draw this one subtree here and there's another subject here,
1:09:57
so I'm asked to flatten that tree so well, I got a flat in the left subtree first, so.
1:10:05
OK, well, let's think about the structure of the left subtree. Well, that itself is of no use in general with two sub trees.
1:10:12
OK. And how do I flatten the left one of those? Well, that, of course, is a.
1:10:21
And so this goes on and on and on. And so the way to picture this is that so what I'm trying to generate the flattened version of the left subtree.
1:10:26
And then put the axe in here. So this item goes into here and then a flattened version of the right subtree.
1:10:39
Like that, so something like, well, how do they get the flattened version of the left subtree?
1:10:46
But what I did is I flattened it. Subtree. It's left subtree.
1:10:51
And then I put its X into there and I flattened it's what subtree I think, well, how do I get that left subtree?
1:10:56
Oh. Well what I did is I flattened its left subtree.
1:11:02
And then I put an item in the middle and I flattened it's right sector, which might be quite small.
1:11:06
And how do they get that one? And so on and so on, so on and so on. And eventually I come down to the base case and flattening a single and leave.
1:11:10
So I just end up with something that that's I guess right now to my joining.
1:11:17
This list and this list and this item together, I'm using the pen and function.
1:11:22
What depend function means I've got to scan this list.
1:11:29
From here to here, so that I can join on to the to this list, but so but that applies at all levels.
1:11:34
So to solve this problem, I got to scan this list from left to right.
1:11:43
I've got to scan this list from left to undergo scan all the way down to the so so
1:11:46
that I'm scanning the same items again and again and again and again and again.
1:11:50
It's just got the wrong complexity because this should be linear.
1:11:55
I should I should be able to visit every note in the tree just once in order to compute the flattened tree.
1:11:58
And it turns out here I'm doing it and square times. So it's it's something wrong.
1:12:06
So how do we fix this? I'm going to take you back. Let's go to the bottom of the file, the bottom of the farmer said,
1:12:10
I'm going to take you back to an example which you should have hopefully had a chance to play within the system.
1:12:18
Remember the reverse function? So reverse just reverse the elements of a list, so I'm going to try to reverse function my own one,
1:12:23
so Rev sort of get a name clash, so it's a list of the list of all the time.
1:12:35
So let's see how we can do it.
1:12:41
Now, we can do that by saying that we can reverse anonymously list by saying, well, let's let's reverse the title of the list.
1:12:43
And all I've got to do is take the X onto the rightmost end. How do I do that?
1:12:54
Oh, I've got to do this thing here. Yeah, and it's the same sort of problem we've got with our flattening function.
1:13:00
We'll come back to the vote to reverse this list. I take this item.
1:13:08
And click onto the end of the result of reversing this, so I had to reverse this list.
1:13:16
Well, I cut the fat, cut the head off, and then I reversed the tail. How do I reverse the table?
1:13:22
I tell the tale, I cut its head off and so on.
1:13:26
And so. What I'm going to do is I've got to get this thing, this is thing, if you like, onto the end of the result of reversing the tail.
1:13:30
So I've got to traverse each of these to do that.
1:13:40
In this case, it's easy because I just stick it straight. That is like an order one wonca calculation.
1:13:44
The next one, I've got my X and I've got this list like the two I've got.
1:13:47
I've got to get the X onto the end here. I've got to scan all the way through this list.
1:13:51
To find the tail so I can put the X on it. So you say the same thing, I scanned this, this, then this, then this and then this and then this.
1:13:58
And then so how many scans of I don't know how many items of I touched in doing that.
1:14:08
Well, plus one for this one. Two for that one. Three for that one and so on up to and minus one I guess for that.
1:14:12
Well if I add up one to one minus one, it's older and square squared isn't it's the wrong complexity room.
1:14:18
Perplexity they should be able to reverse the list. But.
1:14:25
But in linear time, you'd think, well, there is a way to do it and the way to do it is to use an accumulation parameter.
1:14:31
So the idea of an accumulation parameter, I take a list like this, I take this one, two, three.
1:14:40
So rather than trying to reverse the list, using just a single function,
1:14:46
I'll have a helper function and I'm going to give the helper function accumulated, which is initially empty.
1:14:49
And as I recurse, I'm going to take the head of this list and Cong's it onto the front of the accumulator.
1:14:54
So next time round I'm going to recurse with the list to three and I'm going to put the one on the front of that list.
1:14:59
And the initial thing is I'm going to use the cons to do that, which is an order, one operation.
1:15:05
So next time I recurse into the tail and I add the two to the front of my accumulator, which is to consider using two.
1:15:09
This is one country, two cons. And the next time I requested to get the entries and I put the three on to the front again using Kohn's,
1:15:18
and miraculously the reverse list appears in the accumulator. By the time I hit the empty list.
1:15:25
So just a code that I'm convinced it works. I'm sure you probably done this already.
1:15:31
So let's say how would I call it Pruyn?
1:15:35
Give me some X's and I will call a helper function, which will reverse the Xs and I save the best of the helper function.
1:15:38
Well, yeah, I'll do it in the where clause because it's a helper function.
1:15:46
So read the double primes says, okay, let's take an item on an accumulation.
1:15:52
If I ever hit the empty list and my accumulator or call-back that is just the accumulating.
1:15:56
And if I do that with an anonymous list with it, an X is in the tail.
1:16:04
Then there's my cumulated. Oh it's just tell recursive. So I'm going to just call the function again with the Xs, but now I'm going to update the key.
1:16:11
I say update.
1:16:19
I'm going to build a new accumulator which is the old one with the X joined onto the front, which is exactly what I did on the whiteboard.
1:16:20
So hopefully that's all right. And then you can see that for the reverse of that, I can use the rev function, which is the only one.
1:16:29
It gives me the same answer. And I can use the prime function, which is the optimised one, which is still recursive and that's not linear.
1:16:36
Oh. What?
1:16:43
He forgot the initial accumulator. Thank you very much.
1:16:49
I've got to give it the initial accumulated. Thanks. Uh.
1:16:57
Oh, the bad day in the office.
1:17:05
All right, OK, so the nice thing about that trip with the accumulation parameter is it gets me from any great
1:17:10
complexity to any and it turns out you can do exactly the same trick with the flattening function.
1:17:15
It's just that you've got these two subtree to navigate rather than the single one.
1:17:19
So you're challenged with a little bit of homework to see if you can work out how to flatten a different version of FLATTEN,
1:17:23
which gets around this and this great complexity problem.
1:17:31
So specifically, your job is to replace that which is expensive in this context because of the complexity replaced that with a concept.
1:17:33
Presumably it comes to an accumulation parameter somewhere. Good luck.
1:17:42
Right, so let's just let's see how we can see.
1:17:48
Twenty past let's have a little break until this at a three minute break, because I know it's difficult to concentrate three minute break until 24.
1:17:53
OK, welcome back. Let's carry on. So I'm going to generate another sorting programme for you, essentially sort of tree type of thing.
1:22:35
So what we're going to do is we're going to build a binary tree which is ordered in the following sense that if I have to draw a picture,
1:22:42
if I have an ordered binary tree, then I'll put some item X at the root.
1:22:52
Then every item in this subtree must be less than or equal to the X,
1:22:58
and every item in this subtree must be greater than X marks and send the similar
1:23:02
way to the way we build an ordered list in order to build an insertion,
1:23:09
sorting out where we're going to use an order tree to tree. Right.
1:23:13
So how do we insert an item into an order, trace it a precondition now that the tree is ordered, otherwise it isn't going to do the right thing.
1:23:19
Right. So income's my argument. Oh, by the way, I'm going to assume I got trees evidence so I could enrich the type,
1:23:28
but I couldn't make it fully polymorphic for a reason which would become apparent in a minute.
1:23:35
But if I freeze the tight ends, then this is just absolutely fine. So if I got an end, how do I insert into an order to tree events?
1:23:39
Well, let's have a look at the ordinary events. It can either be pretty remote at the moment if it's an empty tree.
1:23:47
Oh, I have to build a singleton. Three and the only way at the moment I can build a single country is to build a. a. an empty type of thing.
1:23:51
So I know with two empty substories, when I come to put my life construct room, we can fix this.
1:24:01
But at the moment, that's all I can do if I've only got to construct it, if I've got a node constructor instead.
1:24:07
So some item at the root of the tree.
1:24:14
So all I have to do now is to compare my incoming number and with the X, and if the end is less than kittiwakes, it belongs in the node left subtree.
1:24:16
So I built a new node where the end is inserted into the left subtree and the X and the T to remain the same.
1:24:26
Otherwise, the flip side of the coin is the T one of the day the segment insert the item into the right subtree.
1:24:34
Right. So let's come to the code and let's see.
1:24:40
Let's find the code. So there's the trade data now, not with my extra data constructor now that is my flat and function.
1:24:45
So now I've got my new constructor. In this case, I can apply my optimisations.
1:24:56
So rather than building a node empty and empty, I can just do the leaf with a leaf with the end sitting in it.
1:25:00
Okay, so there are no substories in that case and that's kind of the optimisation.
1:25:11
Now, the only other thing I've got to worry about now is what happens if I try to insert an item?
1:25:16
And say and because I guess we're dealing with inserting something and into a leaf with some item, they say, OK, what do I do now?
1:25:23
Well, got to make some decisions anyway. So if I've got a tree which consists of the Leaf X.
1:25:33
And I'm trying to insert. My end into that thing right now, let's have a look is endless, and we could do X, if any,
1:25:43
less nuclear X than what I'm going to do is I'm going to build is less than equal to X. I'm going to build this straight.
1:25:52
I'm going to build this tree where I've got the X now sitting at a node rather than a leaf,
1:26:00
and I'm going to put the end into the left subtree of that new node,
1:26:05
in which case because I know when is the only item, I'll stick it into a leaf box and then I have to put an empty cemetery on the right.
1:26:10
And if it is bigger than X, well, I could do one of two things.
1:26:16
I could I could do a similar thing with the end at the end is at the top in the axis to the left.
1:26:19
Or I can leave the X at the root of the tree and put the end on the right and make the decision to leave the X where it was because it was the first,
1:26:23
the first open the door into the tree. So I think what I'll do in this case is to build this tree.
1:26:29
Instead,
1:26:33
I've got an empty subtree on the left and the single boxed Leaf Valley then goes on the right and that's that's basically GraphicLy the insertion.
1:26:34
And all I've got to do is to count those up. So I just have a little look and see then less than or equal to X.
1:26:43
If it is, I build a node with the leaf and on the left the X where it was an empty subtree on the right otherwise.
1:26:50
Equals.
1:27:05
Otherwise, it's a node with, again, the axe is going to stay where it is, so this must be an empty, empty subtree on the left, the stage where it is.
1:27:07
And then I've got leaf and.
1:27:17
On the on the right, yes, of course, I suppose I could define life and wear clothes, but actually it's only it's only a little constructive terms.
1:27:19
I'll just duplicate it. OK, so there you are, very simple augmentation of the insertion function.
1:27:26
And that gives me what I want, just as a little exercise.
1:27:31
I thought it might be quite good fun to show you how an insertion works because
1:27:35
some people don't believe you can possibly do what it's supposed to do. So here's an example.
1:27:40
So here's a tree. You put a line at the top that says something like five here, my left subtree.
1:27:44
I'll have a leaf tally of one here and I'll have a list of eight here.
1:27:53
So that is an order tree. And then I'll put a 12 here and empty here and then something bigger, like 20.
1:27:59
Right. So now I'm going to see if I can, without messing things up, change the pen colour.
1:28:11
So blue, sky blue.
1:28:18
Right, so now my job is to insert.
1:28:25
Some item, let's pick the item six into this tree, so I'm going to try to insert the item six into that tree, so I'm just going to follow these rules.
1:28:30
OK, we'll follow those, because I've now got the lead constructor case, we need to follow those rules.
1:28:43
So if you're in any doubt, just flip back and have a look. So let's see what happens.
1:28:48
Right. So what I have to do is compare the six for the nine.
1:28:52
I don't know whether the six belongs on the left or the right subtree, so it clearly belongs in left subtree.
1:28:56
So what I do is I replace this thing so I can sort of this is pretty much it gets replaced by something which is mathematically equivalent,
1:29:01
which is following the rules. So that says in that case, you will be a new node.
1:29:10
With a nine in it, all right, and then the right subtree remains intact.
1:29:15
Which is the two on the left subtree is now the result of concerting or just walk ins for that six into.
1:29:22
Not that subtree. Because I've got to insert the six into the left subtree.
1:29:30
And how does that work? Well, that gets replaced by.
1:29:38
But first, what we did, we got to look at the compare the sex, but the sex is bigger than the five now.
1:29:43
So now we kick in the other rule, which says that like the other guy, I guess,
1:29:48
says in that case, we get the five know the one this this left subtree points that the T one,
1:29:53
because we're not going to change the T one, but we are now going to build a new treaty to which the right subtree,
1:30:00
which is the result of inserting the sex into that tree.
1:30:06
Now, how do we are now we've got the lifeco is how do we insert sex into a single country, which is a leaf with the Internet?
1:30:11
What we do, first of all, we get the rubber. We replace that.
1:30:19
With remember the diagram I just drew you. This gets to where we said we're going to keep the eight at the top of the tree.
1:30:24
And because the sex is less than the item already in the trade,
1:30:32
the sex is going to be put in a new leaf mode here and then this becomes the entry and that's the base case.
1:30:37
So can you see what's happened with. I have started with this trade.
1:30:44
And I reconstructed part of it and I built this tree,
1:30:50
and that tree is the result of inserting six into the original tree, but notice that the original tree hasn't changed.
1:30:54
And this is just referential transparency at work. The beautiful thing is, once I have defined the data structure and built it, I can never change it.
1:31:01
I can unpick it and reconstruct bits of it, which is what's happened here by the answer.
1:31:09
But the original tree has never change. And this is this is this is a extremely wonderful property.
1:31:13
And if you imagine you built this data structure and you've given it to your friends and they're all looking at it and processing it,
1:31:17
they don't want to see all of a sudden that the you know, the this thing has vanished and been replaced by another point or something.
1:31:22
And this simply can't happen in a functional language. And I want you to find an object.
1:31:29
You can never change it. So there you go.
1:31:32
Well, back to the example, that's the insertion function, so now we can build a sorting programme by doing repeated insertion.
1:31:37
So that looks a bit scary at the moment, you think, oh, I can see what he's done.
1:31:47
He's cancel some argument somewhere because this function is clearly expecting
1:31:53
a list of INTs and there isn't anything that matches the list of things.
1:31:57
So there's obviously some exceptionalities happened in there. So let's just go back to basics to see what happens here.
1:32:00
How would you let me change my pin colour back to. How do I do this?
1:32:06
Mm hmm. So so I've got some list of items.
1:32:14
Let's say yes, well, these Lisa, unsorted integers, I guess.
1:32:21
And they come in the form of a list and I'm going to try to sort them and I'm going to sort them by
1:32:26
building repeatedly inserting them into an trading lists and accumulate the auditory as I go through.
1:32:34
And then I'm going to flatten and that'll be my result. So how do I talk the tree?
1:32:42
Do you think? Well, the several ways I could do about it. Why don't I start with an empty tree?
1:32:46
And almost all the other, let's pick one of the exes I'll go from I'll pick the accent, but I could pick the one that I'm going to insert.
1:32:55
I'll just insert the one into that. Into that empty tree, and then what I'm going to do is I'm going to set the X.
1:33:05
No, so I said, I'm going to insert the N minus one into that three.
1:33:15
And I'm going to take that trip and I'm going to miss the X X, and my point is to ensure that's true and so on.
1:33:20
And eventually at the outermost level, I'm going to insert the X1 into what I get back from that.
1:33:28
And that will clearly solve the problem. I've just chosen to insert the items X and first and then went into an industry.
1:33:33
So this thing you can think of as a source of accumulation happening in here, sort of accumulation.
1:33:38
And you look at that and you said, I've seen that somewhere before. You think I've seen this pattern before.
1:33:46
This is a bold it's a fold. Right. In fact, what I've done here is full.
1:33:50
Right, the insertion function. My base case, what do I do if I've got an empty vessel?
1:33:55
What do I do then? What's the initial value? This? So the way I think about this is this is the initial value of my accumulator.
1:34:03
But I'm sort of this is a thought experiment and this is the initial part of my accumulator. So that's empty.
1:34:10
And if I call my list exes, then that is the same as that.
1:34:19
So I can write the insertion function by saying that build to build my order tree from my own unordered list of X's is the same as that.
1:34:27
And then you notice because of left associative function application, if I put all the brackets in, that's the things that bracketed that.
1:34:37
Oh, and now you see, I've got F of X equals G of X and I can cancel the X's so I get the build is 170.
1:34:45
And that explains this, so that builds a. a tree from an unordered list,
1:34:57
and all I've got to do now is to take the unordered list and generate a look, just take the oldest tree and generate from it unordered list.
1:35:06
Well, that's what flatlanders. So again, back to the magic white board.
1:35:16
How would I how would I do the sorting programme? So my sorting programme says, okay, you give me an unordered list of Xs.
1:35:22
And I will first, but I got to they've got to build the order tree from the actors using that function.
1:35:30
We just looked up and then I'm going to flatten the result and then you go,
1:35:37
oh, wait a minute, F of X equals so something that is F together start again.
1:35:43
I've got the whole F of G of X.
1:35:52
So remember that pattern f g of X is the same as F dot g apply to X which is implies that this thing here is the same as.
1:35:56
Flattened. Don't build.
1:36:10
Of exes, and then lo and behold, I see f x is it because G that X's and therefore sought must be the same as flattened?
1:36:18
To build. Amazing. And there you go, and there's the picture.
1:36:31
OK, to sort an unordered list. Using a function, we'll call it a resort, the way it works is you, first of all,
1:36:40
build the audit trail by systematically inserting and then you flatten the result.
1:36:50
Good. So I could construct an example, I don't think I've got any trees lying around, have I?
1:36:58
I don't think I do. So that's the that's that's the code Qianjin.
1:37:06
So we'll leave our original list has some like a specific structure, and it can cast the tree, become a lie and the complexity become really loud.
1:37:14
Absolutely right. So this this this is a naive insertion. It doesn't attempt to balance the tree.
1:37:28
So in the worst case, as I said earlier, the worst case I could end up constructing a tree where I've got X one here.
1:37:34
And the next two or three weeks, and either one way or the other, either this or the reversal of this,
1:37:42
and this is a degenerate story which essentially just isomorphic to a list.
1:37:48
And this can happen.
1:37:53
So this can happen if the original list is already ordered or reverse order, which, by the way, it depends how we've done the insertion.
1:37:55
Yeah.
1:38:03
So, of course, in practise, if I was building a library for doing tree manipulation, then I would almost certainly try to build in some balancing act,
1:38:03
some balancing tricks so that instead of that, I would I would create something which is not guaranteed or near guaranteed logarithmic depth.
1:38:12
So there's various definitions of balance.
1:38:22
Three, what one says that a perfectly balanced tree is that for each now the the number of items and for every node,
1:38:24
the number of items in the left subtree is the same as the number of items in the subtree.
1:38:31
That's a perfectly balanced tree. Another another notion says, if I calculate that the number of items in this one.
1:38:37
And the number of items and in that one tone,
1:38:45
they differ by most one or another notion says that one has got at least if I look at the depths of this tree.
1:38:48
So the depth of this tree and the depth of that tree, they differ by almost one.
1:38:56
So there's various notions of what it means to be well balanced. But there's only one different definition of perfectly balanced Nexen.
1:39:01
The team's goal setting a team hand, was it?
1:39:11
Okay, I see C the insert function I just wrote in a previous in your programme, I think you forgot to add the dash.
1:39:16
Oh, I'm sure I forgot to add a dash today. Where was it on this 31?
1:39:26
Seltzer's line. Insert prime, thank you very much.
1:39:33
Thank you very much. Yeah, so when you're doing this live, the easiest thing to do is the easiest thing to do is to drop a prime.
1:39:38
If I'm doing this on a real whiteboard, the carpet is littered with crimes that are dropped and it's the students job is to point them out.
1:39:46
So thank you for pointing it out. Qianjin. Is that an old hand?
1:39:54
Is it a team's handling teams had a team. All right.
1:39:58
Excellent. Very good. So here's another wonderful thought experiment.
1:40:04
And I will let you go is so I've used to fold right here in my full function.
1:40:07
Can I use voteless instead? Now, really not really, because the position of argument, it's not correct.
1:40:14
Yeah, that's right. So insert so insert expects an eight undertreatment.
1:40:28
Well, that is exactly what Foaled Right. Will always give you. Yes.
1:40:36
I thought like works by. All right, works by saying, if I say fold, right, if some unit into some axis, which let's say X1, x2 and so on.
1:40:39
So this starts off by saying I'm going to do F of X one and then.
1:40:56
The rightmost argument to that is the result of doing F of X two and so on,
1:41:02
and then eventually we get X and and then the unit, which in this case is the empty tree.
1:41:08
So in our case here, this is insert of X1, insert x2 and insert X n into an empty tree.
1:41:13
That's, that's the way we've. This is the way we use the phone, right, just to solve the three building problem.
1:41:26
Now, if I replace this with four left. What dispo, lefter?
1:41:33
So this is if you want to explain, so this starts at the bottom, doesn't it, with.
1:41:40
So it starts with the unit. I'll put the empty tree in now. So what I want to do is this, and then I want to do an insert.
1:41:50
Of the X one, this is what I want to happen.
1:42:00
And then the two and then so on, and I get the insert of that lot with the funny, with the accent.
1:42:05
Now you can say I can't use the INS function here.
1:42:12
This is wrong because the insert function expects an item on the tray.
1:42:16
And for me to use insert, it would have to take the tray and the item in that order.
1:42:21
Can you see how to fix it. Insert flip it exact plate.
1:42:26
So if I did that I would have to flip the insert function.
1:42:32
And then we be to go, Matthews, that's a question, is it a yes?
1:42:38
So if you rearrange the way we defined the insert function, would you be able to use flip left?
1:42:42
Oh, yes. The other way to do it is to define my insert function. So it takes a true and an end and generates a tree.
1:42:51
And if I made that decision at the outset, then I could have just written for left insert of code.
1:42:57
So I've called insert point because I was a name because of the name clashed with insertions or functions.
1:43:04
I should have mentioned that. Yes, of course.
1:43:09
Had I been that way in the first place, I could just as you flip it out, flipping it, but then you'd say what could I use for right now?
1:43:11
And it was useful, but you'd have to flip that one back the other way so you can have a win.
1:43:16
So you pick one.
1:43:21
And then if it so happens that you're going to use that function in the fold somewhere and it's the argument of the wrong way round is,
1:43:22
okay, you just flip it. Cully's doesn't know a team's hand when you hand.
1:43:27
Yes, Tipton's excellent, right? I think I'm going to stop because you you've probably had enough.
1:43:32
So what are we going to do next? Let's have a look. We're going to do type glasses, so I'll see you on Monday.
1:43:38
Just about.
1:43:45