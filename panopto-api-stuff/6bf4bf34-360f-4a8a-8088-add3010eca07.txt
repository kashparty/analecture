ID: 6bf4bf34-360f-4a8a-8088-add3010eca07
Title: Type classes
Category: Haskell
Lecturer: Anthony Field
Date: 01/11/2021
Anyway, don't worry, it's come down. OK, so let's get started.
0:04
So welcome back, everybody. So we are going to be doing type classes today, so we're getting quite near the end.
0:10
So in fact, all classes are something you probably already know quite a bit about because we saw them pretty much
0:16
in lecture one because they cropped up just to some extent when we were looking at type signatures,
0:21
if even the most basic functions that we've been playing with, so as we went along, had been explaining some of the stuff to you anyway.
0:27
So I'll go back and kind of do it from scratch.
0:34
So let's think about polymorphism because polymorphism and overloading, which is what Titus's is all about, the two to be related things.
0:37
So if you think about a function like that, length length is polymorphic in the sense that, well, what's the type of the length function?
0:46
Wait a minute. This is in the wrong place. Excuse me.
0:56
What is the type of the length function? Well, it's you say you give me a list of things of type and I'll tell you how many how many A's there were.
1:01
So it's polymorphic in the sense it doesn't matter what the type is, it simply wants to know how many are there are.
1:10
So at no point do I have to inspect the A's.
1:16
And if you look at the definition of blank, you'll see that the population underscore in the pattern them. We don't actually care what.
1:18
We just know that there is isn't a and we just the account essentially count to one for each of them an item.
1:23
So length is polymorphic. So one length definition will do for all A's.
1:30
All right. There's only one definition of lame and that's polymorphic.
1:36
Now, a similar concept to that is overloading. Now, a function like equals clearly has to have a different definition for each type.
1:40
So understandably, although we have much we work, we won't actually see how this this works.
1:50
If I say is one equal to one, that is going to involve a comparison of two integers and that's probably going to get mapped
1:57
down into some machine coding structure which will do some sort of clever little test.
2:03
You'll be learning about this in due course if I ask whether this character is equal to this character.
2:07
Well, that's probably going to involve computing the ordinal representation of the character and then comparing those as integers.
2:13
And if I ask for something like this, the last ABC, this will require different, different definition.
2:19
And again, that will give me pause because there's a lot of different definition.
2:25
Again, because in order to work out whether those two lists, people are going to have to use recursion,
2:30
which I'm certainly not going to need about in the cases above. I've got to compare the AI with that one.
2:34
And move the space so I get true in order to establish that to compare the ability to be able to walk down the list.
2:40
So this is the point is that the way that equals equals works is different for each type, and that's what overloading is.
2:47
Well, I can use the same operator to mean equals and give the same operator different types, different types of things to compare for equality.
2:54
The rules for equals will be different for each of those types. And that's what that's what overloading is.
3:05
Overloading is the idea of the idea of having what overloaded functions a function which is a best source of polymorph figure.
3:10
I can use the function of different types, but the rules are different. Right.
3:17
So the types over which equals this equals equals thing is defined, it's called the the equality.
3:22
And this is where type clauses come in. So I think I think on the one hand, take classes as a mechanism for defining overloaded functions,
3:28
turning around the other way type classes are sets of types which have properties in common.
3:36
So if if a type is a member, say the type is a member of the policy class, it means that there is a definition of equals equals for that type.
3:43
And of course, that that definition equals equals will be different for other type instances.
3:51
We talk about instances in just a minute. Let's so you can think of a class as a set of types, the common properties.
3:55
I guess I could draw a picture and you know, so you've got you've got the universe of all types we write that's for all eight.
4:02
And then inside here, we've got this sub universe of of things which are comparable under equality.
4:09
So if I think about the working class as a set of types, so there's types in here,
4:15
type one to talk through this might be int integer chars, string, whatever.
4:19
And there's a little label associated with this and these are what's called the member functions.
4:25
Of that type plus, so all the types inside you have definitions of, in this case, very few definitions of the equals equals function.
4:31
There's another one you probably never called not equals. So the fact that those are those are the only two member functions of the class.
4:39
So if you see a target inside, you know, there is a definition of equals in the definition of not equals for that type.
4:46
That's what makes it about it in the class. Right.
4:52
So this is the centre for defining type class.
4:58
In fact, this is the syntax for defining the equal class.
5:01
I should caveat this because I was actually looking at some stuff this morning and the the the the ghc the versus the prelude and the base classes,
5:05
the base choose rather the base model and so on that form the form, the core of the issue.
5:16
This is being tweaked over the years and this, this, this sort of thing, it is up to people.
5:23
And this is what I was looking at.
5:27
Another type of customer comes in a minute because I think the definition I have on the slides is slightly different,
5:28
the definition today and actually try to find the source code for it.
5:32
And some have so far failed because I think it's actually buried away somewhere and probably not.
5:36
And I'm not even sure that for someone who base some of the base classes, there is actually.
5:42
Yeah, I think we can look at, it seems to me not to be built in, but anyway, let's not muddy the waters.
5:46
So this is a valid definition of the EKU class. So class is a special keyword.
5:53
It's followed by the name of the class. You want to introduce it if you didn't exist and I wanted to introduce it, this is how I do it.
5:58
I say here comes a new a new type class curriculum and it's premature, judged by a type.
6:04
In this case, the type is called C, I could call it a it's just a type variable.
6:09
And that says but I think about is for a type T to be a member of the equality class, there must be a definition of the EU functions.
6:13
But these are these are the types of the member functions and both of them have type T t to boot.
6:21
So it is a member of K then the type for those two functions is to teach about, you know, enter into bool drinkable whatever.
6:27
All right. Now next thing you can do in subclauses, you can provide some default definitions.
6:36
Now if you look at this, these are the Depok definitions for equal and not equal. So not equals is defined to be not what?
6:41
X not equal. Y is not X equals Y and similarly X equals Y is not X, not equal Y.
6:47
So you look at that think, OK, there's clearly some circularity in these two definitions.
6:52
So if I don't do anything, if I just create a class instead I've got I've got a knot which is actually going to lead to an infinite loop.
6:58
So if I'm going to add a new class to the new type, so to the new class, I've got to break that.
7:05
So I've got to define I either not equals or equals or both, otherwise I'm going to get a loop.
7:11
So on the next slide, there's a little quiz, given the answer right now, it's pretty obvious what the answer is.
7:19
So so the members talk about men and the types of instances of a class.
7:27
So if if if if a tight T is a member of the Class B,
7:32
say it's an instance of that class and that means that there will be a definition of these two functions for each instance type.
7:38
So, for example, we know about it, we know we can compare it.
7:45
So it must be that it is already an instance of E and likewise float and double number, which are an integer and all the other things we've seen.
7:49
And we know that because right now we can type expressions like this into GHC and that's a perfectly valid expression.
7:57
And their equals equals is being used at three different types, bootable, turbo, charta, chartable and I guess possibly to ingestible.
8:05
And we've been able to do that since election. One Richet question. So how have you defined not equals with equals and then equals we're not equals.
8:16
How does that work out? Well, there's nothing wrong with these two definitions.
8:25
They they are called defaults. So when we'll see in a minute, when we when we come to an instance of this this class,
8:29
we've got to break the not so we've actually got to define at least one of those two functions.
8:37
Otherwise it will loop indefinitely if you just go into the next slide, if it's not clear.
8:41
But your handicap. So, OK, right then.
8:46
So let's look at the data. So what can we add to a type class?
8:50
We can add types, Newt types to to to a class.
8:53
So we've seen how to define our own data types. And there's a very simple example from an electron to back.
8:58
We will switch type essentially isomorphic to do so. It switches either off or on.
9:03
And now supposing for some reason we wanted to know where the two switches were the same, both wrong, both of the ones in either order.
9:09
Well, we could write a function like this to do it. We could say an equals on switches, would take two switches and be a bull.
9:17
And I might have rules like this using pattern matching. So if it's given two options, the answer is to get into office.
9:24
The answer is true. And in all of the cases, the one in the EU must be different.
9:31
But also, of course, there are many different ways of watching the same function. But this is this is the one of the easiest pattern matching.
9:37
Now, at the moment, well, I mean, first thing is, supposing I had 180 types, you know,
9:43
switches and trees and lists and more clearly for many of those days, it makes complete sense to us where the two objects of those types are the same.
9:49
So it would seem a bit mad to have to define each switch and then equalised and then try another key, come up with names for these quality functions.
9:58
Whereas what I'd really like to do is I like to use equals equals, let's say is of equal, long is nil, equal,
10:08
equal nil and so on for my perhaps my list and my tree is empty, equal, empty for trees, for example.
10:15
And I shouldn't have to define these these, these named functions for doing a quality.
10:22
And that's exactly what they are. That's exactly what making these types an instance of the class gives us.
10:28
It gives us a mechanism for defining once and for all a definition of the equality function on that type.
10:33
And then we can use the same simple. So if I'm the user, if I'm writing a programme, I'm going to import your data types and say, oh gosh,
10:38
I need to pair these two to two objects of this type, this new type that you've lovingly given me.
10:44
And I've got to think, oh, I wonder what they called the equals function.
10:50
You know, if you to look at are they could that be madness? Because everyone else but the two things we just my equals equals.
10:54
And if that's if that's broken, if the type system says I don't know what that is,
11:01
it just simply means that the use of the desktop is not made, but type an instance of the equality class.
11:05
And that may be for good reason, or it may be because they forgot. We'll see Rishabh.
11:12
Yes, but yeah, I just wanted to ask you, you switch back, imagine that you have in the last and some very odd checking as well.
11:20
And since we're not using this, which is going to not use wild cards instead of the things,
11:27
I would in fact, I would absolutely those with underscores.
11:32
And again, I wouldn't have to invent names for them, which, as you know by now, is the hardest part of programming.
11:36
Well, certainly. Yeah. But underscores that that's absolutely fun.
11:40
Yeah. Actually, just to go back to what I said earlier, I think this these few slides coming up, I need to probably update them a little bit.
11:45
I've actually found two things which seem to be inconsistent with the way the the built in metal seems impossible to define.
11:53
And whilst I'm doing it,
12:02
there are other occasions where you either I've either pointed out to you or you've pointed out to me that I can easily places within the school.
12:03
So perhaps I'll post an updated set of notes if I get on right.
12:09
So the moment which is not a member of a so I can't do this if I if I try to write it off because
12:14
he said I don't know how to do this because you haven't even provided me with an instance.
12:20
What it will say is that switch is not an instance that he keeps. How can you possibly expect me to know how you want to compare them?
12:25
Right. So there's two ways I can do it. I can use this and I can create an explicit instance of it.
12:31
So I would say something like this. I'd say instant IQ switch. So please make switch the new the digital switch.
12:38
And instance, if kid was if you could remember which way round it goes,
12:44
that's the name of the class and that's the name of the type you want to add to the class.
12:48
And then you put it where the key word which we know and love and then off you go, you define the equals function.
12:51
So you don't have you don't have to get the type signature. You can optionally put it in if you want.
12:59
But that is redundant because it knows what it is.
13:03
It knows at this point the equals equals has type switch to switch to BU so your job is simply to give the rules.
13:05
And so all I've done here is to put the rules in the previous slide onto the into here.
13:12
And again, you're absolutely right, I can put underscore equals underscore useful in here and that gives me the behaviour I want.
13:17
Now what about. Not equal. Do I have to define not equal?
13:25
If you go back to look at the class declaration.
13:29
What I've done is not now provided a definition of that function that will overrule, overwrite the default definition,
13:32
but it leaves the other one, which is, of course, I'm perfectly within my rights to overwrite them, to define them both.
13:39
But if I just define one of them in this case, I have to find equal, then not sequel's is now absolutely fine.
13:46
That semantically what I want, I want not equal is not equal to be not the result of or the result of actually quite inverted, not X equals Y.
13:51
And so I've broken this, this, not this, this, this cycle.
14:00
And there may be good reason why I don't want this as the default definition of normal equals.
14:05
I can't think of why it wouldn't be, but maybe you can invent one. All right.
14:14
So there's one way to do it is to create an explicit instance. You just have to remember the syntax.
14:19
Now, the nice thing about that is I can define any notion of equality.
14:23
I want to see an example of perhaps it doesn't doesn't exist.
14:27
There's a nice example in the unassessed problem sheets for this part of the course, which I'd encourage you to have a go at.
14:30
And in case I forget to mention it, it's one for our country, but it's one for adding to the Crick's,
14:36
creating the notion of equality on times where times have different representations.
14:43
So data tykwer. But there are two different ways of representing time.
14:48
So in those cases, actually having a bespoke definitions of definitions because it is exactly what I want,
14:53
you know, nobody else could guess that I got that right. So the other way of doing it is using a deriving statement, which is what you see here.
15:00
Now, you've seen me do this in the lectures before to get around the problems of being able to print things properly.
15:06
So here's what's going on here. I'm saying I introducers when I define the data type.
15:13
So here's my data Thubron. And again, what it was, I meant it with this darrowby when I'm saying to S.G. actually please go away and derive
15:18
the equality rules for switches using a sensible and obvious notion of equality,
15:25
which is structural equality,
15:31
so that the the version of equals equals that would be derived automatically for me is one that says well to one's at the same,
15:33
to offset the same and anything else is different, which is exactly what the explicit instant declaration is.
15:41
So that's absolutely fine, so long as that's what I want.
15:47
And as I said, it may not be what I want because it may be that if I just do structural equality,
15:50
it doesn't give me the semantics that I'm asking which goes out to create instance declaration.
15:58
And of course, this raises a lot of work. If it's a data type is on.
16:05
If you go back to the day dated Monday, Tuesday, Wednesday, Thursday. So if you think about a date and enumerated site with seven constructor's,
16:09
if I have to write my own equals equals on that Monday because Monday is true,
16:16
a Tuesday equals Tuesday of true and Wednesday because when I used to argue seven times and I can say underscore equals underscore,
16:21
it's both extremely tedious and I'm just said stating the obvious.
16:27
So that's, that's exactly where dividing helps. It saves us what a lot of what we call boilerplate when the semantics is clear.
16:32
Richard, you've got a question. So in this case, where we are like using the driving function, we need to.
16:39
Predefine EKU, when we do, we just put.
16:52
You don't you don't have to do anything more than I I've written on the site. You just say driving a car and it will go away.
16:59
They seem to like to think about is it they will go and automatically construct something a bit like that at this instance declaration for me.
17:05
OK, so we don't actually need to predefine the path into. Predefine the cost that the cost to the eco class, so I should have made this clear.
17:14
Thank you for pointing out the EKU class is built in.
17:26
So I I'm just I'm just sort of muttering about just now.
17:29
I often say go away and look at the source code for the house profit and you'll see this.
17:35
Well, I couldn't find it because I think it's actually now sort of built in manually constructed.
17:39
But if you were able to look at the source code, it could cost a declaration.
17:45
This is what it would look like. So absolute.
17:50
You don't need to copy that. That's built in and there are other costs built and we will stumble across them in a minute.
17:54
Matthew. Because we've created the Internet.
17:59
Do we therefore not need the function equations which.
18:05
The function declaration, you mean, do I need to define the type of vehicle equals equals?
18:12
Yes, sir, from the previous side, do we not need to know so I don't need to copy this if you want, you can.
18:18
There's nothing to stop you doing that.
18:25
When you into this, you can say, oh, by the way, I think it equals equals is of type say it switch to switch to ball, but it knows that anyway.
18:26
So it's not adding any new information. So, so these things, these things are built into the declaration to type class.
18:34
So she really knows about this.
18:40
So if you imagine that when you freeze, when you create an instant, you're saying you'll tell me what tears I would switch.
18:44
So therefore it knows that both of these functions must be switched to switch the bill for that instant.
18:49
So there's no need for you to go to to to restate that.
18:55
All right, Arkush. And I can hear just about her, so basically,
18:58
like I'm just a bit confused as to how does the the what's called the declaring thing
19:07
know that we are defining equals to be like when two elements in the same is true?
19:14
Because when we when we defined the equals class, all we did was say that like not equals the same as the equal.
19:20
I would explicitly told the like, no, no, you're absolutely right.
19:29
But but every day it looks like this, it's got a bit I suppose it has a set of constructions in this case.
19:32
It's just got two basic Kolstad constructors with no arguments yet. We'll see.
19:39
We'll see some more examples in a minute.
19:43
So if you said, well, I've got a I've got renumerated type with two constructor and I say, what does it mean for an object to touch?
19:44
Which to object is the tax, which to be the same. There's a pretty obvious way of thinking about that, isn't it?
19:50
Which is that they're the same if they're both off or they both are.
19:57
In other words, they're different. And so that that's literally what Haskell does.
20:00
It just uses the IT implement structural equality by comparing constructors and nothing more.
20:04
And I said, if that's not what you want, which it may well not be, then you have to create an explicit instance declaration.
20:11
You know, I'm just curious as to like how he actually does because like it because in the declaration of the class,
20:18
we we haven't really told it that it's actually returning equality, as we just said.
20:25
I don't I mean, you couldn't write you can't write the function which does the deriving.
20:32
It's built into the component. Of course, the compiler knows the data types.
20:37
It knows the names of all the constructors and it knows its own bowels, so to speak.
20:40
So they can it can straightforwardly generate exactly this sort of exactly this sort of definition here.
20:46
On our behalf. That's that's tricky because it's just saying, well, it's just it's just using structural equality by comparing constructors not.
20:53
If the question is how would you try to function, which generates this string or generates the internal representation?
21:04
Oh, I have no idea. I mean, that's a that's an internal affair. But but it is obvious.
21:12
It is obvious. If I tell you the date stuff, you can write this down with a pencil and paper or you can type it into a script so you can do it.
21:17
And therefore a computer can do because it's just it's just it's completely automatic.
21:22
Well, yeah, Ruth. If not Andrew, Andrew wants to go for a drink, I think you've just I can't hear.
21:27
Andrew, you go first and see if you can fix my microphone.
21:41
Yeah, sure, like, it's just kind of like a follow up question, like this is the right thing.
21:45
It's just like kind of like string matching ish. Like, I was like wondering basically like how it's like driving like Implementor basically, OK.
21:49
I mean, maybe we'll just postpone this until we look at our cars and trucks going actually going to show you how it would do it.
21:59
Got a bit of a pencil and paper actually were coming up. It's still not clear. Then you can put your hand up again.
22:05
OK, Trouville, you won't have another go. Because I can't hear you, I don't think that means probably nobody else can.
22:09
But something where you might are going to carry on search if you have if you can fix it and then you can come back to me.
22:20
All right, what's next? See? OK, well, this is kind of this is the quiz I've already I've already asked this question.
22:28
So given the given the the class declaration that we have built in,
22:37
if I build myself a new data type day and it's got one constructor in this case, I've given it an argument.
22:42
Doesn't have to be that, but it does. And I create an instance of BQ for Tidey.
22:48
But I don't I don't overrule I don't have a right or don't define either of these two functions.
22:54
So I just create an instance where if I don't define these functions, are will default to the ones you see above.
23:01
So if I build two objects of type deep example, C1 and C2 and asked whether the same, of course, the programme is going to loop, isn't it?
23:09
Because if I see one equals C two. Oh, let's go and find out in this case Xixi one.
23:15
And why is it so hard to get them. That is the result of not X not equal.
23:22
So how do I calculate next not equal Y. Well I use this rule and this is not X equals one so I go to actually.
23:28
OK, how do I find that. Will I come down here. Yeah. Yeah.
23:34
And I've got a figure of eight cyclic dependancy here and it's just not going to terminate.
23:38
So this will loop indefinitely. I think that the teams that I'm in, I think you told us it is not shout.
23:42
Yeah, yeah, it's it seems that all right, so what about context?
23:52
So when we come to look at type things, we've already seen this.
23:58
We see that some type signatures are kind of polymorphic. They sort of something a2a to something they wanted to teach someone.
24:03
But they have a context which which restricts the sort of universal polymorphic time to them types which are members of a specific class.
24:10
So here is a an example. This is this is what we call a minimalistic function.
24:19
This is the types of frozen to be in synch and buzy.
24:25
Give me two minutes. I'll give you a ball I compared to witness and give you true or false. That's a double function, as you might say.
24:28
Well, I've just tried to generalise that by making it polymorphic. So if I tend to do that by writing that,
24:34
that and the compiler will complain and say it's a type error here because you've attempted to define a polymorphic function,
24:39
I sort of for all t t t t table, whereas in fact, in defining that function, you're using this little fellow.
24:46
This basically equals equals in the end, we all know that equals equals equal is only defined if X and Y are members of the equality class.
24:53
So this this type signature is inconsistent with the definition. So what ghc what you have to do to fix it is you have to provide a conceptual.
25:00
Oh I sort of mean, I don't mean for all day, I don't mean for all.
25:10
I mean those ts which for which there is a definition of the quality for which there is a notion of equality,
25:14
meaning that there's an instance of the working class and the syntax about looks like this and we've seen this before,
25:22
this kind of explains why this comes about. So that is now a very different definition.
25:26
So just what is just what the compiler does? We'll come back and look at this again in the minute.
25:31
If I try this definition well, if I look at the correct definition.
25:36
So so ghc in fact, if you think about how how ghc might derive the definition of equals, if I did,
25:42
if I didn't have this line of code, ghc would derive it for me and it would do it as follows.
25:49
You would say, well okay, I've got two things.
25:56
Are there there are some unspecified type were called T T one and two and then on the right and said oh wait a minute.
25:58
And these two objects have been compared to equality.
26:06
And therefore I know they must have the same type, which means T one is equal to two T, if you like.
26:09
And also that T must be a member of the equal clause, because if it isn't, you can't use equals equals so straightforwardly,
26:15
the type system will infer the type, the same type to take the bull where T is or T must be also constrained to be a member of the equality clause.
26:23
So it's pretty much the diagram I just drew on. The virtue of what. Well, here's another example we've seen in the L.A. Times.
26:34
In fact, we've even seen it time and so we know how that works is just a reminder, is this item a member of this list an element to this list?
26:42
So what is the type of Ellem? So in fact, let's do this and I'll do this on the whiteboard.
26:50
How do we define LMG? Remember we said something like, so I'm not I'm not going to put the type signature.
26:57
And so we said an item X. Is it well, is an item X Y could use an underscore here,
27:05
is that is that an element of the answers is false because there are no elements in the list, so.
27:13
Yes, you're quite right, I can replace that with the school.
27:21
And what about something which is non-empty? So I've got a list but say I'm searching for X.
27:25
What's really cool is why Tom's boys coming, what I call it when we find it right.
27:33
So now there are two cases. Either X equals Y. In which case the answer is true.
27:39
We can stop immediately found it otherwise. Banana.
27:46
What have we got? Well, we know that X is an equal Y Z, but it could be the case that X is somewhere in Y, somewhere in the telescope.
27:53
Just try again. We just recurse and we asked for the X amount of lines right now.
27:59
What do you do? How does how does she actually work out the type signature for this function?
28:04
Well, I guess the first thing it does is it counts the arguments and it says,
28:09
well, Alan's got one, two arguments and he's got a result, unsurprisingly.
28:13
So I know that the shape of its type must go something like how we should we do this one right there?
28:17
Well, OK, I don't at this point, I know nothing either. In fact, they've got two arguments.
28:26
The arguments could have completely different types. So it guesses. And quite literally what it does is it invents type variables as well.
28:29
It's something of the form to be for some A and B, and there's some result type C, so it knows the shape of the type signature.
28:36
So I'll just move this over a tad. Might need a bit of context in which we fall asleep watching this.
28:46
I can't stay awake, I hear is I just muted whoever that was.
28:58
Right. So let's see. So now at the first rule, so let's inspect the first rule and we say, oh, OK, I learnt nothing by looking at the score there.
29:06
So I don't know anything more about the. Oh, wait a minute. The second argument is a list of things.
29:18
And therefore, I know that the second argument must be something of the form, some sort of type structure,
29:22
A list of B, so it can now refine that type because it knows it's got to be something like that.
29:27
And then we come to the right. Oh, wait a minute. What's inside is a boolean. It's false.
29:35
Is an object a typo. Therefore I know that the C must be a ball so I'm going to replace that with.
29:38
So that's all we know from the first words. Now we come to look at the second rule and it's associated guards'.
29:47
Right. Well, we just got the variable. We don't need to look at the X and wait a minute, there's a pattern here.
29:53
But I know that that's a pattern for Lowney match lists.
29:57
So that's I know this well. I knew that anyway. I knew that the second item was a list of some things, the information, information, information.
30:02
I look at the first card, this one here and is okay.
30:09
Right. So now I'm comparing the X and the Y using the equals equals function.
30:13
That tells me two things. It tells me that the type of X minus be the same at the moment.
30:18
That code may be suggesting the different, but now I know it's the same type.
30:23
So I can either replace the with the base of the being the name. So how about I replace that one with an because it's going to be the same type.
30:27
And not only that, I know that that type must be a member of the class, otherwise I couldn't, I couldn't use it as equals.
30:35
So that means I've got out of context.
30:43
So that will get added and lo and behold, I think that's all we know, so we'll just double check it a sanity check to the last line.
30:46
Well, otherwise, what do we do with in that case? Oh, yes.
30:54
I was just sitting here looking at that thing. In that case, we get a true therefore the result of the court.
30:59
Well, it must be true, but I knew that anyway because of this thing here.
31:05
And finally, on the last watch as well, if all else fails, we will recursively call the Allen function, giving it presumably away on a list of days.
31:09
And it should give me back a bow. Well, it does, because the types of judgement, because we you know, if you want to think of this way,
31:19
the type of this this thing, this thing must be the same as the type of this thing.
31:28
Otherwise, there's something wrong. And we already know that Ellen, given a list of eyes, gives me back.
31:31
So it all lines up. And that's pretty much the way the algorithm works.
31:38
In fact, this is such a beautiful algorithm. It's a number of years ago I set it is a January test and it's a it's a it's a beautiful exercise.
31:42
It is arguably one of the world's most beautiful algorithms.
31:50
I can say this is this is this this is the story of higher order, polymorphic type of influence on.
31:53
And what we will do is a practise test before you do your testing journey will go through that.
31:58
Perhaps you can spend some time in maybe the end of this term, maybe for Christmas,
32:03
having a having a go at it and see if you can solve your self when you come back.
32:06
One of those for sure, you have to do it beautifully in a light coding class.
32:11
All right, let's do one more then I have a little break. So this one is the look up function.
32:17
Now, we looked at the look at function last time. Remember the look at function? Oh, this is the thing that works with maybes, isn't it?
32:23
We talked about the maybe date of time and I deliberately limited the time signature.
32:28
But look, I said we'll work it out later. Let's come back to the to the.
32:34
Yes, I'll have to flick between the two I guess is probably the way to do this.
32:40
So let's think about the type signature of the look at function.
32:45
Well, again, I know its shape. Look up.
32:49
Is a type of the thing you need to be to t.A to.
32:54
The to C. That's that's all I know at the moment without inspecting the rules.
33:00
So if I come back here, let's look at the first line of code. So look up key in the empty list.
33:07
Oh, wait a minute. So this doesn't have anything more about it does tell me. The second argument is a list of some things so I can refine my type.
33:13
I know that's a list of some things. Right, so far, so good.
33:23
Let's come back here and what did we see on the right signs?
33:30
Oh, nothing. Oh, what? We know that nothing is a constructor of the Navy data type.
33:33
Therefore, this thing, my whiteboard here.
33:40
No, not to put a there was all just wrote this out on the next line.
33:44
This goes to maybe. See, why is it maybe see, because nothing is a construct of the maybe data type.
33:51
So if I see anything in the programme, I know it's a maybe something, maybe it's a maybe A for somewhere or maybe see for some C.
34:01
So I'm refined, you see what I'm doing, I'm I'm refining and specialising the type variables as I discover more about them.
34:10
Well, it was the third line, tell us. Well, it says, well, look at Keano doesn't know anything more about QI, but wait a moment.
34:20
I knew from the first rule that the second was a list.
34:28
I now know from looking at the pattern that the first item of the list must be a pair because this will only match pairs of things.
34:32
This is a pair of variables in a triple A to check for the variables.
34:40
That's the pattern that will only match two tuples or pairs of values.
34:45
So therefore, I know that the argument isn't just any old B, it's actually pairs of things.
34:51
So if I come back to the magic whiteboard, so say this B here I've got in the square brackets.
34:59
That's actually that B is is A. Is a past, so every item on this list must be something in the form be well, I can call it B B from whatever B day.
35:04
These are just type variables. Right.
35:17
So so we've learnt something. And now we say, well, OK, the cons, but I knew it was a list anyway, so I don't know anything about that.
35:21
So let's get on to the next line of code and say, oh, wait a minute,
35:31
so this first argument now is being compared with the head or the first item in the head of the tape, the case.
35:34
So this could be a key value pessimistically that it is so to know what to do next.
35:43
The programme is asking whether the key the argument, first of all, is equal to the first element.
35:48
Of the head of the list at the table representing the table, and lo and behold, she's in the equals.
35:53
So now I know the key and the first argument and that first I went to the head must have the same type.
36:00
So if you come back to the magic whiteboard, I know that the A and the B must have the same type.
36:07
So what I do arbitrarily is I'll replace the A B in there with an A. It's come back to the programme.
36:11
Want and also equals equals means that they must be a member of the equality class.
36:22
So can I come back here and I can add a context which says that this must be an equally.
36:27
Well, what else do we need to look at? Let's see on the right hand side.
36:36
Well, it's a just but that's the other construct of the maybe toxo. I know, but I knew that was a maybe something anyway.
36:41
But aha. Look, that says just be well, that V is the second element of that pair.
36:46
So that was the type for that. I could be prime in my type signature.
36:52
So when I said maybe see here just now.
36:57
I know that that seems must be the same type as the people otherwise. This would be in touch.
37:02
Of course, if that's what I mean, then the type of V must be the same as the the C, if you like, which this type of, like, invented.
37:09
So therefore, I can either replace the people on the C receiver, the people on the primes back here.
37:20
So it's clear that. So what I'll do is I'll replace the B prime with a C.
37:27
I can go through and read, I can just rename the variables any points I want, right.
37:35
And I think that's probably it, isn't it?
37:38
And the last line is, again, to sort of make sure everything lines up.
37:42
Yes. Well, the right hand side is a precursor to look up, and that should give me back a maybe see what it will.
37:45
Because we know that the result of look out must be a maybe from the previous rules, so we end up, you know, starting from scratch,
37:53
you say just saying I know it's something that we need to be to see by looking at the definition of the function we end up with.
38:00
But it's not particularly well laid out, is it? And perhaps if I were to write it out again,
38:06
I might change the into the variables and I would say it's EKI sugar and I would have to see what Haskell actually causes type variables.
38:10
You might call them t t one t to these days. You know what.
38:20
So something like this. I can name the names that I can be named as long as I'm consistent, and that gives me a maybe.
38:24
The. In fact, over here, if I go to so where is maybe make this continuously?
38:36
What's the title? No, it's not. It's not.
38:47
And rummage around actually got the list. Um.
38:52
Oh, no, look up. Look up. His building was the type of look like.
38:57
Oh, I've got my the data.
39:07
What am I doing here? Oh.
39:15
So tell me what this is go to, because in the programme anyway. Right.
39:21
I didn't include the time signature anyway, trust me, the past come back to that.
39:32
It's something like that. I just wanted to tap in to see where the weather these days, of course.
39:38
And they, Auti, want to impose it for us, all of it.
39:42
So I didn't notice your hand handle.
39:47
How would we define a function that requires multiple restrictions like variable A. that's of type X and a variable B of type Y?
39:51
Right. Well, there's one coming up, actually.
39:59
If you just hang around and come back, if it's not all right, that's a good place to stop cerebral palsy and have a little bit of a break.
40:00
And you can go get yourself a cup of tea and wake yourselves up and we'll come back and
40:08
let's come back at five two and we'll have another break and 20 minutes or so after that.
40:13
OK, everyone. Welcome back. So let's see where we are, I'll come back to here.
48:11
Right, so, yes, as I said,
48:21
I said I said out loud that Look-Up is built in so much you can see I've just done this on my other machines, simply Diltz, let's say.
48:22
What is the type of that?
48:31
Then it doesn't indeed today and be there, so it gives us an hour which lines up with what we kind of worked out on the virtual whiteboard.
48:36
Good right then. So it turns out that some type classes may be what are called subclasses of other classes,
48:44
which basically comes down to having to restrict their instant's types to belong to other classes.
48:51
And the simplest archetypal example is a thing called the old class, which we do know something about because we've been using it since lecture one.
48:56
So let's see how the old class works in just a second.
49:05
It's actually defined in terms of auxiliary data type called an ordering, and there's very good reasons for doing this.
49:08
Actually does look a bit clumsy at first, but actually it's because exactly what you want.
49:13
So an ordering is just an enumerated type with three constructors referring to less than equal and greater than.
49:18
So let's see how it's used in the world class on the next slide.
49:24
You see this? She's, I think, verbatim what you see in the in the Haskell source code, which is in it's in GHC or somewhere.
49:29
I'll check it out if you're interested. Put it on an open source code. It's quite hard to find.
49:40
I was just to find this this place this morning. The source code this morning right then.
49:44
So here we go. So here comes a new class. This is again, this is Bellson.
49:52
You don't have to do this yourself. This has been done for us by the designers of the language which the class each class all day.
49:56
Let's just focus on that. Here comes the order with the following member functions.
50:02
So there's a function called Compare, which was given two A's will give me about one of those ordering things over an equal or greater than.
50:08
So that's a member function.
50:15
There are also these member Opry's infix functions as member operators, the ones that we know and love that we've been using all along.
50:17
So, for example, less than takes two hours and gives you like a bowl.
50:24
And there's Maximon. We know about that from your very first exercising one.
50:30
So Max and Min, if provided a provider, is a member of your class, then there will be a definition of Maximon for that.
50:35
And what does maximum do? Takes two hours and gives you back in time. So the max of one and two is two.
50:44
And so so now we have these different definitions.
50:49
So these different definitions are cyclic. So if you look at them, we got the cantare function.
50:53
What does it do? It says, well, you give me an X and Y, both of type A, of course, from the signature above.
51:00
Then if they're the same, we return Q if X is less than because Y will return less than Alti, otherwise we return greater than.
51:06
So you think, OK, right. So how do we. Well now here we go.
51:16
We know how to do that because that is the function of the old class.
51:19
But then you think, wait a minute, wait a minute. That means that if a Taipei is a member of the old class, it must also be a member of the class.
51:26
Otherwise I wouldn't be able to talk about line code.
51:34
So in the declaration, the class itself, there is a context which says foreign aid to be a member of which is what I got here,
51:37
there must be a context that says they must also be a member of the queue. And that's the Syntex we use.
51:44
That's exactly the same as we would use in a type signature. Instead, it appears in the class, the class declaration.
51:48
Right. So carrying on. Carrying on, so you be in that now we see why there's this this eco context, so how do we define X is less than or equal?
51:55
Let's go and find out. They're actually just as equals as well.
52:07
In fact, for all of these four things down here, what you do is you use the compare function.
52:09
And in the case of lesser equals, if the compare function gives me greatly, though, it doesn't give me greater than the answer is true.
52:15
And so on down the list here. And you think, wait a minute.
52:20
There's a cycle here, right, because in order to know whether X is less than make it away for the purposes of the COMPAR function,
52:25
I have to delegate to this rule.
52:33
And this rule says to work out with the next victim y using the infix operator, I have to go back and delegate to the COMPAR function.
52:35
So the compare function and the X is less than equal function and cycles all the way through.
52:42
If I don't break the cycle, then I'm going to be angry. I'm going to tie a knot in exactly the same as I would in the equation.
52:48
So minimally, when I create an instance of the old class,
52:56
I either have to define the COMPAR function to break the cycle or I have to find the lesson or equal function to break the cycle.
53:00
Otherwise, as I said, it's just going to go on in there and it is a figure like a mutual mutual dependency here.
53:07
And we say that all inherits the operation to the weaker in the sense that once I write this context,
53:13
I know that I can use it as equals any time I've got in my hand and it'll be just fine.
53:18
And that's exactly what I need to define the future. Right.
53:24
So so what do we know about the old type and FUP kind of encouraged you to do?
53:30
This has been going on. You can actually say, tell me about the old type and it'll tell you quite a lot.
53:36
It'll tell you all the instances just need to skip school. It it'll tell you all the instances of the of the old class.
53:42
And so we'll come back to some of those in just a minute. But let's just go up here.
53:50
Here's the summary. There is a class essentially the class declaration. It tells you how it's defined.
53:54
It tells you what the member functions, actually the types of those member functions.
53:59
And then just in here, actually, interestingly, it says minimal compar or less.
54:03
What does that mean?
54:06
It says if you create an instance, you've got to break this infinite loop by either defining the COMPAR functions as well, the whole thing.
54:08
This is a mathematical law, either by declaring the function or by declaring the function.
54:14
That's the minimum you must do in order to break the cycle. Otherwise, any instance will live as soon as you ask for synergy.
54:20
In this case, if you ask is what is where is the next lesson, why that will loop indefinitely unless you've broken the cycle right.
54:28
And down here, what you're saying, by the way, is all the instances of, oh, someone has made into an instance of all.
54:36
Well, that's great. But we kind of knew that anyway,
54:41
because we know that we can say he's one less than two and simple floats and double is one point three point nine and so on.
54:43
So many of the characters. So all the stuff down here just tells me the the the current built in instances, if you like.
54:50
So will come back to that later. Now, I think there's a new question by Hakone.
54:58
Hakan. I don't think that's a team sound, is it?
55:06
Now, I can't say again. OK, so because you go back to the slide at the ordering house, yeah, yeah, I was just wondering, on the condition,
55:13
does this other compare the compare function that lets you go why is salty and otherwise it is is greater than.
55:27
Yeah. What we know, we know it can't be if it's equal, we would have picked this rule.
55:37
So we know it's not equal when we get to this line. OK, so.
55:46
Just because I'm confused, because, like the second line at the bottom there, this is X and Y is is X, Y equals equals Alti.
55:53
So so basically IQ and either one of of less than or greater than must be defined.
56:04
It's all about breaking the cycle. Yeah, in terms of breaking the cycle, because it's a cycle,
56:14
I only have to declare either compare if I if I provide my own definition of compare or I provide my own definition of less than or equal.
56:19
Because the only functions that it's used in compare this one, which but that's OK, because that comes from the EU class in this one.
56:30
This one comes from by default, come from elsewhere in the world class, which is this rule here.
56:37
So there's the two lines that are mutually dependent on that one.
56:43
And that one, so for that reason, you've got to break the cycle and compare, which gets rid of this rule as highlighted,
56:47
all I got to define this record, which gets rid of the this compare on the right hand side.
56:55
Of course, I would say got it here. There's no other way of no other operator.
57:00
There is is is shared between the compare and the features inside the control function.
57:05
It's just the two. OK, thank you.
57:10
OK, Qianjin. Yes, so it actually use something like minimal instruction on the comment and you say the men, I mean minimal.
57:15
I mean the old mineralogical in the code.
57:29
Yeah. When I said that, I had just done that just.
57:35
Yeah, so when you when when you asked for this, it will it will show you this, it's a reminder to you what you have to do.
57:44
So let's try the same thing with the tell me about the working class.
57:51
And again, I get a bunch of stuff, but if I go back and look at the.
57:57
Thing up here, see, minimally, you've got to break the cycle either by defining the equals function or the not equal function or both,
58:03
but you've got to do at least one of them. Plus, what the minimum.
58:12
So, I mean, let's see if I to define my piecrust, do I need to try something like this?
58:15
If when you quote it, if you quote an expression, this response, you must implement one of these two things, otherwise you'll get a warning.
58:24
Yeah, and I mean, if I write my own, I don't have class like class something else.
58:34
Oh, you wrote. Oh, that's a good question.
58:42
So this is I suspect I'm guessing that I would I suspect if you wrote that in your class definition, I think that.
58:46
The compiler, it looks to me like the compiler would use this information. So I think it actually parses this and it uses this information.
58:56
So when you create an instance, it checks that the user has indeed declared one of those two functions.
59:02
Yeah, but I've never done that myself. Interesting enough to try that.
59:08
I should try creating a new class and adding a definition, a comment like that.
59:11
So I like Christmas, but also a message to compiler to ask compiler to check the tab.
59:17
Yes, it is telling it's telling the compiler to check each instance to make sure that the circuit.
59:26
But they won't actually stop you. It'll just give you a warning. OK.
59:30
OK, Andre, why didn't that say that you need to define maximum.
59:34
Because it's go back. And.
59:43
Oh, because this is this slide, is it? Oh, because this is incomplete.
59:49
Thank you. There is some lines, there are some like in there with me.
59:55
I might actually be able to recover. I'm just saying I'm just going to my other machine as we speak.
59:59
No, I think I think it's I don't think when I first produced a slide were indecent lines of code,
1:00:27
but I'm just actually trying I'm just taking out the one that's in GHC source code.
1:00:32
She took classes, so, no, you don't have to you don't have to declare Maximon, so you can have you can have an incomplete instance.
1:00:44
So I think I think the way that you can create an instance of the experience of the class and if you omit the definition of Maximon,
1:00:54
you just get them. They're just not there.
1:01:00
But so, so so let me see that it will issue a warning to say you haven't declared Maximon, but there's no requirement to break a cycle.
1:01:03
So the reason why that minimal thing is there is in order to ensure the cycles are broken,
1:01:11
not necessarily to ensure that every every function is defined.
1:01:17
And I think we'll come back and discuss that when we look at the class in just a minute or tomorrow when we get time to question.
1:01:21
Right. Right then, so let's see.
1:01:28
So in the same way that I can derive Ogami, I've just noticed you put your hand up.
1:01:36
I mean, yeah I just wanted to ask what what reason are we like creating cycles in our tech class definitions.
1:01:43
What's the reason we're doing that. The reason why we create. Well we don't deliberately create cycles,
1:01:51
but the reason why these cycles exist is because the person who designed this class is trying to trying to ensure that when you create an instance,
1:01:56
you write as little as possible and you can bet your bottom.
1:02:03
If you go back and look at the working class, that's this one here.
1:02:07
This is a slightly easy one to look at initially in ninety nine point nine.
1:02:11
I mean, I can't think of a single case where if you if you specify what you mean by X equals Y,
1:02:17
then this would be the wrong definition for not equals. I'm sure we could construct an example, but it would probably be very contrived.
1:02:24
So it's just to save me having to write an extra line of code.
1:02:31
You know, if you said, oh, you've got to define equals and you've got to define not equals, that would be madness.
1:02:35
Because you tell me what you tell me how to say what the two things are equal.
1:02:39
I can tell you automatically what it means for them to be not equal.
1:02:43
OK, it's yeah, I can imagine when you see the old class, she said, well yes, when you create an instance of the old class,
1:02:47
you've got to go through and provide definitions of all these functions and all but certainly compare.
1:02:54
And unless you have to break the cycle, it's creating a lot of work typically what we do.
1:02:59
But when I show an example in a minute, we justify our typically define just this one.
1:03:04
And that breaks the cycle, so we'll see an example in just a moment. Yes, so they're not being malicious and they're actually trying to help you.
1:03:10
Oh, Mohammed, another question for each class.
1:03:21
Would we have to define all the types that it works on?
1:03:24
Yes, you do. Yes. You have to declare when you declare the class, you've got to declare the types because he doesn't know what he doesn't know.
1:03:29
When you create an instance, you don't have to reproduce these. So I show you an example.
1:03:38
Well, we'll do it to see what it looks like. So in the same way, I can derive the rules for IQ, for the equals, not equals functions.
1:03:44
I can also derive what's called GHC. You can derive for me the rules for Aude.
1:03:55
And again, it's going to use some sort of sensible notion of ordering.
1:03:59
So here is an example of an enumerated type and it's obvious what equals equals will be defined for this thing.
1:04:03
So it's obvious what happens when I derive what happens when I derive.
1:04:10
Well, guess what? It's going to assume that these constructors are ordered Monday, less than Tuesday and Wednesday and Thursday and Sunday.
1:04:15
So it assumes an ordering, which is reflects the order in which the construct is written in the date of time.
1:04:24
So if I automatically write that thing and I say, is Tuesday less than Monday, the answer is false because Monday is the construct.
1:04:30
Monday as a constructor appears to the left of choosing is a constructor in that in the data type.
1:04:38
So you can collect this and you'll see. Hmm. Now, if that's not the ordering you want,
1:04:43
you've got to create your own instance declaration explicitly and until you see what you mean by less than less than weekly and so on.
1:04:49
All right, well, we're cursed data types can also be I and they can be added to IQ and they can get it.
1:04:58
Well, let's just see how this is going to come back to wants to hopefully answer the question you ask in just just a moment ago.
1:05:03
So here is a list, data type.
1:05:09
This is the one we had in the slides early on, it's a it's a synthetic manufactured data type,
1:05:14
which is isomorphic to housecalls list, and you probably would never, never actually write this one yourself.
1:05:19
But there's nothing stopping you. And I think if I just go back to just as a sanity check, I think we've already got this somewhere.
1:05:24
Here it is. And I derived equal in this thing show, but I haven't derived old.
1:05:34
So what we can do in a minute is to create another instance of this which would be quite helpful.
1:05:41
Mean can. In fact, let's do it now, right?
1:05:46
So at the moment, in my definition, in my script, I've got I will come to show in the mornings,
1:05:54
but I've already derived the rules for the quality function and therefore the inequality function on this.
1:06:00
But without that, I don't have definitions of inequality.
1:06:05
So you might think, well, what does Haskell general write? If I ask you to write this automatically and I'm going to show you an instance declaration,
1:06:10
which hopefully gives me exactly what you get back if you'd said the writing on.
1:06:18
So to break the cycle, we know we've got to define less than or equal.
1:06:26
So let's come back to our script. So I've got the day to type here.
1:06:30
And in fact, let's come to the bottom. I'll post that in here.
1:06:37
So and at the moment. Oh, did I say.
1:06:44
The idea is actually kill that and come down here, I'll bring I'll bring in the driving as well.
1:06:51
I'll leave the show for just now. It doesn't do any harm.
1:06:59
The important thing is we've already derived the equals of not equals function by virtue of that line of code in there, but it's missing the order.
1:07:01
So let's see what would happen if I put the order and let's try and synthesise
1:07:08
a definition of less than or equal or if I made my own instance declaration.
1:07:12
And hopefully that's exactly the same as the definition to be synthesised and forming automatically.
1:07:19
Right. So here comes a syntaxes instance and I say, oh, what a so if A is members, in fact, let's just let's just leave that for a second.
1:07:23
What I want to say is ORed list of a capital.
1:07:33
Where I want to make a list of a member of the old class,
1:07:39
so let's just leave that and I'll come back and fix it in just a minute, this isn't quite right.
1:07:46
So now I've got to define this function onto less.
1:07:50
So if I like two lists X and Y, say, what does it mean for us to be less to one that's going to break the song like.
1:07:55
All right, well, I know that my list construct the my list is to construct is nil.
1:08:02
And Kohn's, what do you think would be a sensible audience for that? Well, it should reflect the what we got on the list.
1:08:08
So if I say is that less than equal to that, the answer is true enough.
1:08:15
I say, is it less than that?
1:08:20
So if I if I ask these questions of Haskell's built in the stuff, so presumably going to have to invent rules which do the same sort of thing.
1:08:22
So let's go back in and start this off.
1:08:29
So if I've got the empty list on, I ask, but I've only got to define less than or equal just to break the circle.
1:08:32
Everything else, everything else will be derived automatically in terms to this less than equal thing.
1:08:39
So. Well, nil is less than anything, isn't it? So nil is necessary to nil is also nil.
1:08:44
Doesn't do anything of the form cons because that's, that's our normal understanding if you like a lexicographical auguring.
1:08:50
I guess. So that's going to be true. So what about to do the Conca.
1:08:57
I suppose I've got Kohn's not to Ukraine Essere because it's my own data type.
1:09:05
So it's got context and I'm asking whether that's is that less than cool.
1:09:11
So of course immediately think settings but let's do that and I'm missing an equal.
1:09:17
Well, actually, do I put this in the let me let me just go back and stop being so stupid?
1:09:30
What I meant to do is this is fix it up in just a minute.
1:09:37
So I said, I've got a missed concept. This is last week. It took some context, prime say excessive pride.
1:09:44
So what do we do now? Well, they're going have some guards down here, the checks in just a minute.
1:09:50
So I don't actually think I should just stick with what I've told you.
1:09:54
Put the equal signs down there and you can't go wrong. Right. So now we got to do some thinking.
1:09:59
So I've got to list. How do I know whether the one on my left is less than the one on the right?
1:10:05
Well, if I if I inspect the X in the X prise and I say that is less than X prime.
1:10:09
It is certainly true, isn't it, because. If X is less than explained, then concert sex is less than cons exploit exes for any exes at any point.
1:10:16
So this must be true.
1:10:28
Or I could say, well, if X is equal to exploit and then I'm probably the one to last, I'll put the three I can use and otherwise, of course.
1:10:30
But this is quite nice, although not explicitly. If X is greater than X prise, they also must be false.
1:10:41
Because. If I've got something like, well, why?
1:10:50
Because if I come down here, if I'm in high school, in high school world, if I've got four and then some other stuff, I don't care what it is.
1:10:56
And they say, is that less than equal to. And I say, well, let's say I won.
1:11:06
And some other stuff and stuff is the answer is. What about the.
1:11:11
Let's come that the answers, folks, so for that reason, when I come to define my only condition now,
1:11:22
I need to do some alignment and I think there's something wrong.
1:11:30
I think I don't like I think you need to make sure that it's comp.
1:11:34
I haven't finished yet till finished, OK? Oh, you're absolutely right.
1:11:40
So what do I do in this case? Well, I can't tell.
1:11:45
Can I see if I've got two lists?
1:11:50
If I go to Haskell, well, I got to the beginning with the same number in this case, if I'm comparing lists of numbers and I say, what's that?
1:11:53
Something like that, I can't tell just by looking at the ones yet, because it's the left or right lexicographical.
1:12:04
So I guess I could well part the ones.
1:12:11
Let's now inspect the two, three, two and see whether that's smaller than three to nine, in which case, of course, I'm going to get through.
1:12:13
So I would expect that to be true,
1:12:19
but only so it is true because this list is sublist is less than or equal to so list because I couldn't tell just by looking at the one.
1:12:21
Right. So here what I have to do. Is I have to ask whether EXIS is less the media access point, if only I had a function to do that?
1:12:30
Well, I do. It's called less than or equal because it's just recursion.
1:12:39
So I can just use recursion to say that, because I know that if this device is a member of a ward,
1:12:42
then any time I see a list of eyes I can use less than equal, I have to know that is a list of days from the time signature.
1:12:50
So that's the best thing about recursion. It just allows me to write that record.
1:12:57
So the only catch is, as I think it is being pointed out, is the fact that if I'm using pulse here, then I can only use that function.
1:13:02
If the type which is the same thing here, which is the premise of this construct,
1:13:11
the list, the list type constructor, if that A is itself a member of the class.
1:13:17
I haven't told you that yet. So it would object to this.
1:13:25
So I have to put a context in to say that this was so I remember the I remember the old class,
1:13:27
I should say, because I'm using both inequality less than and greater than and equal.
1:13:36
So if I'm if I'm if that functions be valid, then the A's must also be members of the old class.
1:13:42
So I need a context here.
1:13:47
And the context here is something like that so I can make a list, be an of support provided a is already an instance of in which case a work.
1:13:50
And then I can write things like this. Indeed, I can write that because I know already that if I is an instance of the old class,
1:14:01
what we've just been discussing that day is already already there, for instance, at the EKI plus, why do I know that?
1:14:10
Because in my type class declaration.
1:14:15
I had this so we know already that any type that's been made an instance of or must already be an instance of EKU,
1:14:20
otherwise the type system of throwing it out. So that should, Paul.
1:14:28
And it does so still, I can say something is new.
1:14:38
What were the examples of just how just as a you check my head than that so I can say, well, back in my list?
1:14:41
Well, I asked, what is that less than equal to nil? So true, is it strictly less than it's spelled correctly, and that's false?
1:14:47
What about something like a [INAUDIBLE]? You're actually supposing I got the cons of one with a cons of a four with No.
1:15:00
And I say, is that less than equal to the cons of a five year play cons of a and eight?
1:15:10
No. So they don't have to be the same length. But just to me typing, then the answer is true because because the one is smaller than the five.
1:15:21
So it doesn't matter whether that number here is bigger than or equal to the four below zero, for example.
1:15:32
And it's still going to be true.
1:15:38
So if I now make the head of these two, let this thing but one in there, for example, now it can't tell just by looking at the one.
1:15:40
So therefore it's going to recurse into the tail. It's going to look at ask whether that list.
1:15:47
Is less than or equal to that list, and in that case, the answer is false, because four is absolutely not less than equal to zero.
1:15:52
OK, your hands up. Can you can you try doing something like KONE's while Nhill is less with a little.
1:16:02
Oh, I'm missing a case, yes. Oh, yes, good idea.
1:16:11
Well spotted. Yes, I'm missing a case.
1:16:16
What am I missing? Well, I've got.
1:16:20
Let's just say this patent covers nil and nil annual incomes that covers cons and cons, and I am missing, I guess, anything else.
1:16:23
Yeah, so anything less than equal to anything else must be, I guess, false.
1:16:33
Just lay out consistency. I'm going to do that. Yeah.
1:16:42
Pick it out rules and stick with them. Thank you. So if I come down here and that programme.
1:16:47
Oh. What?
1:16:54
If I talked with him, help of if you buy a car, if you type like underscore, underscore, then what it is much already with guns or.
1:17:05
You mean this up here and this one here? Yeah.
1:17:18
Yeah, but don't forget. Yeah, the layout is not the best layout, is it,
1:17:24
because this is why I don't like using I'm very scared about using underscores in Haskell programmes, because last I'll give my own school speech.
1:17:31
If you just look at this, this is this is actually a line of code here. And the underscore sits quite low because of the font that is VIMS using here.
1:17:38
And it's quite, quite easy to think that that under score is part of the line below.
1:17:46
But actually this is just the third one. This is just the third pattern. Don't forget patterns of chestful top to bottom.
1:17:51
So the first question we ask is, does it match that pattern? And if it doesn't, then we say, does it match that pattern?
1:17:56
And if it doesn't, then we come down to the third room. So it doesn't matter how much that pattern.
1:18:03
Well, in that context, we know that the first argument can't be nil. And we know that the two arguments can't both be.
1:18:07
So the only one that's left actually is the case. But I've got a condominium because I've also covered.
1:18:13
So I could have written here a pattern column before.
1:18:19
I could have written here a cons, something I'm done something in less than now, and that's another that would certainly cover all the cases.
1:18:23
But actually I happen to know it must be of that form by the time I get to this long code,
1:18:34
in which case I will suffice to say just a little note and underscores I think Mullaitivu might
1:18:40
be using underscores in identifiers and not just you can turn the mike off now if you're not.
1:18:46
That's it. So, yeah, I don't know if I can demonstrate it on the keyboard here, but, you know,
1:18:56
the thing about caring is that in Haskell, you I F of X, Y, Z, we tend to watch our functions carried stuff.
1:19:02
We don't have to be secretive, typically do just in case we need to partially apply them map and so on.
1:19:08
So we tend to write like that. Now here is an identity I never have to go into default on, but here is an identifier.
1:19:13
All right. Oh, come on, that's it, right, there is an identifier.
1:19:28
And when you look at that idea, and that is a single identifier, so when you look at that,
1:19:37
it's very easy to read that as the application of F to X and Y and Z, isn't it?
1:19:41
So the fact the underscore sits so low in most typed ones, your eye tends to see a space rather than the underscore and the Haskell is cariddi.
1:19:47
We know that a space means function applications is an extremely dangerous thing.
1:19:57
I think having something that could be mistaken for a space.
1:20:01
So that's I don't know for sure, but I suspect this is the reason why Haskell encourages us to use cavalcades rather than
1:20:05
other schools in order to separate just the word identifiers consisting of multiple words.
1:20:12
So can in this case would be a bit tough, wouldn't it, smaller capital X, capital, Y, capital, maybe exploits, you know?
1:20:18
Yeah, but that's that's the we and I have seen price. So once saw a programme, the student had written an identifier, something like that.
1:20:27
And then I think there was something like this, but in fact, it was much worse than this,
1:20:35
and I was starting this programme for ages trying to debug it. I think it was one of the general solutions.
1:20:43
So we had an idea to follow that and then had the audacity to apply that function to it.
1:20:48
Right. If you look at that and tell me what you see, I see F of X, Y, Z,
1:20:55
and then if I actually spot the underscores, I say, OK, now where do underscore Spanish?
1:21:01
Where is the where's the true space? Where's the function application that so don't use underscores and not in a high school programme.
1:21:06
Russia I suspect that's a Thamesdown, but I think that's a fresh one.
1:21:14
Well, actually, I meant to ask one more thing if it is.
1:21:18
Could you explain the show driving Escutia? Well, what is sure exactly?
1:21:23
Yeah, I'll come to that they with me, dummy. Oh, my question was just if you can't use underscores the hyphens acceptable,
1:21:29
you can't use hyphens because a little thing that's a subtraction of effort to extract from OK.
1:21:37
All right. Now, you don't you don't use these camel.
1:21:43
What do I mean by camel case in case you don't know. Oh, is that so bloody, Nancy?
1:21:48
Oh, I can't think of a horse when I'm doing high school.
1:21:56
I, um. I think I'm quite short, but, um, let's see.
1:22:01
So something like this, you know, is a Capitola. There's a there's word magpantay up to the word so.
1:22:06
Um, I put the two together with an uppercase, so don't do that, don't do that.
1:22:13
Right, I'm going to break for a second.
1:22:20
It's just it's just you can freshen up a bit, so we'll come back and say two minutes about that and then we'll finish it 10 to.
1:22:21
Sir, I think your muted. Thank you, can you hear me now?
1:25:09
Yep, yes, yep, yep, OK, good, yeah, so I haven't said I hadn't thought of that work.
1:25:17
I just saying, are there any questions on the on that instant declaration?
1:25:25
Because quite a lot going on that particularly when you see this precursor in here.
1:25:28
And it's just it's beautiful the way it sort of pans out. Good.
1:25:32
So I think it's the case that you. Well, I don't think I've set a January test where you've had to create your own instance of a class.
1:25:39
But certainly in the lab exercise this week, there's an invitation to do some work that I think will probably cover that tomorrow morning.
1:25:48
Now, I think I probably let you go in a few minutes time, but let's let's carry on and finish up to that point.
1:25:56
Right. So somebody asked about the show class because I showed you an example of the last thing in there which was driving the show thing.
1:26:02
I told you what it is yet. Well, the show class so, so equal.
1:26:09
If a type is an instance, A, B, Q, it means that you can compare objects of that type using a quality if it's a member of or you
1:26:15
can use the inequality's and if its members show it means that you know how to print it.
1:26:23
So the show class essentially introduces all types that are Schobel.
1:26:27
That's a principle.
1:26:31
So if I give you an object of that, if I give you an object of that type of that type is a member of the class, then we know how to display it.
1:26:32
And that's what ghc actually I need in order to print things on from the prompt.
1:26:40
For example, when I say eight it says, oh I know what this, that's eight.
1:26:46
And the reason it knows how the print is because whatever the type of it is intrinsic,
1:26:51
it knows that there is a show function called Little Show for that thing which produces the principle representation about.
1:26:56
So in order for GHC to display values that were specified type, we must have a definition of this little show function,
1:27:04
a little bit less function, call a little show as opposed to a picture which is the name of the type class.
1:27:12
So can I show the null constructor.
1:27:17
And at the moment, I can, because I've got to show, OK, but let me just go up here and take this out without the show instanced.
1:27:21
Without the show instance, it would have checked and it would come up with some measures.
1:27:36
In fact, the message I noticed when I was looking at the slides some earlier this afternoon,
1:27:39
a slightly different error messages are slightly different to what what we had.
1:27:44
On the slides, and that's because I have not been disclosed for a couple of years.
1:27:50
I need to do that. So if you want to see it in full blown, that's what it says.
1:27:54
It says, well, you've asked me to show Knill. You've asked me to produce the printable representation.
1:27:58
And if I could ask the same question to you, I can say that and essentially says the same thing.
1:28:03
Well, I don't know how to print, Neal, because you haven't told me and I'm not going to guess anyway.
1:28:08
So coming back to the slides. Coming back to the slides, yes, there's little show function produces the principal representation of an object,
1:28:16
but it can only do so if the object type is an instance of the show. So, of course, it's and integers and doubles and so on.
1:28:30
These all have printable representations, which means that they are the instances of the show class.
1:28:36
So as I said, what was the example?
1:28:42
There were eight. I wasn't it. So that gets printed as eight by GHC.
1:28:46
But what the reason why it's bigger is because the eye is invoking show on that object,
1:28:52
producing that string and then GHC basically takes away looks at the contents of that string and prints out the individual components.
1:28:59
So if I have a multi digit number like that, of course Haskell will print that.
1:29:06
And if I ask you to show that Haskell will tell me the printable representation of that number,
1:29:12
which is the string consisting of the characters one and two and three and four,
1:29:17
one after the other, and it's the contents of the string, the one, two, three, or they get printed up here when I do something like that.
1:29:22
OK, so what about strengths? What about other things? Well, let's have a look at another example.
1:29:33
How if I give you the count A, it comes back and says the right.
1:29:39
Well, that means that the principal representation should have a single quote and then by then a single quote.
1:29:43
So and that's what I guess if I say what is the what do I get for sure?
1:29:50
Oh, the character. I said, sure enough, it's a string consisting of the single quote,
1:29:54
out the eye and then the single quote, which is exactly what gets printed up there and anything.
1:30:00
Oh, OK, I get that. What about strings. Well if I give you a string can spell.
1:30:04
It could be a string. It comes back and says String, unsurprisingly. So what is the principle representation of string?
1:30:14
Well, it should be a string whose first character is a double quote and then goes string and then double chords.
1:30:21
So what does that look like? Well, if I want a character inside a string, I have to put this escape character in.
1:30:29
Otherwise, if I left this if I left this out and wrote something like that,
1:30:37
then that would be that would go horribly wrong because this would be an empty string.
1:30:42
This would be something Haskell doesn't know about. And he thinks I'm trying to apply that to the empty string, by the way.
1:30:47
And then another empty string here. So it's just completely broken.
1:30:52
So in order to make it clear, you can put these escape characters in which says, no, no, I do mean the character.
1:30:55
I do mean the double character. And outpost that some other scout characters you probably know and love are new line and tab.
1:31:01
What else might you've come across? Oh, there's also you can escape to get Unicode characters and so on.
1:31:11
So some of the some of these may be use of, you know, we'll have this week.
1:31:17
I don't know. Right. So back to the slides.
1:31:22
So that's why when you say they show that you get a string which has got the double Khachaturian plus.
1:31:26
All right, so if a title he's not a member, the show function, we can't display objects of type.
1:31:35
See this, by the way, this always amused me because this was the this was the error message that she used to produce.
1:31:39
So if I go if I do this, by the way, is a constructor my day data type, wasn't it?
1:31:46
If I just type this in producing an a bit like this, but I cannot find the shell function for and it would tell you the expression,
1:31:50
but in imprinting the expression, it actually produces the very string I wanted it to be, which is capitalism.
1:31:57
OK, so given that it can produce the string in an error message, why couldn't it produce a string?
1:32:05
Well, the answer is, of course, because it can't be sure.
1:32:09
Oh, because I didn't tell it. It can't assume that I won't know when printed as the different.
1:32:12
No, so here's how we can fix it. This is a driving statement, and if I didn't want to have a driving statement, then I guess I could alternatively.
1:32:20
So the right the just the right show, by the way, produced the obvious thing, little bit print,
1:32:32
the constructor's exactly as they represented in the programme when T and so on.
1:32:37
So for example, if I do that and I type that and when that comes the name of the constructor as a
1:32:43
string and of course I got a pair of days and it will print that in the usual way.
1:32:50
Oh yes. That is, there must be a show function for pairs of things and indeed there is more time to see that in just a minute.
1:32:57
Right. So I guess if I want in my own instance for sure. Oh, perhaps because I wanted some other behaviour.
1:33:06
So I guess I could start typing something and say, instance, show me the show and I can see where o day where.
1:33:14
Oh for goodness sake and where.
1:33:26
And I could say something like well oh to show Monday I want to show it is Monday.
1:33:31
Yeah, well this is exactly the definition that Haskell will synthesise for you if this is what you want.
1:33:37
So you wouldn't do it yourself. Tuesday is the string t, u, v and so on and so on down the road, right.
1:33:42
And it may be that's what I want. So in fact, if I wanted to display it differently, I couldn't use them either.
1:33:55
If I wanted them displayed in full strength and they weren't being replaced by Monday and you think to Tuesday and Wednesday and so on.
1:34:02
And I wouldn't use this because I don't get the mapping I want. So I would just use the this an instant declaration like that.
1:34:10
So coming back to my code, I guess I just say I can print these anyway.
1:34:18
And this actually is something you may well find useful this week.
1:34:22
I'm not sure. Do you need to use the you need to create your own instance?
1:34:26
Yes, I think you do, because you've got to be able to print expressions this week. So you probably want something like that, Addae.
1:34:32
Yeah, is it possible to, like, kind of define your own show function for some values and then have the default,
1:34:43
like from deriving other values if you get one?
1:34:50
I think the question is, if I got some type here and then I've got some something in here.
1:34:55
So there may be a constructor in my type with some arguments.
1:35:03
Well, I think this is what you mean. I don't know. But I can I can choose to display X, Y and Z any way I want.
1:35:09
So it could be that I want to use the default. I may require them to be shareable, there be some context, but if this was an INT, for example,
1:35:17
I might want to show and in that context, differently to the way GHC would normally show any.
1:35:29
Yes, maybe I want to angle brackets around or something, so sure, I can do that by changing the right hand side.
1:35:35
What I meant was like to say with the data, like, say, I wanted to show Monday as like Monday fully still out,
1:35:42
but I want to show all the other ones, like I went straight to this t.
1:35:49
Oh, I see. Yeah. So you're saying so let's go back to the date one.
1:35:53
So we've got a day here today to date something. I've got something like Monday, so I want that one that way and I want the others.
1:35:58
Yeah, you see, once I started, I can't sort of say, oh well now I want the others to be some sort of default.
1:36:10
Do you want to default back to the other show? Yes. No. Okay, fine.
1:36:19
All right. Yeah. You can't do that. I'm just thinking there's a clever way to do. I don't think there is.
1:36:24
No, because you're basically what you're doing is you're you're overwriting your overriding the show function definition.
1:36:31
Well, there isn't one. There is the deeper one that I once you started.
1:36:37
You can't stop. And you can't do both, so you can't drive, show and then create an instance of an object.
1:36:41
Right, good. So that's that.
1:36:49
Yes. So this is quite nice, because if you got any data type whose components are the constructors of a day,
1:36:55
then it will print the constructors the way you want them. So. All right.
1:37:00
One more thing and then all of them will stop. So two things, actually.
1:37:05
So we may have multiple constraints. If you look at this function here, this is a two argument function.
1:37:09
We see that the X and Y here are being compared to using an inequality.
1:37:14
Therefore, we know the type of X and Y must be members of the old class. And lo and behold, we're also showing them.
1:37:19
So if that condition is true, we show the X, otherwise we show the what.
1:37:25
So but the type of the X in the Y, they must both be members of the old class and they must be members of the class.
1:37:28
So if I type this function in and see what it thinks the IP is, or if I were to add my own type signature, then it would look like this.
1:37:37
So you see the context here. It actually has a pair of constraints of such a pair of constraints.
1:37:44
So they must remember what a must also be, in which case then the function is a two way street.
1:37:51
So I think all of them might have asked this question earlier on today. Good.
1:37:57
Right. So finally, for today, they're not going to stop. We've already seen from the example that the pair type T come on you there's already an
1:38:04
instance of the class because I know let's just let's just concentrate on the working class.
1:38:14
I know I can do something like this, something like this.
1:38:20
Right now there is a perfectly valid comparison. So therefore I know that pairs of things must already be and a member of the class.
1:38:26
So that's how we might set that up. Lots of ways to define that function.
1:38:35
So I can say Cresco is an instance for the EKI class for the pair to you.
1:38:39
And in order to do that, we need T and you also to be members of the Class Y, because if I ask whether a pair AB is equal to the pair said,
1:38:47
the only way I can find out is to compare the with the C and B with the D so I could write this a different way.
1:38:59
I could say that for these two things to be the same,
1:39:06
I guess I could say something like on the right hand side to the I could say that aim must be equal to C and B must be equal today.
1:39:09
So that's a rather nice way of pointing it. There's nothing wrong with the slide but just using a condition.
1:39:23
Yeah, so I think I'm the right hand. I would certainly use the the conjunction that I've just shown you.
1:39:32
Right. So that's fine. And. And then you think, well, wait a minute, what about triples, so, well, let's see, can we can we compare apples of things?
1:39:37
And you think, well, some of you may already have had to do this, so there's a trickle of numbers.
1:39:50
Well, actually, let's get a true one, two, three again and again.
1:39:58
True. And you think, well, what about Portugal's?
1:40:02
So, yes, someone has gone through and lovingly produced this type of definition for triples and quadruples, presumably.
1:40:06
Let's just check. Yeah. And you think, well, I wonder if it did it for five tuples.
1:40:16
So you think, well, let's try this and. Well, what about six or seven, Chiba's?
1:40:23
Surely, surely nobody would ever be able to 10 people surely.
1:40:30
Well, let's see, let's see what the design is. The language thought it might be useful.
1:40:35
To compare 10 stupples yup. OK, well, OK, let's keep going, let's try 11 tuples, 12, 13 tuples, 14 tuples.
1:40:41
Let's come back and do that 11, 12, 13, 13, 14 tuples, surely?
1:40:54
No, not yet. So obviously they thought, well, someone seems to know someone's going to need a 14 tuple.
1:41:01
What about 15 Schubel C surely not 15.
1:41:08
If you show me a programmable 15 sheeple, I'll show you a programme that needs fixing.
1:41:14
But OK, oh, I see, I talked to the five. It doesn't matter how good this can indeed compare 15 she was,
1:41:19
what about 16 pupils know someone very patiently inserted all these lines of code into the GHC prelude in order to get this dope.
1:41:25
And you say finally they run out of steam and thought, no, know again with a 16 tupman,
1:41:38
it is probably badly broken and you should refactor the pregnancy then. But the largest chip I think I've ever seen was 9/11.
1:41:44
Schubel And that was when a compiler for a function like which when I was a student I didn't want it dummy.
1:41:50
Is that the team's hand. I know I have a question, is it possible to implement that recursively?
1:41:58
Oh, good question. No, because there isn't a constructive stupples, so I wouldn't know how to write a left hand side.
1:42:06
It's for the same reason that I can't write the first function works on just Pear's, and it wouldn't I wouldn't know how to.
1:42:15
You can't write a function that we work on arbitrary tuples because there's no constructor to play with.
1:42:23
Otherwise it could be. No, that's wrong. Yeah, there are sort of metaprogramming, tricks that you might want to throw in Vanilla Haskell.
1:42:29
No, it's it's just it's just just it wouldn't you couldn't you couldn't watch a programme with the right type.
1:42:39
Good, that's enough for today.
1:42:47
I'm going to finish off tomorrow, this section on tight classes with some stuff that you will most almost certainly need in this week's exercise.
1:42:49
There's plenty to be getting on with, so I'm not holding up.
1:42:58
But this is a beautiful little optimisation you can do to your evaluator and indeed your differentiation tool like brawn can use type classes.
1:43:01
So that will come tomorrow. So we'll see you then. QRIO.
1:43:10
Thank you. Thank you. Thank you.
1:43:17
You're welcome. Give. They.
1:43:21