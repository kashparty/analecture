ID: 57d222d6-584f-481e-8193-ae2300dc2689
Title: Java - 2022-01-20
Category: Java
Lecturer: Alastair Donaldson
Date: 20/01/2022
So, yeah, that's what I would consider those.
0:05
Senior researcher that. And the funny thing is, I it's so odd.
0:33
OK, I think we're good to go. Nice to see you.
0:51
Thanks very much for coming along in person today for those of you here and hi to all of those of you online.
0:53
Can I just get an acknowledgement that those who go online can hear me and see?
0:59
Someone could just go we can hey, thank you very much.
1:07
All right, so what we did last time was we started on the material related to streams and lambdas,
1:10
and I was quite worried I wouldn't get through it by the end of the week because I got it into my head on Tuesday that it was the end of the week.
1:17
So apologies for that. I think it's because I gave you that first, that first session in week one, so it was our second session.
1:24
So in my mind, that meant it was the end of a week, but in fact, it was midweek, so we didn't find for time.
1:31
So what I'd like to do today is finish the material about streams and lambdas, which allows you to do style of functional programming in Java.
1:36
And then I want to go back to basics a bit and talk about references and classes and primitive types in Java.
1:45
Just make sure that those fundamentals are hammered home.
1:53
OK, and then we may have time to get started on the next topic, which is inheritance, so we'll see how we do.
1:57
As usual, please feel free to shout out questions if you're on Zoom and continue the great questions in the class as well.
2:03
So what we looked at last time was how we could go from a collection of data like a set of data or a list of data to a stream.
2:12
And the point of streams in Java is that once you have a stream,
2:21
you can do various functional operations on the stream and the key functional operations that we typically do on mapping.
2:25
So converting a stream of data from one form to another, potentially preserving its type,
2:33
or maybe going through a different type filtering to get rid of things from the stream
2:39
that we're not interested in and reducing so turning the stream into a single value.
2:43
And we covered mapping last time and we got started on filtering.
2:50
So I'm going to go over filtering again and then we will have a look at reducing as well.
2:53
OK, so filtering a stream filtering involves saying I would like a news stream,
2:59
the only has things from the input stream that satisfy a certain property I care about, and that property is represented by a predicate.
3:05
A predicate is a mapping from a particular type to bool.
3:14
And for every value of the given type, the predicate says true or false, saying Are we or are we not interested in this value?
3:19
So the filter method of stream takes a predicate method is an argument,
3:27
and that method can either be provided as a method reference using the colon colon syntax that we study last time, or it can be provided as a lambda.
3:33
So we could use the variable name arrow expression syntax and then the expression would be a Boolean expression if we have a predicate.
3:42
OK, and it returns a stream containing only those elements that do satisfy the particular predicate.
3:52
So I showed you this example of filtering out offensive words here, right where we got a filter.
3:58
Bad words function takes a list of strings and it takes a set of bad words.
4:02
And what it's going to return is a list that's a sub list of the input.
4:09
That's not going to contain any of the words that were in the bad words set.
4:14
And the way this is achieved here is from the last words, we get a stream by calling the stream method,
4:18
then we call the filter function of that stream and we pass into either a lambda or a method reference.
4:26
And because there isn't some function that's available to do bad word filtering, there's not an available predicate function.
4:33
I've used a lambda here,
4:39
so I've got a function that takes an item which will have Typekit string and that gets inferred automatically by the Java compiler because
4:40
we've got a stream of strings on it returns a Boolean and the Boolean would be true if only if the string item is not in the set bad words.
4:50
And then we want to return a list again, so we have to collect the stream back into the list.
5:01
We use the collect function for that and we use the to list collector.
5:06
OK. I remember the kind of analogy I gave you of a stream or the mental model, maybe is to think about these,
5:10
these operators that map and filter as being components in a production line.
5:18
So there's a stream of things. Moving on to the conveyor belt and a map operation is like going to change one of these things from one woman
5:24
to another and a filter operation is potentially going to pull some of them off the conveyor belt completely.
5:32
And the crew collecting is being kind of the end of the conveyor belt.
5:37
There's someone who's going to grab all the things and put them in order and a list, or just chuck them into a box if they respect that.
5:41
So that's maybe the mental model you might like to think of.
5:48
OK, so this is a lambda, and you would you would get this message printed like I went over last time.
5:51
OK, so let's do an example of filtering using a method reference.
5:58
So this is partly to show you again how to use method references, apparently to to make a point I made in our first lecture once again.
6:03
So using a method referenced here, we've got a method called filter false strings.
6:12
It's going to take a list of strings. And what it's going to do is stream them.
6:19
And then filter them using the value of method from the Boolean class as a predicate.
6:25
So a couple of things to note here. Recall that for primitive types int boolean float, we use lowercase letters for every primitive type.
6:32
There was a corresponding wrapper type. So in the case of Boolean true false values,
6:44
there's a class called Boolean with a Capital B and a Boolean with a capital B is
6:49
a little object that has one feels that is of type Boolean with a lowercase B,
6:55
and we call this a wrapper for the primitive type Boolean.
7:01
And as I mentioned briefly last time,
7:06
the purpose of these wrappers is so that we can use primitive types in cases where we're only allowed to use objects, for example, in Java.
7:07
A list can only be a list of objects, so you can't have a list of it the primitive type, but you can have a list of integer type.
7:18
So this class Boolean has got a number of convenience methods, and one of those methods is American value.
7:30
Of the value of that is it takes a string and it returns true or false, depending on whether that string represents the Boolean true or false.
7:35
So what we're going to do is filter the input strings and keep only those ones that evaluate to what when we kind of into oblivion.
7:46
True, true. Very good. OK, so value of is going to return a Boolean.
7:58
And we're filtering with respect to whatever Boolean it returns. All right.
8:04
So we're going to keep all the strings that turn into true when we make the movies.
8:07
So here's a little main method called filter false strings.
8:12
So we've got a list of the strings. True. False, true.
8:17
False. One, zero and cat. OK. So my question to you is, what is this main going to print?
8:22
So it's going to keep all of those strings that evaluate to true when you interpret them as Boolean just.
8:31
So it could that could be all kinds of answers to the question. So you think what would your prediction be?
8:45
Just a little history. OK. It's good to be true to anyone.
8:52
Could it be true, Truman? So maybe, maybe it's case insensitive and maybe one we sometimes think of as the truth value and Boolean logic.
8:58
Could it be all of them evaluating true, just the empty string value database of questions going on here,
9:09
which I'm delighted about because I love questions,
9:15
but the question in the letter to was, could it be that some of these will be invalid to turn into a brewery and maybe without exception, be thrown?
9:17
So yes, that's indeed a very legitimate thing to wonder. I'm sorry.
9:22
Can you repeat the question from a name, please? Could it be all of them evaluate to true and only the empty string?
9:26
Yeah, that also seems sort of reasonable to. Right? So I can't remember what's going to happen when I click OK, and why can't I remember?
9:34
Criticism of arbitrary right, but there is a rule. But why are they not learn the rule?
9:46
Year, not just because I could just look it up.
9:53
I could just pick it up. I could look up anything. And I want to be an official programme. I said, I want to look everything right.
9:56
So yes, I could look it up if I needed to. Like, you'd written some code using this,
10:01
I could look up to somebody who means you remember a point I made you in the first lecture about learning languages encyclopaedic.
10:05
Right. So we don't want to write everything about the job transfer, because that's definitely a good point.
10:17
But if I did know this, then I may be tempted to use this kind of thing, my programmes.
10:22
And then that would be terrible for all of you. OK. So really, she probably shouldn't be toning strings in the billions,
10:27
and there's some very special reason you'd want to and you maybe don't want your
10:34
programme to rely on this very little known feature of the Java programming language.
10:38
So it would be best just never to use this feature. And therefore don't bother learning it because you don't learn it, you're less likely to use it.
10:43
OK, so sometimes the language is I mean, if you build a compiler or compiler, right?
10:49
So and I'm kind of into that business, then you really do need to learn everything about the language,
10:54
at least when you're building the bits of the compiler that is going to compile that bit of the
10:57
language because people do ultimately need a compiler that obeys the language specification.
11:01
When you're a programmer, maybe you don't learn all of the kind of crazy little features of the language because
11:06
you might be tempted to show off and use them in your code and make code that later,
11:10
you won't be able to understand because you won't remember or other people you working with.
11:14
Will, you know, maybe you leave the company, maybe you die, and then people are trying to look at your code and have no idea what it does anyway.
11:18
I think it does. True and true.
11:25
And yes, I was correct. OK, so I did sort of the right.
11:29
So it turns out that making a billion from anything that I believe, by the way, you can make any of these characters capital.
11:32
So it's like it converts it to lowercase and then says, Is it any of the string?
11:39
What if I give it to false? A more important point than the encyclopaedic thing I mentioned is it's very common in dynamically
11:44
typed languages like JavaScript or Ruby or Python for these language to be extremely permissive.
11:51
Often, it's the case that almost any string can be used as an integer,
11:57
and some crazy interpretation will happen and you should just try and never do that yourself.
12:01
And if you're looking at code that does it, try and really make sure you understand what's going on there,
12:07
because often these things can be very counterintuitive. OK.
12:11
I think things like integer one plus the string containing one becomes 11.
12:15
That kind of thing. OK. Is there a reason you've done that is not as list instead of doing something like this start off?
12:19
Yeah, so here we could use. No, there's not. There's not a good reason for that.
12:27
Erase the list is calling a static method of erase costs as list,
12:30
and there's a more modern method list dog so that the list interface has got a static method called all of that will
12:36
give you a list with the same advice that I don't know if they're entirely equivalent in the way they implemented,
12:44
but functioning their equivalent. Yes, please. No, this. Is an immutable list.
12:50
Yeah. OK. Right, so if you did list of and then try to add something to it, you'd get exemption, right?
13:00
Thank you. Yes, please. Interface.
13:07
Yeah. So a list is an interface.
13:21
So list of is going to return you an object of some class that implements that interface.
13:26
And you don't know it, right? And the idea is, you shouldn't really need to know you shouldn't depend on which one, if you need it,
13:35
as if you really needed a linked list you shouldn't use list of you should make a new list and add the elements you want to that list.
13:42
And then, you know, if you just need some list and you don't care what you don't really care about,
13:49
the performance properties is maybe just going to contain a few items you use list of all,
13:54
but all you need to know is, as your colleague said, whether or not this list is going to be immutable or mutable, right?
13:57
I tend to assume my default is whenever I use these convenient things.
14:04
I always assumed the thing is immutable. I'm not allowed to add things to it.
14:08
If I want to make a list and put more things in it, I tend to make my own list of things explicitly.
14:11
Yeah. I mean, I would expect what would happen here, but I you could you could check this.
14:16
I expect what will happen here is that a the list would return on ArrayList would be my
14:24
expectation and I would expect that from what from what you just said about this stuff,
14:30
I would expect list of would return on ArrayList wrapped inside what's put on modifiable list.
14:34
That's a closet job advocate on modifiable list, which is a wrapper for a list of what it does is there is an exception if you try and modify it.
14:40
Otherwise, it calls the methods of the list that it wraps. But what?
14:47
Maybe we could come back some of these questions when we have a composition of objects and if you like to type.
14:52
Oh, I see this. That's a great question. So here a raise is a cost its face.
15:01
So as this is a static method of might cost list of is an example where the interface list has got a static methods in it.
15:06
And I briefly mentioned this last time when I said to you last time that interfaces only contained method signatures.
15:16
Nothing else. You might recall this, and that's not actually true. There are some.
15:21
They can contain static methods because a static method is just a standalone method that doesn't have to be called on any object,
15:26
and it needs to live somewhere. And in Java, the the convention is things always live inside classes or interfaces.
15:32
So a static method could be in any class and could be in any interface. It's got nothing to do with if you implement the interface.
15:39
The static methods of the interface have nothing to do with the obligations you have as an implementer.
15:46
So in our page element things last time we could have added a static method called Foo and then menu, text box and image.
15:51
They wouldn't have needed to have done anything with respect to food because it makes sense. Good questions.
15:58
All right. So filtering using a method reference.
16:05
Digits. All right, so say we had a list of characters and we would like to keep all of the characters digits.
16:11
Then what we could do is we could stream the characters to get a stream of
16:18
characters and we could filter using the digits method from the character class.
16:22
All right, so character is Rapa for Char in Java, and it's got a method.
16:28
Code is digit and we can use that as a predicate to only keep the only keep the characters the digits and then we use collect.
16:34
So this back into the. So if you do A-Z one two percent ninety, we hope to just get one to nine, which is another example of using a method reference.
16:45
OK. Let's talk now about reductions.
16:58
I mean, that filter is pretty straightforward, but nevertheless, Eddie, the questions about filtering.
17:02
OK, so let's talk about reductions. Suppose we want to sum up a stream of numbers to make a single number.
17:08
That's an example of a reduction operation. OK.
17:15
And it's very much related to fold operations.
17:19
You've started in high school ten fold left and fold right. So that's an example of a reduction operation.
17:22
Would you sing the string of strings to a single?
17:27
No, sorry. Reducing the stream of integers to a single integer? This is that song.
17:32
This is not so common in practise is actually very common to want to add up numbers.
17:37
If you do a dot product operation on vectors, for example, you would add them all up and then multiply them.
17:40
It's not so common to want to multiply together the numbers, but nevertheless you might want it.
17:45
That would be another example of a reduction might be that you would like to get the shortest strings in a stream of strings to get a single string.
17:49
OK. Or you might want to concatenate together all the strings in a stream of strings to get a single string.
18:02
That is that concatenation.
18:08
So it's pretty common to want to do something where we combine all the elements of a collection together in some way to get a single element.
18:10
But we'd like that to be programmable. We'd like to be able to specify what the combination is.
18:18
How these things get combined and reductions. What allow us to achieve this.
18:23
So the tree reduction is a well-known time in computer science and programming,
18:28
and Java actually has a reduced method on streams that you implement your own reductions.
18:32
OK, so we don't need streams to do reductions, of course.
18:39
Here's a way of doing a multiplicative reduction on a list. So I've got here is a list of integers or factors.
18:42
And if I want to compute that product, but I could start with one and I could go to all of the factors for every factor s,
18:49
I could multiply my result by F and when I return, the number I return is going to be the product of all of those factors.
18:57
So this is very straightforward for looping through every integer in the list factors.
19:04
So the initial value here is the multiplicative identity one.
19:14
One is the identity for multiplication, because one times X equals x x times one is equal to X.
19:20
It does nothing to X when you use the multiply operation. OK, and here we would call this times equal.
19:27
So this is like the same as writing results equals results times F, but it's slightly more concise by writing it.
19:35
This is called the accumulator operation, where accumulating the items by multiplication.
19:41
So we start with an identity. And we repeatedly accumulate until we get a final result.
19:45
Is an example of string concatenation, so the pattern is the same.
19:52
We're going to iterate through all of the strings in our collection.
19:56
We're going to start with some suitable initial value. And if we want to concatenate strings,
20:00
then we would say that the concatenation of no strings is the empty string and then
20:05
our accumulator operator would be this contact operation results plus equal s,
20:10
which you could equivalently write as a result equals result plus s.
20:15
So the identity here is the empty string and the accumulator function is this concatenation operation.
20:20
OK. So by the way, I apologise for this Zim bar on the top.
20:29
I'm using Linux and it seems that Linux is a bit less featured resume than some of the platforms,
20:34
and it seems that there's not a way of getting rid of this on the site for a different course,
20:38
I'm using a Mac, which I'd rather not use because I didn't like that course.
20:42
There are reasons that I do that I do. I do some music stuff and I love Mac for music.
20:48
It's great for music, but I had to actually getting stuff done.
20:52
Terrible. OK, so what are reductionist having comment?
20:56
Well, there is always an accumulator function that's used to combine elements of the collection being reduced.
21:00
So for the product, it would be times for the category strings, it would be plus.
21:08
And in general, the accumulator function needs to be associative. So what we mean by associative is that bracketing doesn't matter.
21:14
You can bracket the application of this function in any way and you get the same results.
21:21
So, for example, the definition is that if you if is the accumulates function, then f of X and Y.
21:26
With then applied to it with Z will give the same result as, first of all, applying X,
21:35
Y and Z and then applying F to X and the result we got from applying F to Y and Z.
21:40
So this property is court associated pretty. So give me a give an example of an arithmetic operator.
21:46
That's associative. Plus, and one that's not associated minus, OK, very good.
21:50
So then every element has to have an identity on which accumulation has no effect.
21:56
OK. So for the mathematicians amongst you, what kind of structure do we have here?
22:02
Algebraic structures we have here where we've got a binary operator associative.
22:10
We have an identity. Yep.
22:17
It's not a group. OK, but it's nearly a group, it's like a stunted group.
22:22
So what is it? What does a group have that's missing here? That's an obedient group.
22:27
So groups have inverse groups have the ability to invite. So here, I'm not saying that the function of the accumulator needs to be inevitable.
22:38
And if you if you think about it, we don't have inverse ability for integer multiplication.
22:45
Yeah. So you can't always. We don't always have anyone that's going to have what you call this, yes,
22:52
this is a this is it is a savvy group, right in the same way that it's also a set.
23:00
So it's more than this emigrates between this group and group. Hemy said the group was picked, it was between a semi group, a group.
23:07
It's not wrong, but I'm pleased that you know about all these.
23:18
It's going to be annoyed. Just a little fact. Right?
23:22
So the computer, yeah, I'm annoyed, is a semi group that has an identity and a savvy group.
23:26
You've got biter operator and it's associative and then a group is old as well as the identity.
23:33
It's also inevitable. So, yeah, just in case you're interested in and out of it,
23:40
maybe that would be a useful thing to remember as a way to remember what these reduction operation operators do.
23:44
OK, so that's the reason that we use one as our identity for four concatenation strings.
23:51
The empty string was our identity, and yeah, we've got to have this property for the identity and our accumulator.
23:56
If we apply the accumulator to some Element X with the identity on either side,
24:03
then we should get back X to the identity should have no effect when we use it with the accumulator.
24:09
And that's definitely the true true one with multiplication and of empty string with string concatenation can sense.
24:14
OK. Of the result have to be the same as the site of each of the L.A. street or could they be different?
24:24
The result is got to be the type of each of the elements in the range. This is less powerful than some operators you have seen in Haskell.
24:33
This is where you turn a stream of Taipei into an element of Taipei.
24:39
Which is normally sufficient, but sometimes it can be kind of annoying,
24:46
you might want to turn it into something you might want to accumulate things into.
24:49
Another sort of type, you can't do that with a job for reduction.
24:55
OK, so stream the interface stream has got a reduced method, and that method takes two arguments.
25:00
And guess where they are?
25:06
While an identity of the given type and an accumulated operation, which is a function, you pass it in either as a lambda or method reference.
25:07
And it's up to you, the programmer, to make sure that what you pass is the identity really is the identity for the
25:16
data type you are talking about with respect to the accumulator operation.
25:22
So you can pass whatever value you want is the identity you can pass, whatever function you want as the accumulator and the reduction will proceed.
25:26
And if you pass garbage in garbage out, that's quite often the case with computer programming, as we'll see later in the course.
25:34
There are various other things in Java where the language, if you read the documentation,
25:40
says to use this method, you should ensure the following things if you don't.
25:44
Results will be unexpected. That's pretty, pretty standard.
25:50
It would be really nice if we could have compilers and type checkers to automatically show as what we've got all these things wrong,
25:55
but that's often not possible. OK. So as I said, the accumulator can be a method reference or can be alarmed.
26:01
So let's do a couple of examples of reducing the extremes.
26:08
If you'd like to concatenate strings together,
26:13
then what we do is we stream our list of strings and then we reduce with the empty string as our identity.
26:16
And with the contacts method, which is the method of the string class as accumulator.
26:25
So I think maybe I when I briefly go to the idea just to drill into this a bit more and remind you of a few things we mentioned last time.
26:31
OK. So I'm going to. Code this up here, I'll say.
26:39
CONCATENATE. This is going to take less of string.
26:48
And. Yeah, well, I'm going to do is I'm going to see retired strings stream.
26:56
Congrats. Sorry, not knocking. That's what we're trying to achieve that reduce.
27:04
OK. And empty string is my identity and string can count as my accumulator.
27:09
And then I would collect this. Oh, sorry.
27:18
I don't collect it, right? Why don't I collect it? Because it's already a single value.
27:25
The whole point of reduction is that we're taking our stream and we're turning into a single value.
27:33
So Reduce gives us a value of the streams data type.
27:38
So we don't collect it. Got it out of the ditch side. OK.
27:44
So what I want is just, let's just get this into action.
27:49
So I could say system so. Footprint, Ellen.
27:52
CONCATENATE. List of.
27:59
ABC the. If we run that, we should see the single string ABCD differences.
28:08
OK, fine. So I wanted to remind you of was how we use method references.
28:21
So let's have a look at this thing contact method. So what it does is it takes in a string.
28:26
And turns a string, so cats is actually not a static method, is an instance method that you call on a string.
28:37
You say a dot contact B and what you get back is a string that is the concatenation of A and B strings in Java immutable.
28:47
So this doesn't change. It doesn't concatenate B onto the end of a gives you back a new string is the concatenation of those two strings.
28:57
OK, so here we're using that trick trick, but ID. I showed you last time where we're passing an instance method as a method reference.
29:05
So what do we need for reduce? We needed.
29:16
Something that takes two strings and gives me back a string.
29:22
That's what we needed for our accumulator. And it may look as if I've provided here is something that takes one string and gives back a string.
29:27
But remember that this method always needs to be cold on an object.
29:37
There's always a receiving object, and we can think of that receiving objects being the first parameter.
29:41
So the method we use as a method reference. So when I do this, 'cause it's like I said.
29:47
A bee goes to a local cat bee.
29:56
Right. So it's the same as if I'd done that MBA strings on the logistics two strings A and B, and it returns a dot com Kathy.
30:03
But a more elegant way to write this is to use the method references that.
30:13
Yes, please. Is it? So why do you think it might not be straightforward to use them in our maximum?
30:20
Yes, it will come to reductions, but I think he's in a moment. OK. But why don't we briefly do something the him?
30:36
We look at a couple of ways we could do that, right? So let's say and find men, which is going to take a list of integer.
30:43
Integers. All right, in a minute, maybe we would like to say.
30:53
What is the men? One, three, minus five.
31:02
Twenty six, one hundred say, OK, so what we could do here is we could say return integers stream or reduce and say we foolishly thought,
31:16
Well, maybe the identity for men is going to be zero. OK, this is wrong then.
31:29
We could pass in Lambda. Abe goes to a philosophy.
31:37
So what this is going to do is,
31:44
say initially we're going to say that the results of our reduction is zero and then if we find anything sorry, I should have done.
31:45
I thought men. A year, I would it to the minimum, so if I find anything smaller than zero, that becomes the new value of my reduction.
31:54
So if we do this, then it's going to give us. I like to fight, but obviously is wrong in general.
32:03
Right, so if we. Do five here, then we're going to get.
32:10
The value zero, which is not what we want it, right?
32:17
I think making the point that there's not a kind of obvious identity we'd like for men because men works of any kind of integers.
32:19
And what we did is to be able in Java where we're working with machine integers.
32:27
So what can we do is use a max value here so we could do integer.
32:31
Max value, right? So this will say the first of all, the result is the maximum possible integer and then we will determine on all the things we find.
32:39
So if the student can only contains max value as its items, then we'll get max value in.
32:49
That's correct. Otherwise, you would you would get the expected value.
32:55
So that's pretty reasonable. The trouble is that.
32:59
The trouble with this is if we didn't instead say do collections empty list?
33:06
So where you can get an empty list, by the way, it's kind of, in a way, a nice way of saying, I really mean empty list here.
33:12
So this will give us an empty list.
33:19
So the trouble with this is that we will get max value printed as the minimum of the empty list because what the reduction would do is say,
33:21
OK, initially it's your identity, and then I'm going to go and see if I can find anything that is smaller than your identity.
33:28
And it doesn't find anything because it doesn't look over anything because there's nothing in the list.
33:35
So you get this max as your minimum of an empty list. Which might be OK, right?
33:39
Maybe in your application, that's fine, and maybe, you know, if I get Maxim back,
33:44
I know that empty or maybe, you know, you're never going to call it an empty list. But that's the limitation of using these inconvenient identities.
33:48
So we'll see an example in a minute where there's really no sensible identity even.
33:56
I mean, this is a semi sensible identity and we'll see what we do in that case.
33:59
Any other questions? What I've got the editor? Yes.
34:04
Typekit, yeah, I mean, what I could do is I could say here something like if integers dot is empty,
34:21
throw new legal argument, exception I men only requires.
34:30
An empty nest, right, so if if it was actually inappropriate and if you document it in your in your API, in your kind of description,
34:40
if I mean, if you documented that you should not call on that list, then it would be good practise to check that precondition.
34:49
That's the first thing you do. And to throw an illegal argument exception. So this is the same tactic of throwing an exception.
34:55
You say, throw an exception. This is an object.
35:01
So you knew the name of the expression type, and it's pretty common to I mean,
35:05
there's always a construction that will have a message you could pass, and that's pretty common.
35:10
You can just be very nearly got a legal argument exception. If we do that, then we get a.
35:14
Less meaningful message, we just know that something happens. Yeah.
35:21
Here you can see the entire day's highlighted masturbate in yellow.
35:39
And it's saying that what I've written aid goes to aid is equivalent to passing a reference to the masculine method.
35:44
OK. Like.
35:51
Well, if you are alarmed, it just does what you say, they're here.
36:03
I've said a maps to an expression, and it would really just of this question in the case of a method reference,
36:06
if it is a static method, which, by the way, comes up with italics and intelligent.
36:17
It's just because you hadn't taken it and then it will.
36:21
It will call the static method with the the necessary arguments, you know, to that static methods.
36:24
And if it's an unsettling method, it will be the first argument dot the remaining arguments.
36:32
Makes sense. OK.
36:37
So, yeah, I went over this instant method.
36:42
So, yes, this is concatenation, this is what we went over in the slide.
36:49
We could do a reduction.
36:54
We want to do multiplication right, so we've got factors we could stream them, the identity be won and we could use a lambda x y goes to X times y.
36:56
OK, so now an example of where this form of production falls down.
37:06
So suppose we wanted to do comma separation of strings, which is quite a common thing to want to do.
37:14
You're going to have a whole lot of data. You want to show it in a comma separated way. We don't want to have a leading comma or training comma.
37:18
You just like to have commas between the elements. So how would you how would you do that?
37:24
So say we've got a method comma separate.
37:29
Picks a list of strings, and it does a reduction off to streaming them is a reduction starting with the empty string.
37:34
And what it would do is for a pair of strings X and Y, it will yield the accumulated yield X, then a comma in a space.
37:42
And then why? All right. Well, this nearly works, but not quite so if we run it on the list.
37:50
No leading comma, please. Then what we get is comma space, no comma space, leading comma space, comma, comma space, please.
37:58
So this needy what we want, but we get this leading comma space.
38:07
So if you think about it, when you add elements using a reduction, you start with zero and you add stuff on to zero.
38:10
So here we start off with comma space, and we then concatenated stuff onto comma space.
38:16
So we get this annoying comma space at the beginning, we'd rather not have that.
38:20
So really comma space, sorry, empty string is not really an identity for this sort of accumulation.
38:25
And in fact, there isn't really an identity for this sort of accumulation.
38:34
And in particular, what should the comma separation of an empty list of an empty list of strings?
38:38
What should it look like if you make it comma separated? Maybe it should be the empty string.
38:46
Maybe shouldn't be allowed to do that. It's not totally clear what behaviour you want back.
38:50
OK, so we don't want to start with common space, and we get this, I want to be in coma.
38:58
What we like to do is really combine the first two strings in the list with a common space.
39:02
And then after that, you use the accumulator where we add on more strings with the commas base.
39:09
So start with the first string comma space constraint, then for every subsequent element s append comma space s.
39:16
So what should we do with a single element stream if we just had?
39:28
One string in our list and we want to comma separate out string. That seems pretty natural, right?
39:33
We we just we just want the element itself. And then what if we had an empty string?
39:37
What if we had no strings at all? We want a comma separated them.
39:42
What should be the right behaviour that? And as I already argued, you, it kind of depends, it depends on what your application is doing and.
39:46
It doesn't seem appropriate to specify that as part of the reduction operator.
39:56
So I'm not going to talk about the operational costs in Java, which is like Haskell's, maybe, and Courtland has optional as well.
40:02
And many programming languages do. An optional is a way of documenting the fact that we may not expect there to be any value
40:10
associated with this bit of data that they genuinely lack of value or it will have a value.
40:18
So in Java, you sort of have this automatic because Java has got null and.
40:25
But the trouble with now is that now can mean or we just don't have a value right now or now can mean something's gone wrong,
40:31
and we don't know the value optional as a way of elegantly saying.
40:38
We really might not have a value, and that might be perfectly fine, and you should be prepared to deal with it in your programme.
40:43
So the cost optional. An instance of this class is either empty contains no value or full meaning it
40:49
contains a value of the type T associated with the angle brackets optional T,
40:58
so an option is either present, meaning it's got a value or we might say full or it's empty,
41:04
in which case there's no value and it's got a number of methods.
41:11
But the most important methods are is present,
41:14
which gives you a Boolean telling you whether or not there's something inside the optional and this debt and with gets you should only call get.
41:17
If you know the optional is present, you will need to know it because you just asked the question.
41:27
You said if is present, then get or you know it by construction.
41:34
You've built your programme in a way that this line of code, you just know that there will be something in the optional.
41:40
If there's not, there's a bug somewhere else in your programme.
41:47
So you might like this you might assert is present so that you've got a nice assertion documenting what assumption you're making.
41:49
So guests will throw an exception if in the optional.
41:56
Otherwise, it returns what's in the optional and then the coolest method of optional, in my opinion.
41:59
I mean, if you can regard methods and optional as particularly cool, I think I do.
42:04
So is the or else method. So the idea of or else is you don't know whether there's going to be something in the auction or not.
42:08
If there is, then you want what's inside. And if there's not, then you've got a default value in mind that you'd like.
42:17
Try to use instead, so you can say or else blah on an optional to get what's inside the optional or blah if nothing is inside the optional.
42:25
So this is quite a nice way of of using an alternative value in the case where an optional is empty.
42:37
So why have I told you about this?
42:44
The reason I've told you about this is that there's another form of reduction in Java that doesn't require an identity.
42:46
And instead of returning a value of the stream type, it returns an optional of the stream type.
42:53
And if you call that on an empty stream, you get an empty optional.
43:00
And otherwise, you get that behaviour, I showed you that we wanted for comma separation,
43:05
like get like the accumulator applied to you, start with the first element and then you apply the accumulator from then on.
43:08
OK, so we only need an identity if we have to have some way to get started with our reduction.
43:17
And that's what we'll get back if there's nothing in the street.
43:24
If it's OK for us to just use the first thing in the stream as our initial value and accumulate the rest of the stream onto that,
43:27
then we don't need an identity. But we'd be stuck if the stream is empty, we wouldn't have that first value an optional help sign.
43:35
OK, so the overload the stream provides for reduced and just to remind you of terminology,
43:44
overloading is where you've got multiple methods with the same name.
43:50
But normally with different argument types or really always with different argument types.
43:54
It provides an overload of reduced that because just an accumulator, but not an identity.
44:00
And what it does is instead of returning something of type T,
44:07
it returns something of type optionality and an empty stream, we're reduced to an empty optional.
44:11
So this allows us to elegantly do something like a comma separation.
44:19
For instance, suppose that we've decided that if we comma separate an empty stream, we should get an empty string.
44:23
Let's say we've decided that then what we would do would be use or else on the result of our reduction and give empty string as the default argument,
44:30
meaning that if actually there was nothing in the stream and we got back empty, we sorry, we got that an empty optional,
44:41
then we're going to say that the comma separation of the stream of strings was the empty string.
44:49
So how does this look? Well, we can say, I mean, actually, I think maybe I will write this in the editor.
44:54
I some of the time typing up is. And I said a nice way to do it goes a bit slower and elicits more questions.
45:02
OK, so let's say we've got. Method that returns a string called comma separated.
45:11
So we're taking a list of strings. It's going to do something.
45:22
And I mean, let's print. Comma separate.
45:29
This style of. Hello.
45:34
Costs. OK.
45:39
Right. So what we're going to do, then, is just to remind you we could return.
45:54
Strings. Dot stream, dot reduce.
46:03
With Adam Stringer's identity and with string and with.
46:11
Accumulating two strings to be a common space.
46:19
And if we do that, then we'll get the annoying leading coma. OK and Justice Ministry, what's going on there?
46:25
I mean, if I instead use this as my identity, then we should get exclamation marks and then a comma and a space.
46:33
So it's not as if there's there's not really a leading comma here.
46:39
It's more that has an unwanted string in Oklahoma separation.
46:43
And we made it almost straight empty. And it looks like a leading comma.
46:47
OK, so now what we could do instead is say, well, we're going to use this special reduction,
46:57
it doesn't take any density, so let's just get rid of the identity. But now we're getting a compile error.
47:03
So why we getting computer error, anyone? Want to volunteer the reason?
47:09
Yeah. Right, we were talking an optimistic night when we said we said we were going to try to strike very good.
47:15
So let's say. You never had an optional string.
47:23
So optional, I could use control and to do that. And if you go up here.
47:31
You'll see that oh, no, it supports Java, don't use a lot star. So this is an annoying thing, right?
47:38
The need to be a bit careful when you use IDs. Because you.
47:42
Your style guide may have certain requirements, for example,
47:50
the Google style guide says don't use the storyboards and generally the star employs about idea.
47:53
It's kind of lazy shows that you're always thinking about what your programme depends
47:59
on good practise to be thinking about what courses I might actually be depending on.
48:01
Do I really need those dependencies? Not just import everything right?
48:06
Give me everything at my disposal. If you do programming competitions kind of half the length type stuff,
48:10
that's pretty common just to have import everything at the top because you want to on solving an algorithm in the best way you can.
48:15
But when you're writing real software, you want to be quite careful about what you're using.
48:21
You can configure intelligence, tell it not to do the store import,
48:26
but otherwise when you import more than a certain number of things than it does this bizarre import you automatically.
48:29
So let me see if I can remember where option is. I think it is Java you two optional.
48:36
But you still got optional. OK, so oh, but because I removed this, our import in addition to about list.
48:42
So let's tell our list. And another another you've got be careful of is if you're too trigger happy.
48:52
OK. Yeah, it was offered me another alternative the list is not offering it to me now, you may have noticed before it says, go on until this order.
49:00
When you see this, it's the abstract windowing toolkit which you could use for building goodies.
49:11
And sometimes if you're kind of typing quickly, you might find that a short suggestion from the from the IDE comes up.
49:17
And before you know it, you've accepted it without really meaning to kind of slip off the keyboard,
49:24
and that can lead to crazy things getting imported.
49:28
So every year, when I mark these lexis tests, there's always some solutions that I've got really, really strange imports.
49:30
So I would like you to make sure you're really thinking about what it's doing
49:37
if something strange happens unexpectedly and your file seems to have changed.
49:40
You control that to do it one day and then just do it again will carefully make
49:44
sure you don't have kind of some really strange costs imported at the top.
49:47
The trouble is that if you're importing less or set,
49:51
there are often many clauses that are less used in different libraries that may have names like that,
49:54
so an auto complete may end up suggesting them and you may accidentally import them.
50:01
And why does that matter? Well, it matters because I mean, the doctor mark.
50:05
That's one reason. But the reason I mean is that. You can make your project accidentally depend on something that you've got on your machine.
50:11
There's a library that you've got on your computer. You make your project, depend on that library and your project works fine on your machine.
50:20
You've not even noticed you've made your project. Depend on that library. It was an accident.
50:27
Then you try and actually get it working on someone else's machine or deploy it, build it somewhere else.
50:31
And it doesn't compile because they don't have that library available in their system.
50:36
Right. So trying to be very clear about what your software depends on is an important part of software engineering.
50:41
Anyway, go back to this then. So now we've got this this code, right?
50:47
So our produce records are optional. This isn't really what we want because what we're going to get will be run.
50:52
It is optional. Hello, class, how are you?
50:59
All right. Well, we didn't want that, we wanted the we wanted to actually have hollow class how you said what we could do then is.
51:03
So let me. Extract this into a local variable.
51:15
How do we do that again? I don't been using intelligence for a while, so I would just do it manually, so it results.
51:21
So optional. String.
51:33
Result. Sorry to call comma separating it.
51:39
Right. So suppose I comma separate these things into an optional then I could do result they'll get.
51:51
OK, so we get this optional result and the couple gets in it.
51:57
And now. That gives the desired result.
52:03
Hello, class, how are you? OK. That's maybe fine.
52:06
But what if we use an empty nest? So let's say I do.
52:13
This string data, because this thing or the unattractive the string data equals collection's empty list.
52:19
So if I use my empty list version. So I've got an empty list, and I comma separated to get results, and then I show the things in the optional.
52:30
Well, what's going to happen now is we'll get an exception.
52:41
Because comma separates will give us an empty optional because the stream we got from the list was an empty string.
52:45
And then we tried to call Gats on an empty optional.
52:54
So we get this exception. No such elements exception saying no value present.
52:58
So what would what would you like to do instead is?
53:03
Let's go back to just printing the results. We'd really like this method to we're trying to string.
53:08
And instead of returning the optional we do this or else on it.
53:18
And we might say nothing if it was if the if the stream was empty, I'm going to say nothing.
53:23
And I hear. This is no longer the right type to receive the results of comma separate because comma separate now returns string.
53:31
So now there's nothing here, we get nothing for as long we have the actual data.
53:42
And we get. Expect to have results back, and probably we don't want to say or nothing, we probably want to say or else actually nothing.
53:51
Empty string and then. If I switch back to the empty list version.
54:01
And the comma separation will be nothing, so in this light here we should see just a blank line.
54:08
Yes, please. Difference between during inception is that, well, there are a couple of differences.
54:13
Fundamentally, there's not really a difference in the either way your programme is going to go wrong.
54:32
However, there are some practical differences.
54:38
First of all, the research actually documents the person who wrote this code had good reason to believe that the optional should.
54:40
Not be empty here, so they might be wrong. However, they may have been right and actually the fix is not to work around the option.
54:49
Don't see fix fixes to determine how it became empty earlier on in the programme and adopted by the programme.
54:57
So that's one reason the second reason is a bit more technical. If it is, sir, it fails.
55:02
You get an assertion error. If you look inside an empty optional, you get no such elements exception.
55:06
Later on, of course, we'll study exception handling, and it might be that those exceptions have been handled differently.
55:14
And if they been handled differently, the programme will behave differently depending which one of them is.
55:20
The final reason is that assertions in Java enabled if you run your programme with DACA, enable assertions.
55:24
Otherwise, assertions are not enabled and is pretty typical to have lots of assertions in a programme, whether it's in Java or in other language.
55:32
And when you are testing the programme during development, you enable the assertions when you run the programme in the wild.
55:41
Don't enable the assertions, the assumption being that it's better for the programme to grind on and do something than just stop.
55:47
That is that that's questionable, but that's often the kind of kind of the case in practise.
55:54
I was going to say this take a 10 minute break, and I think that's quite good timing. OK?
56:00
Can I ask a question? Maybe.
56:05
Can you ask her at the beginning of the next session, just because I didn't want to chat and others are we're drilling in our room.
56:07
OK. It is just a smaller. I'm not saying, OK, everyone, let's make a start again regarding the drift regarding the drilling,
56:15
I've got the mobile number of the building manager and I just called them and requested them to do something about it.
56:41
So if happens again, I'll make more of a fuss. OK, let's let's do it.
56:47
So just when I finished off, there was a question from someone in the Zoom audience that I didn't hear.
56:52
So would you like to ask the question? I think I understood it.
56:58
OK. Right. So we've been through this idea of doing commerce, separating, using a reduced without that identity.
57:04
And this slide summarises why I showed you in the idea of terminology you may have noticed with these same operations that they all return streams.
57:17
Apart from reduce or collect, which returns something,
57:27
this is not a stream either a single value in the case of reduced or an optional and in
57:30
the case of produce with no with no identity or a collection in the case of collect.
57:35
And what we talk about with streams is that being a stream pipeline where we chain together operations,
57:40
we either have intermediate operations that transform a stream into another stream and the main intermediate operations are Mac and Filter.
57:47
Or we've got terminal operations that turn a stream into a non stream by somehow collecting their elements together.
57:56
So map and filter, like I said, are the classic intermediate operations and collect and reduce are the most widely used terminal operations,
58:05
and a stream pipeline starts with some stream maybe gotten from a collection or maybe gotten from some external
58:14
data source then applies a number of intermediate operations to transform the streams potentially many times.
58:20
And finally, does a terminal operation to either get a single value from the stream or a collection of values from the stream.
58:27
One thing that is quite nice is that you can collect a stream into a map,
58:35
so if you've got a stream of elements, you can turn the stream into a map, which is a key value store.
58:40
So a map from some key Typekit to some value type B. So I think I'll do a little coding
58:46
example showing you how you can use collectors to map to turn a student into a map.
58:52
So let's suppose that we want to. You have a function.
58:59
Which is going to count occurrences. So you might say public static void.
59:06
Counts sorry, not Pakistan, to avoid public static map.
59:16
Integer. Integer. Counts occurrences, so it's going to take a list of integer values, and I'm going to import maths, which is from Java, Utah.
59:23
And we're going to do here is we're going to go through these values and we're going to end up with a map telling us how many times each value occurs.
59:44
OK, so what we could do is we could do this with a loop.
59:55
We could say back into integer. Integer results.
1:00:00
So we could do something like the following. We could say for. Integer I in values.
1:00:11
We can say if our results. Does not contain the key.
1:00:24
And we could say results don't put. I zero.
1:00:38
Right. I wonder if this is the first occurrence of I've seen this record that we've now seen I once.
1:00:46
Otherwise we could say results don't put I.
1:00:54
Results don't get I lost one.
1:01:00
And finally, return results for the third way to keep the double up.
1:01:07
The complete cubillo up and result in death, great.
1:01:14
I think what you might be able to do is get or default, right?
1:01:20
So what we could do, actually. Is equivalently right, this has results.
1:01:26
Dot set. Results Dot.
1:01:34
Yeah. No, I'm not sure. I don't think there is, but I'm not sure.
1:01:40
Yeah, or default will give you a default value.
1:01:46
If the thing you're looking for is not in the map, but I was wondering whether, whether there's a way of saying.
1:01:49
Add an entry that will then have that default value and give me the default value.
1:01:56
I don't think there is. So yeah, this would be this would be a way of writing this for the loop.
1:02:01
So what I can do is say, let's have a list of injuries.
1:02:09
And maybe let's give it the bad news. Well.
1:02:19
So we've got a bunch of data in this, and I'm going to say system to either print Ellen and.
1:02:35
Occurrences of data. The screams go on, survivor here, we just got some data calling kind of occurrences on it and kind of occurrences,
1:02:44
it's going to make a map from integer to the number of times that integer occurs on the list.
1:02:54
And it's going to build this map up by saying, Well, we've seen the integer once,
1:03:00
if this is the first time we've seen it or saying we've seen it one more time.
1:03:05
If we'd already seen previously. So let's just run this and check this doing something reasonably sensible.
1:03:12
OK, here we are. So could we do this alternative alternative with streams?
1:03:21
Well, let's let's copy the methods of the truth that. Compete again.
1:03:28
OK. So count occurrences. No, I didn't actually think this example, this is an example I've come up with on the spur of the moment.
1:03:39
So let's talk through together how we might achieve it. All right. Well, I want to do is something like values stream.
1:03:49
Don't collect collectors dot to map. But collectively, it too is quite interesting.
1:04:00
It needs to have a function. To give his.
1:04:07
And a function to give. Associated values.
1:04:15
So let's have a look at collectors to map. So collectors to map this is a little bit.
1:04:22
A little bit difficult to treat. OK. But the term up here requires a function from tea.
1:04:32
Don't worry about, oh, this question marks super extends and we'll cover that later.
1:04:41
And of course, it basically needs a function from tea to cake, which is the key mapper for every element of the stream.
1:04:47
Going tell us what key that corresponds to, and then it needs a value map every element in the stream.
1:04:55
It's going to tell us what value element or correspond to.
1:05:02
So what we might want to do, first of all, is get rid of any duplicates from this.
1:05:08
From this street, we've got the stream of data, and we would like to.
1:05:20
Yeah, we'd like to end up producing a frequency count. So how could we do that?
1:05:28
We're going to. Got all these items flying past.
1:05:33
All right. And what we'd like to do is build up. A mapping from.
1:05:39
Each item to its frequency. But we could only have one entry in that nothing item.
1:05:46
It would not be appropriate to have multiple entries in the mapping for a given item.
1:05:53
So any thoughts on how we might go about doing this? Yeah, it's.
1:05:58
So what we could do is we could transform the stream from from one thing into another.
1:06:16
All right. I don't know if that's going to be very helpful to us here.
1:06:25
Actually, this is not very well in the. This example is a little bit hard to mappers, can you explain how the two lab works?
1:06:33
Yeah, I was, I was I was going to use this love to show you had some app works,
1:06:43
but I've now I realise it's a bit it's a bit more complicated an example than I'd thought, so it's not very suitable to my works.
1:06:47
OK, so do we.
1:06:54
Why do we make that an exercise to ponder how we would achieve this to a next time, whether whether it could be achieved nicely using streams?
1:06:55
But let me do a simpler example that's actually useful in showing you how that works.
1:07:01
OK. So maybe instead, let's say we'd like to map every integer to whether it's even on us.
1:07:05
So let's say we've got one two three four five six seven eight nine 10.
1:07:15
And. We'll call this compute is even so what it's going to do is it's going to take a list of integers.
1:07:23
And it's going to return a mapping from integer to Boolean right and an actual map.
1:07:32
So true, if it's even into false, otherwise, you may observe this would be the same as we're charting a set of integers.
1:07:40
This subset of injuries that are even. OK, so a mapping from a type to Boolean is equivalent to a sex.
1:07:46
It's often called the characteristic function of the text.
1:07:54
So anyway, here what I'm going to do that is I'm going to say stream the values and use collectors to map.
1:07:57
So what I want to do is say that the. The kidnapper is going to take every element to himself.
1:08:04
I'm going to assume there are no duplicates on this list, so I would say item goes to item.
1:08:13
And what's the value that we're going to do? Well, the value matter is going to say item goes to.
1:08:20
Item mode two equals zero. That's how we check whether something is even.
1:08:27
All right, then we're going to return the. So extreme that extreme values and we've collected them using collectors to map and collectors,
1:08:39
but to map says that every item in the stream, that's what its key will be.
1:08:49
And this is what its value will be. So here we're turning, we're saying that an is key will just be a.
1:08:54
And in industries associated value will be whether the integer is even or not.
1:09:01
Certain outlets replaced this with complete is even I'll get rid of this, this kind of currencies function.
1:09:06
Yeah. So we run this and we should get our desired one, both two true, three false or true, et cetera, et cetera, et cetera.
1:09:15
Why do we do something slightly wacky and say we're actually going to?
1:09:28
Protecting the intruders is strings instead of integers, right?
1:09:35
So. I'm going to map every integer to the string value of every integer to a string representation of an integer.
1:09:38
So I would have a mapping with quotes. One equals false quotes.
1:09:54
Two equals three.
1:09:58
Except in Java or you display something as a string, you don't get the quotes right when you print something out, you to get the quote.
1:10:03
So this looks the same. So just to convince ourselves that something really has happened here that's got an exclamation mark around them.
1:10:11
So every item is going to go to exclamation mark integer that's going to be key in the map and its value is going to be whether the item is even out.
1:10:18
So now we've got to go is the true one goes to false nine, goes to false and.
1:10:30
Maybe one more point to illustrate. Let's say I change item here.
1:10:42
To Item Mod five meaning.
1:10:48
I'm not going to allow a keys larger than for the keys are going to go from zero up to four inclusive.
1:10:55
No, the problem with this is what. I think maybe the right answer keys can be can't be duplicated.
1:11:02
Yeah, duplication, duplicate keys, right? So we would end up with one mapping, two exclamation mark, one exclamation mark,
1:11:13
two mapping two similar to similar format, similar five to zero exclamation mark.
1:11:19
Sorry, exclamation mark, zero exclamation mark. And then six is getting them up to one exclamation mark, sorry exclamation mark, one exclamation mark.
1:11:26
And then we'll get an exception because we tried to make a map, but we map the same key to multiple values.
1:11:33
It's an illegal state exception, duplicate key exclamation mark, one exclamation mark attempt, attempted murder of these value schools.
1:11:41
So that's a little example of hype to the networks.
1:11:50
Every element in the stream, you provide a function saying what that element should make to you as a map key.
1:11:53
So this is a bit alarmed to hear. And then you provide a function saying what is value should matter.
1:11:59
And I think it's another one to hear as well. Yes, please. What is meant by the schools?
1:12:07
Oh, right. Well, it's oh, that's interesting. OK, so I hadn't thought about that before.
1:12:14
I expect that if the values that the keys of match were the same, it will accept them.
1:12:18
All right, but let's try that, so why do we just say that everything matters to folks?
1:12:24
OK, now I'm missing some parentheses.
1:12:30
Just based on reading the error message,
1:12:36
my expectation is that it will now work because although there were duplicate keys, those keys not to the same value.
1:12:37
So there is a reasonable map that could be.
1:12:44
Constructed and they may not be good in practise, it may be that you really didn't want that to be duplicated,
1:12:50
that may be, but OK, so that's not where it all flows in both.
1:12:56
OK, so it looks like I was wrong with my conjecture that duplicate keys are illegal.
1:13:01
I don't really know then why you get a message about merging values. I mean, if they're just a legal full stop, then why try out these?
1:13:07
I very much doubt it would be because what would be a good what would be a sensible default think for it to try?
1:13:23
Now. Yeah, but this is this is implemented generically, it's implemented so it can work for whatever types.
1:13:31
I mean, it's possible that it's just an error message so that they can know which exactly failures.
1:13:39
Oh yeah, that's a good point. Right? Yeah, indeed, right? That's it. Yeah, I think that probably is the reason, right?
1:13:46
So there's been some key, there's been some key duplication.
1:13:50
It could be a lot of potential duplication, and it's giving you an indication of which keys by which parts of the stream you have in duplication.
1:13:53
Yeah. Good. I suspect that is the reason. Excellent.
1:13:59
OK. So I hope that gives you an example of how to my books and I know enjoyed I felt like I felt it,
1:14:04
that kind of currencies should have been a good example. But yeah, it doesn't seem to be a very good fit for strings, at least in this case.
1:14:09
What? Yeah. But.
1:14:19
But 360. But I doubt it.
1:14:25
I mean, let's try it. We just say that the the key is always going to be.
1:14:33
Hello. Say. The values always going to be false.
1:14:42
Very boring now, so everything's going to be about false to hello, false.
1:14:47
What will I predict will happen is the first time it will correctly produce the first entry in the mapping and then the second one will fail.
1:14:51
All right. That would seem to be the. And due to the keep it sent to useful symbols.
1:15:01
OK. Right.
1:15:10
So the map requires a function to map every type T to the key value of Typekit
1:15:13
and a function to map every stream entry of type T to a value of Typekit.
1:15:20
So when you use to map, it's pretty common for T and K to be the same.
1:15:24
But as I showed you that there need to be, we should shoot a stream of integers mapping to a string to Boolean map.
1:15:29
And as we discussed, it's illegal for two felons to be the same.
1:15:38
So here is a quick example to string with parity.
1:15:43
So it's basically the same as the same as the example I showed you in the lectures and in the demo.
1:15:47
So a few notes and streams, I already mentioned this earlier. But if you start with an ordered collection, a list in particular industry,
1:15:54
you get an ordered stream so you can guarantee seeing the elements of a stream that came from a list in the same order,
1:16:01
the elements were in the list with a set.
1:16:08
First of all, if you ever iterate through a set when you do it using a for loop or whether you do it by targeting the the set into a stream,
1:16:12
there's no guarantee the order in which you will see the six elements probably on your computer with your particular implementation of Java.
1:16:19
If you run your programme again and again looking at the order, things are in sets.
1:16:29
It will very likely not change.
1:16:33
The Java language doesn't guarantee that it won't change on a on a stable environment, but probably in practise it will change.
1:16:36
However,
1:16:43
you shouldn't depend on it because a language doesn't even guarantee that a b on someone else is set up with a different implementation of Java,
1:16:44
or maybe even just other environmental factors on their machine, potentially the amount of memory they've got available to potentially various other.
1:16:52
Yes, in some cases, if this if the collection is implemented using parallelism, essentially what other work is going on in that machine?
1:17:01
The order you can see when you inspect elements of a can be completely different.
1:17:09
So you can never guarantee what order you will encounter elements of a setting.
1:17:12
And likewise, when you stream from a set, you've got no guarantee about the order.
1:17:17
You will encounter elements of the stream when you do a stream operation. OK, and some final notes, some streams, you can't use the stream twice.
1:17:21
So here if I've got a list of integers one, two and three, I stream them into an integer string.
1:17:30
Then if I reduce that stream. And try and reduce it again.
1:17:39
Then I get an illegal state exception saying that the stream has already already been operated upon or closed.
1:17:44
So if I did really want to do this, I could stream from the collection again so I could stream from my list of integers once and do a reduction,
1:17:52
and then I could stream from it again and do a reduction.
1:18:01
And one of the reasons that you can't do things multiple times on a stream is that even the streams we've been looking at here
1:18:04
and often the streams you use in practise when you just want to get access to functional features come from stable collections.
1:18:12
But in principle, a stream could come from some data source where the elements of the stream genuinely are not available multiple times,
1:18:19
they really only available. As they fly past, so you can't say, Oh, that was interesting.
1:18:25
Can I see it again? It's like, No, you have to actually decide what to do there on your screen.
1:18:31
OK. There's some material here about using Java collections.
1:18:38
I'd like you to go through it in your own time, so it shows you a list, set a map, interfaces and a bunch of methods on those on those interfaces.
1:18:42
And a point it makes. I would like to just spend a little bit of time talking about it is that it's always good practise to use it.
1:18:52
Interface type on the the left hand side of a declaration,
1:19:00
unless for some reason you need specific features of a particular cost implementing that interface.
1:19:06
So read the rest of these slides in your own time. But I want to do a quick coding demo to illustrate that point.
1:19:14
So. Let me just.
1:19:22
Get rid of the skirt. OK.
1:19:31
Let's have a look at the list interface. So the lesson space as a whole lot of methods.
1:19:37
Bike size is empty, contains iterator to a whole load of methods, and some of them are more widely used than others,
1:19:52
and because this is an interface and it specifies these methods, we know that every cross implemented the interface will have these methods.
1:20:01
So if I go back to my demo, I could write something called.
1:20:12
Well, why don't I say? Show elements and it's going to take a list.
1:20:20
Of strings. And it's going to go through this list of strings.
1:20:30
Maybe it's going to say, yeah, system. I'm.
1:20:42
And in. In May, I'm going to do a few things, I'm going to have a new ArrayList.
1:20:55
One. I'm going to have a new linked list.
1:21:02
I'll see. I'm going to have a list of three made from lists of.
1:21:09
I make this be. A B.
1:21:19
See? Sorry. So and I'll do one more, I'll say list L four equals erase as list.
1:21:26
To be. OK, maybe one more again, I'll say at least five.
1:21:41
Because. Collections. On modifiable list.
1:21:52
One. All right. I'll go through what this has been in a moment.
1:22:01
Maybe I'll just add a couple of things into one and say L want to add?
1:22:07
X Y. To add.
1:22:13
Said. W. OK, so we've got here a.
1:22:18
A list l one, a list out to a list L three, a list L for a list of five.
1:22:27
They're all lists. As a result, I can show all of the elements.
1:22:33
I can go. Show elements. One.
1:22:38
Two, three, four five. So what is the problem here?
1:22:45
Yeah, sorry. I don't think one argument, sir. I should have called it twice.
1:22:55
So I've got a list one I've had it actually made to it. I've got a list like I've added that to it.
1:23:07
I've got a list, all three that's got AIDS in it on construction analyst al.4, that's got info on construction and I've got a funny list.
1:23:14
L5 is an unmodified double version of L1.
1:23:22
And then I got to show you the elements for these lists, so if I run this programme, then I should see X Y Z W.
1:23:28
ABC, the x y. Right.
1:23:37
So. That's the contents of Alan. That's going as well, too.
1:23:41
That's the quality of our three. L4 and L5 is not a modifiable version of about one, it's got the same contents as our.
1:23:47
And maybe just to make our Typekit look a little bit nicer. I'll.
1:23:58
Yes, I would use system to try a prince. I'll do a space.
1:24:05
And then. Guideline. So if I run this, we should see this is a more.
1:24:12
OK, so now let's suppose that actually I wanted to do something else in this show elements.
1:24:24
So. I could, for example, also print the size of the list so I could say system or print alone.
1:24:34
Size of list is strings the size.
1:24:44
So why kind of do size? But I can do size because Strings implements the list interface.
1:24:50
If I go into the list interface. There is a size method in this interface.
1:24:59
And here I can say. Is less empty.
1:25:11
And similarly is empty as part of the interface, so I can use it right?
1:25:21
And by the way, the reason I can do this. Iteration over the list is actually this is getting a bit more technical, but less extensive collection.
1:25:26
Collection expense, it's horrible, and it's true, but it's all the things that you can iterate over.
1:25:39
So it's because list is what's called a sub interface of.
1:25:45
That's what lets us do that looping over it. That's a list item will go into this later on.
1:25:50
Of sub interface things, but the key thing is that inside this strange method, this show elements method, I can do anything on strings.
1:25:57
This available in the list interface, so why don't we try and find something in ArrayList that's not in the list interface?
1:26:07
So let's go into ArrayList and have a look at his methods.
1:26:15
Right. So it's got a method called trim to size. Is that in the list interface?
1:26:21
Let me control it and the listed space? No, it's not in the list of states, right?
1:26:26
So what I can do that here is because L1 is a array ArrayList, I could say L1 dot trim.
1:26:30
OK. It's not available. Is look for a different method in ArrayList.
1:26:40
Maybe this is in a different. Plus.
1:26:46
OK. Oh, sorry, sorry, sorry, sorry, sorry. And it was so.
1:26:52
Yeah, I can't do our eyes. The reason I can't do that.
1:26:58
It's because I've declared El One as having type list.
1:27:05
By making that type list,
1:27:12
I've said the things that are available on our one are things from the list interface and trim to size isn't part of the list interface.
1:27:13
I did actually initialise it to a new ArrayList, so behind the scenes, it's implemented as an array list.
1:27:22
But because I've declared it as having type list, the array list functionality is not available.
1:27:28
When I when I look at which methods I can call. Why could do instead is I could say ArrayList one equals new ArrayList.
1:27:36
So now I've actually said I really am declaring an ArrayList here.
1:27:48
I'm committing to L1 forevermore being an ArrayList. OK.
1:27:51
And now I can go to emphasise, because that's a method available, all right.
1:27:57
Yeah, please. So it's like. Right, so well, let me try let me try explain that, right, so no.
1:28:01
I've got this ArrayList that I can do to emphasise. OK, but inside show elements.
1:28:17
I can't do strings doctrine to size. OK, so that OK, I'll come to a question in a minute.
1:28:22
I just want to finish the point I'm trying to make, right? So let's suppose, actually.
1:28:29
We had. Implemented show elements.
1:28:36
Without really thinking about what kind of list we were using. So let's suppose that we don't even thinking about it, rightists.
1:28:41
And we had actually implemented show elements to take specifically an array list, not because we really,
1:28:49
really care about ArrayList, but because maybe they're the only kind of list we've heard of.
1:28:56
So now this works on ArrayList. Okay.
1:29:02
And for some reason, we ended up getting a bit carried away and realising, Oh, you know, the ArrayList is too bad, too big, so let's trim it to size.
1:29:05
Right. So now this works fine, but the show elements works on an ArrayList,
1:29:15
and then imagine this was more serious because it actually did something meaningful.
1:29:21
But nevertheless, it relies on this ArrayList specific piece of functionality.
1:29:25
There may be, you know, a few years later someone comes along and things. Actually, I would like to use a linked list with your code.
1:29:30
Right. So maybe. They list to.
1:29:38
And then down here, show elements LC Oh no, it doesn't compile, right, doesn't compile, because why not?
1:29:46
Well, let's have a look. Required type ArrayList provide a type link list.
1:29:53
Oh, OK, so let's go and change this, let's say. This year, we're going to list instead.
1:29:58
Right? Then maybe some of us and some of us in the room have an argument and say,
1:30:04
should it work on Israelis a little less now doesn't work on terrorists because it made it work on lists.
1:30:11
So we go, OK, well, hang on a minute. This is interface code list. And actually really, we just need this method to work on lists.
1:30:17
So let's go to this show. Elements make it work instead on a list.
1:30:23
Right? So before it worked on an array list. And that being said, OK, we want to sue everyone, let's make it work on a list.
1:30:29
But now it's trim to size. It's not available because that was a function specific to the ArrayList class.
1:30:39
And maybe this is like embedded deep inside how this method works.
1:30:46
This is a really simple, nonsensical method I've implemented. Maybe this is a more sophisticated piece of code.
1:30:50
And over the years,
1:30:55
it's ended up depending on this implementation detail the fact that ArrayList has got a tremendous size methods and maybe for whatever reason,
1:30:56
just removing that line of code is going to cause other things to break. OK.
1:31:03
So if we'd in the first place use the list interface,
1:31:08
then we would we would not have been able to have made our code depend on that ArrayList only method trim the size,
1:31:13
and we would have been forced to have thought if we thought, Oh, wouldn't it be good to use trim to size here?
1:31:20
We would've thought, Well, if we use criticise it, we have to make this only work for aerialists.
1:31:26
We work for other kinds of lists now and then. We would have had a conversation with our collaborators about that.
1:31:32
Is that a sensible thing to do? Are we really sure that ArrayList is the only list we have to care about for this piece of functionality?
1:31:37
The answer might be yes, it is in which case fine. Let's make it be an ArrayList specific function that can then use ArrayList specific functionality.
1:31:43
But if actually we really would like this to be more general,
1:31:51
we should stick with the more abstract type list and that will make our code more future proof.
1:31:53
OK, so having said all that, yes. That's why this is not a specific response.
1:32:00
Yeah, basically, you should always use the more abstract form unless you need the specific functionality.
1:32:17
So what you should probably do this silly example is use list everywhere.
1:32:22
OK. And then you can't coach him, his eyes.
1:32:28
So, yeah, you can do that, and we'll come to that later on, of course.
1:32:38
And it's. It's bad practise to do it if you can avoid it for some, sometimes just what you need to do.
1:32:42
All right. So here we can't coach emphasised because we don't want to be a list,
1:32:50
but we might think, Oh, actually, we really do want to trim it to size before we call.
1:32:54
This show elements method,
1:33:00
so a compromise would be declared as an ArrayList so that we can do a really specific things to it at the beginning of time.
1:33:02
And then when we pass it to trim the size from two sides can accept.
1:33:08
Sorry, when we pass it to show elements, show elements can accept any list.
1:33:12
And then once we're in show elements land, we no longer have access to direct access to the methods of our list.
1:33:18
So the basic message, which is I mentioned a bit more in this study in your own time slides,
1:33:26
is always declare using interface types or more abstract types when you can and only use a more specific type if you know you really need it.
1:33:31
You know, actually, I don't just need some list here. I'm not going to change my mind later and use a different list.
1:33:40
I really want an array list because I want to use special features in the list.
1:33:46
Yeah. If you use VAR in the declaration, the type you get is the most specific type, right?
1:33:50
So if you said VAR, L1 equals. So if we say here.
1:34:00
Ball one is the greatest. Then we can you can't coach in.
1:34:10
So this is your reason. Good reason not to use VAR. I mean, I think I think using Bar is pretty bad practise.
1:34:16
It's like, I mean, I do to sometimes myself because I am sometimes lazy, but is that is that figure thinking?
1:34:23
I don't really want to write this down. It'll save me time. I'll just use far right.
1:34:29
Is kind of lazy programming. Typically, it's better to spell out what things are.
1:34:34
It can be good.
1:34:38
It can be convenient to use VR because sometimes if you like to change a type somewhere, you don't have to change loads and loads of other types.
1:34:40
And that can really make a refactoring of your programme easier.
1:34:47
On the other hand, the process of going through and making all these changes makes you really think through the factor.
1:34:50
I mean, she said, should have change that. Should I change? That doesn't make sense. Doesn't make sense. Yes, it does.
1:34:54
Just having like the compiler work out what the types of your programmes are behind the scenes doesn't necessarily lead to you having the best
1:34:58
understanding of your programme or your programme being the most readable because there are all these boards everywhere rather than actual types.
1:35:06
If you're programme in C++,
1:35:14
it's the same story with auto or two as a convenient thing in C++ to avoid an awful lot of boilerplate type declarations and C++.
1:35:15
It's a real pleasure that the language has that feature, but it can be overused.
1:35:23
Yeah, because on this? No, there's no job, there's no way I'm doing it, according to Typekit, to give you a short answer because and honestly,
1:35:29
I think that's really good because it's it's just better to be able to see what things are explicitly.
1:35:43
I mean, there are exceptions that I appreciate sometimes, and having having Typekit items can be convenient and good.
1:35:48
But I mean, Haskell, great language. Terrible coding style.
1:35:55
My personal opinion, I mean, you just get all these like tiny, tiny, tiny variable names, you feel like basically you do it.
1:36:00
I do because I'm not very good at it, but you will probably feel like Wikipedia.
1:36:08
And then you look at it later like, oh, like, what is that representing? What's effort?
1:36:11
What's effort x represented? What is X? Is that what is sex? There are all these conventions and things.
1:36:15
And why not just use actual, meaningful names of your programmes that just makes your programmes easier to easier for people to comprehend?
1:36:20
Right, but that's that's not very hostile ish, though.
1:36:28
So and I'm with you, I think we're on the same side. I'm with you still compilers and it's easy to read and it takes massaging longer to write.
1:36:33
So it's better if it's necessary. OK?
1:36:41
It will a bit of a tangent here. And. But.
1:36:44
Yeah, with VAR, you've not said what type you want. You've implicitly indicated what type you might want by what's on the right hand side.
1:36:53
So there's no way for the compiler to know what you really intended.
1:37:02
So the most reasonable thing it can do is say, what's the most specific type that does satisfy these constraints?
1:37:05
Yeah. OK, good.
1:37:12
All right, we'll stop there, and I will actually see you next week this time. I saw the.
1:37:15