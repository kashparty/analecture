ID: 168c7b20-f5e1-4d79-b634-ae28010cb492
Title: Java - 2022-01-25
Category: Java
Lecturer: Alastair Donaldson
Date: 25/01/2022
I've got to ask. I expect. Hello.
0:38
OK. We have an awful lot.
0:49
OK, so that's up, up, up, up, up, but still.
1:03
Can you say? Hello.
1:25
OK, that seems to sort of echo. Can someone align themselves and say yes?
1:35
Yep. Executive Gun, a very accurate yes and having fun teach you two courses at the moment in two different activities,
1:42
and there are just different surprises every day. Different technologies, prices, it's definitely keeping me on my toes.
1:50
OK. It's really nice to see you all. Welcome to the next lecture.
1:55
What we're going to do today is look a bit at references, garbage collection and immutability,
1:59
and then move on to inheritance and maybe get into a bit more interfaces.
2:05
A couple of things I wanted to mention before we get to that.
2:09
One thing is I wanted to make you aware of a scheme at Imperial College could undergraduate research opportunities.
2:12
I expect you'll probably have had an email about this, but I thought it was worth mentioning,
2:18
you know, as well as undergraduate research opportunities as a way for students,
2:21
typically between first and second year of their degree or second and third year degree, but not limited to those years.
2:26
To get a bit of experience of what it's like to do research by spending the summer,
2:32
working with an academic in the department on a research project of some nature might be at
2:36
applied research project involving some programming might be more theoretical research projects.
2:41
If you are potentially interested in going on to do a PhD or don't know if you're interested and would like to get a taste of what it's
2:45
like that undergraduate research opportunities can be a good way of getting some experience of what it's like to do academic research.
2:52
It's quite different from doing an internship. The main difference or our main differences, the pay is completely different.
3:01
You get paid a stipend when you do Europe, so you're not paid.
3:07
It's tax free, but the amount of money is pretty low. So don't do it for the money because it's potentially quite a cool experience.
3:10
But unlike an internship, you get to really kind of work with an academic and potentially get stuck into the sort of research they're
3:18
doing that might lead to being able to publish a paper with the academic on the outcomes of the project.
3:25
So quite quite a different thing from an internship.
3:29
I'm not sure personally if I'm going to take on Europe students this summer, and I think about that this weekend.
3:31
I know many academics in the department are so if it's if it appeals to you,
3:36
then I would suggest you go look at the web pages of the academics in the department and find someone whose
3:41
research interests you and drop them in email and ask them if they're interested in taking your student project.
3:46
The deadline is early February, so sometimes not that much time.
3:52
There's another thing I want to say to you regarding things like Europes and internships, which is.
3:56
It might actually be highly recommended to not do an internship or research placement during at least one or maybe two of your summers imperial.
4:04
I've noticed over the last several years there's been a bit of a culture where I think students.
4:13
So many students do internships that I think some students feel like kind of have to if you don't do an internship,
4:20
you're going to be less competitive. You're not going to have a successful career. It will set you back and.
4:26
I think we end up with quite a lot because it's quite difficult to get places. Congratulations to all of you on getting a place the imperial.
4:32
I think we have a situation where we have sometimes students who spent years and years being quite competitive at school.
4:38
Working can be hard doing exams and they come to imperial and the pressure is pretty high.
4:44
I'm sure you've noticed that there's a lot of deadlines, a lot of stuff piled on you and then you do like an internship in the first summer.
4:48
Then second year is really tough, then you do an internship in the second summer, then if you're in the third,
4:55
even industrial placement and then you have like a fourth year and then suddenly
4:59
you're whatever age and you haven't really relaxed since you were whatever age.
5:03
So I would despite advertising the scheme to you, it's potentially interesting.
5:07
I just wanted to say to all of the courses, do you seriously consider, especially if you can afford it?
5:11
And I realised for some people, an internship is necessary financially. But if you can afford it, you consider having fun with your friends,
5:16
going travelling, just spending some time, your parents place just chilling on it. So I think, yes, doing internships is fun.
5:22
Yes, it maybe does give you a short term competitive advantage in the very first job you get when you graduate.
5:28
Yes, I acknowledge that's probably true, but you're going to get degrees from one of the best universities in the world.
5:34
You're not going to have anything to worry about and the rest of their lives. And trust me, when you're my age,
5:40
you might look back and think you if you get to party a bit more or chill out a bit more when you are whatever you are on it.
5:44
OK, that's my run over. But yeah, with that. With that said, if you fancy a summer, do some research.
5:50
You consider Europe. Any questions about Europe, by the way?
5:56
Well, while I'm on the subject. OK, so.
6:00
At the end of the last day, I was doing a kind of rambling example about interfaces and lists,
6:10
and we didn't quite get to the end of example because some of you are some really good
6:15
questions about the differences between an interface type and an implementation type.
6:18
And I'm going to delve into detail on all that in the next couple of lectures,
6:23
but I just wanted to finish off the example and make a couple of points I didn't manage to get to.
6:27
So in the example, we had a number of lists, we had a list L1 list Alta.
6:31
List three of four and five and white showing you is that all of these variables are declared as list string.
6:38
What I was revising this just before the lecture,
6:47
I realised that in the demo last time I admitted to the string and angle brackets, which is actually old style java these days.
6:49
You always put the generic type when you're using in class like a list I've got list of strings are one.
6:56
And the point I made last time was that although we might make a new ArrayList,
7:02
you get a list or we won't make a new link list or we might call lists of to
7:07
get some kind of list or erased or as list or collections on modifiable list.
7:12
There are all these different ways of getting lists if on the left hand side of our declarations when we declare the variables,
7:18
if we favour using the interface type list rather than any specific implementing class type.
7:24
That means that the code, the variables we declare, will be compatible with any code that expects a list.
7:30
So they, by having the list interface type, have all of the methods of the interface available on them.
7:36
So code that needs a list to work with can take in any of those variables and is guaranteed that those methods will be available.
7:43
And we should only use on the left hand side of a declaration a more specific type like our list.
7:49
If we really do need to rely on being able to do things to that variable that are specific to that implementing class,
7:55
so I gave you the example of trimming an array list.
8:03
If we knew we really do need to trim this object, then we should declare it specifically as an array list.
8:06
If we just know is a list, we're going to make it be an array list and I maybe later we'll change our mind
8:12
once we benchmark our programme and realise that this will be more efficient.
8:16
But if we want to have that flexibility later than in all of our declarations, we should use the more general interface type.
8:21
So I made that point last time, but I didn't get to was I just wanted to run this code in the debugger.
8:28
So I'm going to set a break point here and I'm going to debug.
8:33
I just want to show you what we see in the debugger. So we just kind of.
8:38
OK, so the code has hit this line here now for the FAA to step over that line of code.
8:47
And we see we get an object L1, which is an ArrayList.
8:53
So what you notice there is that even though I declared L1 to have the type list,
8:59
the object that is actually created is in a radius because I said new ArrayList.
9:05
So L1 is referring to an ArrayList object in our programme.
9:09
We've said that we're going to view this as just a list, but there is no such thing as a plain list in Java.
9:14
There are all these different classes to implement list here. At runtime, we've got an array list.
9:20
OK. And if I have a few times, then L2 is a link list because I made a new list.
9:26
And some of those last time, what happens if you do list of what kind of list did you get back?
9:33
And I said I wasn't sure. I think one of your colleagues in the course noted the fact that you get an immutable list from a list of.
9:38
But I wasn't sure because I never looked. What specific kind of list you get?
9:46
Well, if we had to step over this line, then we see the three is actually assigned to at least triple correct collections dollar list.
9:50
And what that means is there's a cost called immutable collections and it's got an inner class.
9:58
We're not going to go into details of any classes in this class called list,
10:03
and so there's some special sort of list implementation that's come out of list.
10:07
And if we want to, we could go and read about that, but we actually did need to know the details of that, right?
10:11
Because actually, all we've depended on here is the fact that three is going to be a list list
10:16
are always going to give us some sort of list and we could use it as a list. We can expect that size, for example.
10:23
Yeah. Although, like some, some from the first as well, which functions like has a lobbyist for a massive fund, my Sylvester is.
10:29
Yes, that's an extra point. I'm going to come to that in a minute. My example for those of you who didn't hear the question or the comment,
10:51
it was that the list interface does have a bunch of mutating methods like ads, for example, and remove.
10:55
So what does it mean? Are they all of those available on an immutable list? And what happens if you call them?
11:01
So come to come back to that in about 45 seconds.
11:05
So if I go through here, you can see that collection is the unmodified list gives us an unmodified or random access list.
11:09
So there are these various different sorts of list implementations, but with high quality encapsulated code,
11:17
we try to avoid using information about the specific kind of list or set or whatever that we've got on the left hand side,
11:24
unless we really want to say I really need that kind of list for my programme to work.
11:32
It doesn't make sense for it to work in a more general list. OK, so to your question, is indeed true.
11:35
There are a number of operations that won't make sense on an immutable object, in particular operations that mutates the object.
11:41
So to see this in action? Why don't we try doing so?
11:49
Al.5 was a collection on modifiable list created an Al-Watan.
11:54
So this is wrapping up our one in a form that says you can't modify it.
11:59
So what happens then, if we try to add something to L5?
12:03
If you say L5 adds a law, right?
12:07
Well, the code does compile the code compiles no problem. The reason it compiles is that all five.
12:12
Does have type list. And this does have an ethical add, so that method is available.
12:20
It does exist. And if we run the programme, so if I could play, what's going to happen?
12:28
Is that going to get an exception when this line of code is executed?
12:34
To that run. To.
12:40
It's happened. To avoid making this big enough for the lecture, the lecture is that sometimes it becomes difficult.
12:49
So I was looking for. Yeah, OK. So here you can see I got an exception.
12:59
In unmodified on modifiable connexion, and so the ad operation was available on the list because it was an on modifiable list.
13:06
The operation through an exception. Now that might not seem very nice, like why have an operation available if it's not really available,
13:15
if it's not truly available and it isn't that nice?
13:22
But if we could go and look at the list interface and say, if I control, click on list, let's look for ads.
13:24
OK. This is incredible because this is the compiled code, but I think if we would Google say for.
13:37
Their job just to face.
13:45
And we look for that and method. And you can see that this is an optional operation.
13:51
It's a bit larger. You can see this is an optional operation.
13:58
OK, so across the implements and interface, if the interface has optional operations,
14:02
what that means is you do need to provide a body for those methods.
14:09
But if you have documented that you don't actually support them, it's OK for you to throw an exception.
14:14
So what this means is that you, if you misuse one of these, if you misuse it, immutable list of percentages mutable.
14:19
Unfortunately, your code will compile in a nicer programming language with a more advanced type system.
14:26
It'd be good if that could be avoided, but in Java, the Kobo Compile.
14:31
But at runtime you get an exception because you didn't read the documentation properly and you ended up adding something to an invisible list.
14:34
At this. It's the first thing you said if they didn't implement it, still,
14:42
if they didn't provide the body and the compiler would complain and say that the
14:57
class on modifiable list does not provide the add method required by the interface,
15:01
so they do provide the method and will all the method would do would be throw an exception, say, unsupported operation exception.
15:06
OK. Right. So having got through that, let's go into the next set of slides that references and immutability.
15:13
And I'm going to present. So I do want to apologise for the fact that we have this, this Zoom thing up the top here for various reasons, it is much,
15:22
much easier for me to teach from my Linux laptop where I don't have to depend on other people getting things right, any mistakes on my own.
15:43
But Z1 Linux is a bit rubbish, and there doesn't seem to be a way of getting rid of this thing.
15:52
And of course, it goes right across your titles of your slides. Do what you have to slide, so hopefully you can figure it out.
15:57
All right. So what we're going to talk about here is a bit about how memory is laid out, what a Java programme runs.
16:03
Conceptually, I'm not going to go into details of exactly how the physical memory works.
16:09
I want to talk conceptually about where memory is allocated, and I want to talk about the difference between reference types and value types.
16:13
A little bit about another pointers.
16:20
I want to say a bit about garbage collection, and there's some study in your own time slides about immutable objects.
16:22
So I just want to remind you that in Java, every variable is typed and variables are stored in the programme stack.
16:29
So when you have a function, when you have local variables, those variables are stored on the programme stack.
16:36
And if the function calls another function, a new frame is pushed onto the stack.
16:42
The space for the variables of the new function. And if that function goes, another function that grows.
16:46
And in Java, there are two types of variables. There are primitives into the small I or char.
16:52
And then there are reference types like classes that you create.
16:58
So for these primitive types, the values are stored on the stack or the storage directly inside objects.
17:03
And Java has a fixed number of these primitive types. You can add some new primitive types to your programme.
17:10
And then in contrast, you've got reference types,
17:17
classes like circle car lecturer or classes that come with the Java language like string, for instance.
17:19
And when we declare something of reference Typekit one of your methods.
17:26
A reference is stored on the stack and it points or refers to an object stored on the program's heap.
17:31
OK. And the great thing about reference Typekit is that you can write your own courses to extend Java in some sense
17:39
with more and more and more of these reference types to support the needs of the programme that you're writing,
17:47
so. Well, I want to go into it and kind of detail that is that is what it means to have a reference to an object.
17:53
So the way I like to think about the reference, a reference to an object is is some memory called the heap and an object actually lives in the heap.
17:59
And a reference to an object is the address of that object in the heap.
18:09
It's the position in the heap at which that object lives.
18:14
And the reason I like that mental model is that it lets me think about a reference as being just a number.
18:19
So when I write down string s, for example, then you might think X contains characters, but really there's a string object on the heap.
18:24
An X is referring to that string object, and that object will live at some memory address like one million six hundred twenty seven.
18:35
So s reading has got value one million six hundred and twenty seven and it's got type string.
18:43
What that means is if we want to look at the string, we have to do to memory address.
18:50
Remember, I said that one million, six hundred twenty seven and then we'll find the data there and we can go and look at the characters in that story.
18:55
That's personally the way I like to think about references versus objects.
19:01
The object is the real memory, and a reference says where that memory is,
19:06
so you can think about a reference is being a little bit like a remote control is to a TV.
19:12
You can use a remote control to make a TV, do things. You can send it messages, you can probe it, but it isn't the TV.
19:16
So a reference is not the same as an object. Reference gives the location of an object.
19:24
If you know the location of an object. You can do things to that object, but the location of an object and the object a different things.
19:30
So in Java, we always interact with objects by references to objects we don't ever in.
19:38
Java have an object on our programme stack. Objects only live in the heat, and we have references on the stack that point into the heat.
19:44
This is different to some programming languages, C++, for example, is different in this regard.
19:53
It allows you to declare objects on the stack and that leads to some high efficiency,
19:58
but at least to some security problems, java as a more secure language by only having objects on the stack.
20:03
I would go into the details of why that is OK.
20:09
So if you've got a reference to an object returned by the new operator and we can store that in a reference variable.
20:13
So to give you a concrete example, if we say here, circle my circle and then we say my circle becomes a new circle with a red radius for,
20:21
say, and this declaration circle my circle that does not create an object.
20:32
What that does is it makes it bearable on the stack, and that variable is capable of holding the location of a circle object.
20:37
But my circle is not a circle object. It's a reference to a circle object.
20:48
Now in this lecture, I'm going to be very pedantic and talk about a reference to an object versus an object.
20:53
When we speak informally about programmes, we often say. Circle, as if it were an object, you might say, Oh yeah, my circle is a circle object.
21:00
What we really mean is my circle is a reference to a circle object. It gets quite cumbersome to always say that.
21:09
So once we kind of know what we're talking about, we can be a bit lazy and say, Oh yeah,
21:15
I just declared an object when really mean I have to cut a reference to an object.
21:21
But in this letter, I want to be quite picky and correctly talk about an object living on the heap
21:25
versus a reference to that object living on a stack and pointing to the object.
21:30
OK. So then when we say my circle becomes a new circle,
21:35
what this does is new causes the memories for a circle object to be created on the programmes heap,
21:40
and then the address of that circle object is returned and it's stored in this reference variable.
21:47
My circle? So once again, circle my circle, it just creates a reference variable on the stack is capable of referring to a most one circle,
21:53
and it does not create the circle object. OK.
22:07
And then when we do that, the new that's when the circle actually gets created and a reference variable either
22:12
create either contains a reference to an object or it contains a special value for null,
22:19
which means no object. This reference is currently not referring to any object when a reference is null.
22:24
That means you can't do anything with it. You can't call methods on it because there's no object on which to call those methods.
22:31
So it's a bit of an exercise to try and make these points clearer. I am going to draw the stat and the heat for the bit of code here as it executes.
22:39
No, I believe this is the board. In fact, it's the only board.
22:53
The other ones going.
22:57
Few folks being online, I hit the preset to give you the whiteboard, can someone just confirm that things are zooming in on the whiteboard?
23:04
I can't see your view. Yeah, it is. Okay, so there's no excuse to turn off one of the predictions and we're going to draw the second.
23:10
And do you feel free to shake up the questions while I go through this? It's quite important to understand this.
23:22
OK, so the programme stack them. We're going to do it here.
23:29
And I'm going to draw the stat going growing upwards. Some authors draw the stat, going downwards doesn't really matter.
23:40
It doesn't matter if you're actually talking about the way an operating system works or the way our compiler works.
23:47
But these diagrams, I'm going to give you a conceptual idea of how objects are being laid out in memory.
23:52
So specific details that matter too much. OK, and then we got a heat.
23:58
So he. Is a large portion of memory.
24:04
Well, I object to going to. OK, so what does our programme do first?
24:09
It does in a becomes a call to tech. So what kind of a type isn't?
24:17
Primitive, very good. OK, so if this is in the body of some method or declarations are going to live on the stack.
24:22
So what happened here is we'll get some space on the stack for a.
24:30
And A is going to have the value 10. And what I'm going to do is I'm going to note here.
24:36
A, isn't it OK that that information isn't actually stored inside the stock, but the compiler compiles the programme in, the compiler knows.
24:45
OK, that's the acquisition is going to mean an integer. There's a value 10, which is just some binary.
24:57
The binary could be interpreted as a floating point number. Or is it integer or something else in the compiler is going to know, right?
25:03
When I look at that, I should interpret it as an integer. OK, then the next line of code Circle C becomes equal to a new Circle Red three.
25:08
So what this is going to do is it's going to the new it's going to lead to a circle object being created on the heap.
25:18
So we're going to have an object. And I'm going to use this notation for objects where at the top we do.
25:24
Colon. Typekit, if you want to before the coat on, we could give the obvious name.
25:33
I'm not going to bother giving this object a name here.
25:38
So we've got a new circle and that circle is going to a couple of fields, so it would have a colour field.
25:41
I'm going to be all American instead it room. And it's going to have a radius field.
25:48
And the colour field is going to be red. And then the radius field is going to be through.
25:56
So this is memory allocated to them. And then on the stack, we're going to have a Circle C reference.
26:05
So we would have to see. And. This is going to have tight circle.
26:15
This is a reference capable of referring to a circle.
26:24
And when that new operator returns just in just a moment when the new operator returns on the second line,
26:27
it's going to return the address of that circle. So let's just suppose this circle.
26:33
Got allocated at some memory address like O X, A B C D one two three four two somewhere in memory.
26:41
This circle got created. That number there that I've rated hexadecimal is just an integer.
26:51
All right, it's the integer memory, OK? The integer memory allocation where that object starts.
26:57
So really, all this happening is that that variable in the stock gets that value of x a b c d one two three three four.
27:02
But annoying to write down these two if we draw these diagrams,
27:16
pretty annoying to make up these numbers and have to look and be like, Oh, is that number the same as that number?
27:20
So what we typically do is you don't bother writing down some kind of fictional address.
27:26
What we typically do is we just. Pretend there was an arrow.
27:30
From here saying. That variable C refers to this object.
27:36
But if you're ever confused about what does that mean,
27:44
one way to rewrite them is to wherever there was an arrow from a set on the heat on the stack to an object and heat.
27:47
You could instead give the object on the heap some integer location and say what the
27:54
variable of the stack has that integer as its value and the arrow doesn't really exist.
27:58
So I find the different students prefer the different mental models.
28:03
This kind of abstract model of this refers to that circle versus this has this memory location as its value and the memory location is here,
28:06
and that's where the circle is. OK, your question? But.
28:14
So Radius would be an right, so radius is perimeter tight.
28:27
How do you make the point that the colour is a straight and a string is not primitive? Yeah.
28:31
Very good. Thank you. Yes, that's actually exactly what I wanted to get into next. So when we draw these object diagrams,
28:35
it's quite convenient to pretend strings are quite common and they're very common and examples that lecturers get to classes.
28:40
So it's quite common to pretend that we've got actually the data read inside this inside this object, but actually a string in Java is an object.
28:46
Right? So really, what's happening here is that there's going to be another object, the heap.
28:55
Of type string. And actually, this colour.
29:03
It's going to be a reference. So that string object and that string object is going to have some data inside it.
29:12
OK, now what is data? Well, data is actually going to be an array of characters Natera's objects in Java.
29:22
So actually, we don't have the data inside the string.
29:29
What we really have is an array. Somebody said we've got a chore or.
29:33
And it's going to have some data values. Which would be the character or character?
29:42
Character, the. So that's a bit cumbersome to write out, hence, when we draw these diagrams, we might often just write colour because read here.
29:52
But it's important to note it really a string is an object. And actually, the data is stored as an array.
30:02
That's another object. So we would draw that the stack and the North bit more faithfully this way.
30:06
So let's just dissect the first two lines of code. OK, so now let's carry on into a B equals new into three.
30:13
So how many objects are going to be created by that line?
30:19
Just shout out, you can shout out front line. So I'm talking here about the third line or B because of size three one one, right?
30:25
Why one? Why not for? Because it isn't an object this would directly in.
30:36
Right? Yeah, that's kind of correct. I mean, it's true.
30:46
It isn't. It isn't an object store directly in the array. Yeah, that is true.
30:50
And I'll explain why I said kind of in a minute. But what's going to happen here, then, is we're going to have on the.
30:56
On the stock. Be. B is going to be an entry into the heat.
31:03
That's going to refer to some object of type into a.
31:12
And that data, the data inside that. Is going to be zero zero zero,
31:18
so Java is a nice language in the sense that all data gets initialised and jumping on initialised data is always default,
31:25
that these things get initialised. So in some languages, if you just declared an array of integers,
31:32
they would just be garbage that there would be whatever had already been in the memory before.
31:37
That would be the case in Java. Yes, please. Yes.
31:41
Maybe it would be. I just made up the name data is a field name.
31:52
Maybe I'll call this contents.
31:56
But in Java, a string is an object, and the object is implemented by having an array of characters and that array of characters is another object.
32:00
So the string object has got a field that is an array object.
32:11
Does that make sense? I don't think probably a bad idea for each of these data placements.
32:15
OK, so here we have our integer array three. Now we've got an array D. That's called the values one three five one three five seven nine.
32:21
So it might look like no objects to get to that right because of this.
32:28
These are curly brackets that's got that's what we call an array literal.
32:32
So it might look as if we're only using primitive stuff that is an array of primitives that has got that value,
32:36
but actually that curly brackets one three five seven nine. Let's just syntactic sugar for making a new array and filling out.
32:41
So what will happen when we do this is will end up getting. Another Interreg.
32:49
On heat. And it will contain one one, three, five, seven, nine and on a stack.
32:57
The. OK, so next stop.
33:08
Circle of circles equals new circle.
33:15
Three. So how many circles is this going to create?
33:19
Zero. One. Yeah.
33:26
Zero. OK. No, sir, because getting creative it was getting created is an array capable of storing three circles.
33:32
Is that true? No. OK, because we're going to be really, really annoying in this lecture.
33:42
All right. So it's an array capable of storing three of.
33:50
Yeah, references to circles is the answer I want to hear,
33:56
but I think addresses or I heard various various correct ish things that but three references two circles.
33:58
OK, so what's going to happen here and is that the new Circle three or the right hand
34:05
side of the fifth line of this example is going to cause an array to get created.
34:11
In memory, you're a tight circle. All right.
34:18
And it's got the capacity to refer to three circles, OK, which circles is it going to refer to when it gets created?
34:25
Second. Yet nothing is going to refer to no circles and therefore the value the contents will be now so.
34:36
No, no, no, no. And it's almost certainly the case that in any implementation of Java, null will actually be represented by the Integers zero.
34:47
Remember, I told you that references are just you can think of the numbers. We had a number that ought to be that address.
34:57
So null will in effect be the number zero, but it's best not to think of knowledge zero.
35:03
Think of the absence of an object, so no object is preferred to know object is referred to.
35:09
No object is referred to it. OK. And then on the heat we have got.
35:15
Circles. Sorry, I'm a that. You've got circles. Circles is going to point to decide which way to do this arrow, isn't it?
35:22
OK, now things get sort of interesting when we say that Circle's entry zero becomes equal to see.
35:35
What does that do? Does that create any more circles? No.
35:45
OK, so what is it? What is it doing? But.
35:48
Refers to see. Yes. Yeah. So see is here, right?
35:55
So what's it going to do like to create an IRA? Like that?
36:01
No, OK, so. To the circle itself.
36:08
So. Right.
36:14
So I personally find it helpful to use the kind of integer notation here.
36:24
So see, that is our reference, and it refers to a circle, it refers to this circle.
36:28
So that is not normally an IRA that that's really a number, which is the address in memory of that circle.
36:35
So let us pretend the that had address one two three four five six the silly address, but it doesn't matter.
36:41
It's just an example. So really, we've got the value one two three four five six.
36:49
So actually, when we say Circle zero becomes, you could see what that's saying is copy the number from see.
36:56
Into. Circles zero. So it's saying replace that no with one two three four five six.
37:04
That's all this happening. It's like an integer move, it's just saying move, whatever integer value is in C into this memory cells on the heap.
37:17
But what that means in terms of our programme, more conceptual level,
37:27
it means that actually now this reference is referring to whatever object is at that address, which is that object.
37:30
So it's like we've ended up with a draw from inside the ended up with an arrow.
37:38
So this object. And we typically wouldn't put these numbers in, it's quite kind of cumbersome.
37:45
But I just wanted to use it to illustrate the point. OK.
37:52
And then if he did string e equals two, then we would have to be up here pointing to a new string object,
38:02
which would point to an array of the data for the string. I'm not going to draw that out here because the first.
38:12
Yeah. So I suppose if I wanted to actually set circle zero to an object that looks just like sea but is actually a completely new in memory,
38:23
so another circle, a distinct circle that has got colour red and it's got radius three.
38:38
So I mean, one thing I could do is I could write here. So zero equals new circle red three.
38:44
But I presume that's not what you meant. I presume you mean what? I want it to be like a carbon copy of C.
38:49
So that would depend whether Sea provided a way to create copies of itself.
38:53
So Sea might have a constructor, sorry. It would depend where the circle contained a way to make copies of itself.
38:59
So Circle might have a constructor that takes another circle as a parameter and then uses that circle to fill itself up.
39:05
But filling itself up with cloned data or circle might have a clone method, does it?
39:13
Interface in Java, which I'll cover very briefly near really the end of my bit of the course,
39:18
but also it might be that Circle would enable cloning, but in Java, there's not a standard way to do that.
39:24
It's not the case for an arbitrary cost. You can just make copies of that cost.
39:29
And that's basically a good thing because often that shouldn't be allowed.
39:34
It often doesn't even make sense to do that.
39:38
And whenever you copy something and we'll come, we'll come to this debate later in the course and there tutorial questions on it, too.
39:40
Whenever you copy something, there's always the question of how deep you should go with the copy should you be copying.
39:46
Every field or should you be deeply copying all the fields of all the fields of all the fields,
39:51
all the fields, and what should you do if you've got an object with cycles inside it? How should you deal with that?
39:56
So typically it's better not to have a default in the language of force, the programme or to actually programme what they'd like to happen.
40:00
I think even next year. Well, the it's written down in your programme, and when the compiler compiles the programme,
40:08
it needs to it needs to use that information to best effect.
40:23
So some of that information will be stored in the Java bytecode. Some of the information the the Java bytecode will have been built.
40:26
On the basis that that information is correct and would exploit that information by construction, but the information may be gone.
40:35
So when you when you look at assembly code or bytecode, you often see offsets like go 60 bytes from here or 128 bytes from there.
40:41
And that kind of stuff will have come from types in the programme and knowledge of how the memory specifically meant to be made at the.
40:51
Well, that's because the programme that there will be debug information in the Java by code.
41:02
And similarly, if you programme in other languages like C, for example, a C++,
41:07
you can easily compile your programme in a special way so that information about what the source
41:10
code of the programme really meant is carried in that level of representation of the programme.
41:16
Actually, despite having to use Java huge tonight, I very rarely had to look at Java bytecode,
41:21
which is actually, I mean, maybe that's not great from a computer science perspective,
41:27
but it's great for myself and your perspective in the sense that it's a sort of
41:31
triumph of the language if you really need to know exactly it has implemented.
41:34
So I don't know exactly what type information is coming around in the Java bytecode.
41:38
So there might be it might be that intelligence already got whatever it needs from standard Java bytecode.
41:42
Or it might be that when you combine and debug mode,
41:48
some special symbols are added that allows the idea to reverse engineer information about the source.
41:50
OK. It's another question for.
41:57
At the end of the pool, those lines you see on TV.
42:05
Yep, yep. You got that right, you get one change.
42:10
Right, it's all right. So the question was if we did see a change radius 20, for example, what would happen?
42:20
Would it be that we would see 20 Aceh's radius, but we'd see something different if we looked at Circle Zero's radius?
42:30
Or would they be the same?
42:37
Well, if we do, if we did see Change Radius 20, what would happen is that we would be saying, OK, well, where the sea referred to it prefers here.
42:38
We did change that number to 20.
42:48
And hopefully that now answers your question in the sense that if we now look at Circles Zero's radius, we would go, What is circles?
42:53
Is this array? What's it, zero Taliban? It refers to this circle.
43:03
What's its radius? Trintignant, and that's called aliasing.
43:07
We've now got multiple names for that bit of memory. Quite a bit of memory, we can call it siege radius, or we can call it circles zero dot radius.
43:12
So it's like having an alias, just not very curious.
43:24
But still, there are two names for that.
43:27
And you can end up changing, you know, when you change about memory change, will all the names for that memory see when you use them?
43:31
OK. I think I'm going to crack on then. I have a question on. Please.
43:40
When you have to circle away just full of nails with those nails, the actual memory locations?
43:44
No, they would be they would be a special value, meaning no object.
43:50
And as I briefly mentioned, it's almost certain the implementation of Java, they would be the value zero.
43:54
OK, thank you. OK. Good. All right.
44:01
Let me give you back a view of the lecture theatre if you're online and certain projects that go get rid of this board.
44:09
OK, so I hope that was interesting and instructive, giving you some more kind of idea about how to think about what your programme is doing.
44:18
And if you get a programme where you're having weird effects, where things are values of objects changing in ways that don't kind of believe,
44:24
then it might be good to do it exercise in drawing what the stuck in the heat looks like.
44:30
OK. No, you was quite careful with the assignment operator in Java due to this problem of aliasing.
44:38
So for primitive types, the assignment operator equals operator copies values.
44:45
So, for instance, say we had a function that took us with value 256 so it would live on the stack and would have a value 256.
44:52
And then if we says Jay is one, then we'd have another static variable.
45:01
And then if we said Jay becomes you go e, I would overwrite the value of J with the value of E!
45:05
All right. So Jay would become one two five six before, after, before, after.
45:10
So that's very straightforward, it's what we'd expect.
45:17
And if we increment J then J becomes two hundred fifty seven, a naturally there's been no effect on E when we increment to J.
45:20
But with reference types, the assignment operator copies references, it doesn't make a new object.
45:29
It just copies references.
45:36
So for example, if we had to call objects like I've got a Blue Dog, if you've got a red mini, you could decide which you prefer.
45:37
But let's say we have these cars, then what we can have is something like this on the stack.
45:46
That'd be my car and your car, which both car references. They're capable of referring to a car object on the heap.
45:53
We'd have two different course, right? We have the Red Mini and the Blue Golf, and currently my car refers to the Blue Golf.
46:00
Your car refers to the Red Mini. But now if we say your car becomes equal to my car.
46:08
Well, what that does is it just copies. You can think about that just being a no, that's a no, and it refers to that object's location.
46:14
That's a no, and it refers to that object's location. So just like saying Jay becomes equal e copied the value of E into J.
46:22
If we say your car becomes equal to my car, that's just going to copy the value of my car into your car,
46:30
which in effect is going to just mean both my car and your car refer to the same car.
46:38
So this is an example of aliasing, which you spoke about. I mean, so there are two aliases for that object.
46:44
There were two names for it. We can get at it through my car. We can get at it through your car.
46:50
If you think about the TV remote control analogy,
46:55
it would now be like two people that maybe two of my children have each got a remote control for the same TV and that horrible things could happen,
46:58
right? They can start to change the channel, and they're chaotic enough without that happening.
47:04
So I'm glad that's not the case.
47:10
But yeah, it could be quite annoying now if we've got two aliases for this object, and sometimes this is exactly what we want in a programme.
47:11
Sometimes it's not. The important thing is we understand this concept. We understand that if we do, your car becomes good.
47:19
Go to my car. It doesn't mean that now there are two really golfs, right?
47:25
There's still one bleep golf. It's just the two of us think we own it.
47:31
So now if you take your car reg, my cars also become red as well.
47:35
So this is something to be aware of and be careful of when you programming.
47:43
And one of the reasons that we generally like to use immutable objects when we're programming
47:49
as much as possible is that aliasing does not matter a jot if objects are immutable,
47:55
if objects are immutable, then there's no way to cause havoc by changing an object.
48:01
Many different references are referring to. You can't change the object if it's immutable.
48:06
So one of the big selling points that immutability is, you can avoid aliasing related bugs in programmes.
48:11
This piece is the only way to make a new copy of Guess that comes back to the question that your colleagues wrote with The Circle.
48:17
If we wanted to make, if we had that red circle, could we say I would like, I would like a circle to be a different circle?
48:24
That's also right, and it's the same radius. So here you'd be like, is there a way to make another car?
48:32
That's got it? It's also a blue bolt or remedy. So no, by default in Java, there's not a built in way to just make.
48:35
Another version of an object. What if you wanted to make it possible in a closet you implemented?
48:43
If you wanted to make it possible to get a clone, then you could provide a method that provides that functionality is not there by default.
48:49
There is something a bit confusing in Javier's interface called Clonmel. And.
48:57
That provides a way of doing clothing, and I'm going to talk about that.
49:05
Yeah, very briefly, a lot later on, it's a bit nasty and I'd advise you to kind of stay away from that, so I won't go into details of the Riner.
49:09
OK. So, yeah, as I mentioned, this business of two references referring to the same thing is called aliasing, and it can be problematic.
49:19
It's not. It's not wholly a bad thing. Aliasing is often exactly what you want to be happening in the programme.
49:27
For example,
49:33
if you think about social media network that you can have a graph right where there are going to be connexions between the graph and if, say,
49:34
two of you have got a friend in common,
49:41
you really do want it to be the same friend that wants to have copies of the frightening comment or your friend's changes that profile.
49:42
You don't want to become a new person. I mean. So not everything can be immutable, but we do need immutable things in the real world.
49:48
But if you can use immutable objects where they work, then you may end up saving yourself from some aids related heinous.
49:56
Now, something is quite annoying about Kottmann, is that Colin?
50:07
Introduced this equals equals equals operator, I don't know why in the sense that I understand why they might like.
50:11
I don't know.
50:18
It's like when people designing a language, they go, Let's fix the fundamental things that make our new language better in fundamental ways.
50:18
And then they also go to the wall.
50:25
I've never liked the way ecosystems equals in Java means this thing that millions of Java programmers know it means.
50:26
Why do we make it mean something else in our language? OK, so in in Java?
50:32
Well, let me tell you that, Colin, because you know, Scotland, right,
50:40
so and Scotland you've got a method called equals is a programmable notion of equality on objects.
50:42
And in Scotland, equals equals. A short time fiddle equals syntactic sugar dot equals.
50:50
OK and then improvise to separate the good equals equals, which is called referential quality.
50:57
It actually says, did it are there's reference is the same number. Are they referring to the same objective memory?
51:04
I mean, Java. This equals equals equals doesn't exist and Scotlands equals equals equals is job equals referential quality.
51:10
Now I've not studied it in incredible depth. So maybe there's a really good reason for this change.
51:21
And I'd love to hear it. But for you, poor souls who write in both languages, you just have to actually really know what these operations mean.
51:27
However, unlike in the unlike in the case of, say, knowing which strings turn into billions when you give them to the constructor of do oblivion.
51:37
And I said, I don't learn that that's kind of crazy knowledge.
51:46
You wouldn't really ever want to use that knowing about equality of the programming language is extremely important.
51:48
So whatever language you learn will have its own notion of equality that's saying,
51:54
like these, these two references are the same value or these two objects.
51:58
But if we respect the field by field maths, there will be those notions of equality.
52:03
Whatever languages you use, they will be subtle and you do need to learn them and understand them.
52:07
So that's something where I think experts were somewhat encyclopaedic. Knowledge can be very valuable.
52:11
OK. So yes, like I said at the bottom that when you're working in a new language, don't try and guess how these equality related operations work.
52:16
Go and read the documentation and actually check that they know how they work.
52:25
Right? Let's take a 10 minute break and see you after that. OK, so the recording has resumed, I'm sharing a present.
52:30
So I mentioned that and Colin and Java,
52:51
these operators equals in Tripoli calls mean the same thing in the sense that Tripoli was in Scotland is what double equals is in Java.
52:53
And annoyingly, Scotland is got its own equals, which is a bit of a pain.
53:06
So you need to remember that there is a difference.
53:10
And then you need to be careful about this equals equals comparison of rights when you're programming in Java.
53:13
And similarly, be careful with the equals for primitive types.
53:21
It compares values, as you'd expect.
53:26
So for example, if you've got A B, C and D sorry, a B and C with the values for four and three, then eight equals equal.
53:28
B will be true. Eight equals equals c b false eight equals equals four will be true.
53:35
Very straightforward. Well, with reference types, what it does is it compares references, so suppose we have this example of cars, right?
53:43
My car, your car. So. Let me use the board again for this or to switch to that preview.
53:51
So there's video online. OK, so if we got that on the stack.
53:59
My car. Your car?
54:08
And our car. And if the heat.
54:15
You've got to call objects, right? We've got a blue.
54:21
Yes, to. Adhir, be lazy and just using strings as if they lived inside the object.
54:28
Remember, radio string is another object. Etc., etc. and another.
54:35
Blue. Yes, sir. So you might you might wish that.
54:41
Those cars should be regarded as equal if you wanted, you could provide for car costs,
54:51
you could provide an implementation of the equals method that will actually compare colour and compare.
54:56
Model. Six ominous. For the sake of your colleagues online, let me investigate.
55:04
OK, I'm going to. Exit Zoom. Oh, I think the wi fi is gone.
55:31
A nine. I return to my service.
55:56
Not. And it works.
56:12
We're back. Typekit panel.
56:34
Five video panel. OK.
56:50
So where was I? Right, right. So we got these two cars that different objects of memory, so.
56:57
Right. So let's suppose that my car is one of the blue fiestas, say this one and then your car is the other big fiesta.
57:12
And then there's this time in our car becomes a go to my car.
57:24
So what that does is it copies the value of my car into our car.
57:28
So that's a number of correspond to that object. No number gets copy there.
57:31
So conceptually, now we've got an IRA. OK, so now I'll come to you just a moment.
57:35
So now the question is Michael equals equals your car.
57:42
True. Well, what this is doing is it's just asking is the integer value of that reference the same as the integer value of that?
57:47
So is that true? My car, your car? Right? Well, did you refer to the same object?
57:55
No, they don't. So my car equals equals. Your car is false. Is my car equals equals our car.
58:00
Well, my car, our car. They both refer to the same object, so that equals equals operator to true on them.
58:07
So it compares the values of the references. It doesn't compare details of objects.
58:15
They refer to you to your question. But. You mean industries with a capital, I.
58:19
Yeah. So with an integer class, you have this.
58:31
No, I mean, if you make two different integers, why do we see an example that needs to be quite careful with that, right?
58:36
So in Java, when you used a new keyword?
58:43
You always get different objects back. So if I say integer I one equals new integer.
58:49
Three, for example, an integer. I, too, was new integer three.
58:56
I'm getting a warning saying it's my practise to use that constructor. You shouldn't really do that.
59:03
You should rely on the compiler to do what's called auto boxing.
59:08
Say, I did do that and I.
59:13
Just give myself a line to get to if I set a break point here and debug the programme that I want and
59:22
I was certainly going to be different objects is not possible in the new to return same memory twice.
59:28
You can see here that we've got integer at seven six five seven six six.
59:35
That's not literally saying memory allocation. Seven six five. Memory allocation seven six six.
59:40
But it is an indication is that it comes from a hash of the memory address.
59:44
So this is showing us that those introduced really live at different locations. Now, if instead.
59:48
I do. In Coast three in ITV Coast, three,
59:55
I'm pretty sure that the Java compiler will actually rely on the fact that integer is an immutable class and it will only make one object.
1:00:00
It's got the value three, and it will make sure that both I and you refer to that object. And so if I.
1:00:08
If I do that here, then indeed, you can see that both of those objects. Both these references refer to the same object.
1:00:15
But that's something that's a bit dangerous to depend on there, really.
1:00:21
If you are comparing if you're comparing object references, really only use equals equals.
1:00:25
If you really want to know, are these the same object? You're not interested about the values and sides when there are the exact same object.
1:00:32
OK, so if I go back to the slides, then here in this cause example, then my court equals equals.
1:00:39
AKA is going to return true. Whereas evaluates drew worse my car,
1:00:46
because your car is going to a party with a false regardless of the fact that the data stored inside those car objects looks exactly the same.
1:00:52
So that's an important thing to be aware of. And this is an example that relates a bit to the question you just had about integers with strings.
1:00:59
So strings are objects.
1:01:06
OK, so suppose I do something like this on the left hand side, string s is the string hello string is the string hello return equals equals team.
1:01:07
So this is going to return a Boolean. And here I do string as equals equals hello, string u equals sorry, string x becomes equal,
1:01:17
hello string u becomes a go [INAUDIBLE] and then string t is you can catch it with low and then evaluate 616.
1:01:26
So. Hands up, if you think that you're going to get the same answer here and here, like both of them going to be true or both, I'm going to be false.
1:01:36
A couple of you know, and I mean, I'm sure probably a few more of the might have heard what it had,
1:01:48
I not asked it in the sense that I'm probably going to say that's not what
1:01:53
happens because I'm going to make a point about the language being a bit tricky,
1:01:56
right? So that would seem reasonable. But it's not. It's not true.
1:02:01
Actually, it so happens that the way the Java compiler is implemented, it looks through your programme text.
1:02:03
Whenever it sees literally the same string in multiple places, it goes, OK, what strings are immutable?
1:02:09
So actually, I can make one copy of that and wherever it's used literally in the programme, I could make it be that object I've made.
1:02:14
So at the beginning of the programme starts, it will it will make a whole lot of these strings.
1:02:20
There's a whole pool of them and then it will go OK by S.A. They're both going to refer to the object that's got the contents.
1:02:24
Hello, that I made. And it would also make objects for Hello, [INAUDIBLE] and low in this example.
1:02:30
But you would refer to how and this would be kind of, you know, anonymous piece of memory that really gets used in this concatenation.
1:02:35
And we're going to end up with different objects so these strings refer to.
1:02:43
So actually, on the left hand side, it's so happens will get true because if a compiler optimisation that means the SNC happens to refer to
1:02:47
the same object or the right hand side will get false because that optimisation doesn't get applied.
1:02:55
OK. So basically, you shouldn't use equals equals on reference types unless you really want the check to be.
1:03:00
Are they the same object? That often is what you want? Right?
1:03:08
Quite often is. So, for example, in a computer game, some entity might have a reference to a particular game world object,
1:03:12
and there might be another game world object that happens to have all the same state as the first game out of it at some point in time.
1:03:21
But we might really want to say these players on the same world. We don't mean, are they on equivalent worlds?
1:03:27
We mean, are they on the same world? And then we really would want equals equals.
1:03:31
But if you wanted to see if you want to say, have I seen a person with this name,
1:03:35
address and age before then you might be saying a of all the objects of people I've seen before.
1:03:41
Does this object look the same then you wouldn't be asking, is it? Is it one of the objects you'd be asking, does it look the same?
1:03:46
And then you want to use dot equals to compare fields? So later in the course, we'll come onto ways implementing object equality.
1:03:51
But I just wanted to make the point early.
1:03:58
To be quite careful with this equals equals operator in Java generally and be extra vigilant because it means what Dot equals mean.
1:03:59
So use it as if it were Copland's operator. OK.
1:04:08
So the next point I wanted to mention was object references, his parameters.
1:04:14
So in this example here. We make a new car, a blue fiesta, and we call this a method, get sales value.
1:04:20
We pass in a reference to the car to get a value how much that car is worth and the car was blue.
1:04:28
So if we then say is my car's colour equal to the string blue?
1:04:38
Let's assume that get caught, it does return. The string represents the cause of it.
1:04:45
So we made a blue fiesta. Is it possible that we could end up printing this message?
1:04:50
Hey, somebody painted my car. So what we've done is you've made a car.
1:04:55
Let's assume that these dot dot dot goes down for anything consequential to some innocuous code.
1:04:59
We ask How much is the car worth? We get no back. And then we say, Is the car still blue?
1:05:05
And the answer is no. Is that possible? Yeah, so why is that possible?
1:05:10
Right. Which method in particular? Maybe get sales out of you, right?
1:05:22
So what we've done when we've passed my car and to get, say, a value,
1:05:28
it's like we've given gets our value, a handle to the car, we've given it the remote control to the TV.
1:05:32
We've said, here you go, there's the car. Is there a memory? Do what you want with it.
1:05:39
OK. And if we have poorly encapsulated car thieves, we've made the colourful public.
1:05:44
And if we can, if we've made car mutable so the fields can be changed.
1:05:51
And it's definitely possible that that same value, if it's been poorly implemented, could end up mutating the state of the car.
1:05:55
So yeah, we could have something silly like this so that you could set the cars colour to red and then return somebody.
1:06:05
So, yeah, the point I want to make here is that if you don't use immutable objects and if you don't obey encapsulation,
1:06:14
then when you pass objects around to methods, those methods can do arbitrary things with those objects.
1:06:21
So that's why it's good not to use public fields to make there be scope for your or someone else's code to misuse your objects.
1:06:27
And it's why it's good to use immutable objects, but you can't.
1:06:35
OK, so you might be able to get around this by, say, passing or making a clone method where maybe, you know, get so value should only inspect the car.
1:06:39
But for whatever reason, you know that it's possible to mess with the car, it's possible to mutate it.
1:06:49
So maybe you could implement a clone method that would give back the car with all the same fields.
1:06:53
You pass it to get zero value if get sale value happens to wreck the car.
1:06:57
That's OK. It's wrecked a clone of the car, so that would be one possibility. That wouldn't be a very nice solution, though, right?
1:07:02
Normally, it's better to use encapsulation, as mentioned before, to hide the state of the object.
1:07:08
And then we, yeah, we would make the stakes, the car invisible.
1:07:14
I want to say a few words about garbage collection in Java in some programming languages.
1:07:25
You need to manually take responsibility for reallocating all the memory that you allocate.
1:07:31
You're going to study the C programming language later this year. So very, very nice systems, programming language.
1:07:35
But one thing that makes it a bit difficult is that you've got to manually keep track
1:07:41
of all the memory you've allocated and manually allocated de allocated later in Java.
1:07:46
This is not required. The reason is that Java is a garbage collected language, so as Haskell, so as Python.
1:07:53
So most of the kind of usable, easy to use programming languages, they tend to be garbage collected languages.
1:07:58
So. What we have then, is a separation of references, a point to nothing.
1:08:05
No references, then we got objects that have got many references to them, and that's called aliasing.
1:08:12
And we could also have objects with no references to them,
1:08:19
which are quite inaccessible objects or garbage objects, or sometimes known as orphan objects.
1:08:21
That's not very nice, but that is a term you might see in the literature.
1:08:27
And if you have these inaccessible objects, objects that are in the heap, but there's nothing referring to them and they can clog up the heap.
1:08:31
And if they would never reclaim if that memory was never reclaimed by your system,
1:08:38
that your programme would end up exceeding the amount of memory that it's been given to work with by the operating system.
1:08:42
So Java has got a garbage collector that runs automatically periodically, so when your programmes are running a certain points in time,
1:08:49
the garbage collector will kick in and it will find objects on the heap that cannot be accessed by your programme.
1:08:57
Provably can't be accessed, what that means is there is no path of references from your programme stack to one of these garbage objects.
1:09:05
There's also something in a programme called the static area, which is where static variables live.
1:09:16
So there also shouldn't be a path from a static object to one of these garbage objects.
1:09:21
The garbage collector will find any garbage objects and then we'll do a sweep and we'll reclaim all the memory associated with them.
1:09:25
So what this means is that when you're programming in Java, you don't need to worry about explicit destruction of objects.
1:09:34
You can leave objects in heat, and the collector will eventually get them for you.
1:09:40
And in the tutorial exercises I've set for you, do remember that on science here there's a link to GitHub programming questions.
1:09:44
Quite a number of questions for my parts of the course, and you really should try them all by the end of the term.
1:09:52
There are some exercises about simulating garbage collection writing Java programmes that simulate what the garbage collector does,
1:09:57
so they should give you a little bit of a feel for how much garbage collection works, what other studies in any more detail here.
1:10:04
It's a pretty simple question if it didn't go this way, how much memory?
1:10:11
How much memory with the average Java programme, because this look over the phone more than once?
1:10:18
I mean, it's really easy to I mean, you can you can easily write a programme to write a memory.
1:10:25
Let me do it now. So. What I can do here is I can just say a list of integer my integers equals new.
1:10:30
Sorry if I do a list of strings. String a string.
1:10:41
My strings, because new ArrayList. I'll do something of this, I'll say string value is an empty string.
1:10:48
And then I'll say for an I was there, I listen. So I'm like, no, no, I + +.
1:11:04
Even then, it was too large to try and make it a bit smaller. Now I'll say.
1:11:11
Value becomes equal to value, plus I say I'm going to make value, be sorry, value plus equals,
1:11:18
I'm going to concatenate the integer onto value, so I'm going to say my strings add.
1:11:28
Ali, I'm going to leave an inordinate number of times and every time that you can push a slightly larger string as my two strings.
1:11:35
OK, so part of this might be the end of the lecture, by the way. So what we got here was that out of memory error, OK?
1:11:44
And maybe what we could do just as a little experiment is why don't we count?
1:11:57
Well, why didn't we see a more lewd situation occur, so approximately why did we say something like if I?
1:12:04
Module one thousand equals zero. And.
1:12:13
I. So we're not going to know exactly when the the error occurred, but we'll get a rough idea.
1:12:22
Yes, so you can see that after 41 days, illustrations, but also we ran a memory.
1:12:40
Now the ability to get larger and larger and larger and larger and larger straight when every situation.
1:12:45
So if I just added like small strings and would have run out of memory after more iterations and then you can on the command line,
1:12:50
you can use an argument to say how much memory you want to give the Java virtual machine.
1:13:00
So if you know you need a load memory to give it more memory,
1:13:04
but it's always possible to write a programme that will consume more memory that it's allowed.
1:13:07
I can't really answer your question of how much movie does an average Java go because they're not really such thing as an average Java programme.
1:13:11
OK. And if you enjoy true wishes, there were a few kind of fun exercises about playing with errors like Stack Overflow of
1:13:18
errors that he ever encouraged you to take a look at those to gain some more insight,
1:13:25
please. Obviously, Panopto.
1:13:31
Yeah. So you've got a cycle of updates, and I guess the question is, is it possible to cycle?
1:13:55
I'm already on the whiteboard for those folks who remove. I mean.
1:14:01
The way garbage collection works just very briefly, and then I do need to crack on with some more of the core material.
1:14:08
This is quite interesting. So very rich, then you've got your programme stack.
1:14:14
And you've also got this thing called the static area, which is just where all of the static area, this is about all static fields live.
1:14:23
And you've got to keep. And then there were going to be a load of objects and heat.
1:14:34
They can be millions and millions and billions and billions of these in the heat.
1:14:46
And then they refer to each other in whatever ways.
1:14:51
Hopefully, you do buy programmes that have such spaghetti like objects.
1:14:58
And then there are going to be some references from the static area and references from the stack.
1:15:04
Into this object, rather. So what the garbage collector does.
1:15:11
I'm implementing an efficient garbage collector is a huge kind of difficult and challenging task, but just a very basic level.
1:15:16
What it does is it starts from each of these points that called the roots of the programme that things that your programme,
1:15:25
the text of your programme can actually access. You can refer to a static variable you can refer to in your programme and it go, OK, what's reachable?
1:15:30
That's reachable. So that is to so that is two. So that is to say that is too.
1:15:38
So that is to I mean, it was say, OK, sign up for sign up for all these things are reachable and then it goes through the whole heap.
1:15:44
And anything that's not marked gets swept away. This is called mark and squeak.
1:15:51
Garbage collection.
1:15:55
So these objects all get swept away and in particular, this cycle, which maybe we're worried about because it was no element of the it was reachable.
1:15:56
The cycle get swept away may have had a reference counting, which is another kind of way of managing memory.
1:16:05
Automatically reference counting is hindered by cyclic structures. But markets with garbage collection isn't.
1:16:12
OK. That was interesting, but I didn't I better get on with the main material.
1:16:19
I wanted to check, you know, a bit about Nhlapo exist, right?
1:16:25
If you say that a variable is no, you're explicitly saying it doesn't refer to anything null is the default value for references.
1:16:28
And if you try to use something that's not also this example olive as an exercise for you to draw the heat for.
1:16:35
But if at the end of this example, you did not start.
1:16:42
So if you look here, the got the value of C C was no.
1:16:46
So D is going to be null. So doing did not start is going to try to call the starch method on whatever object refers to.
1:16:51
It doesn't refer to any object, so you get a no pointer exception. OK.
1:16:59
So I've never, ever had one of these in my code personally, but I've heard about that.
1:17:03
The quite nasty. OK.
1:17:08
A brief summary table showing you some differences between primitive and reference types.
1:17:13
Java. A couple of things to remark on. Here are the reference types always needed.
1:17:19
The references refer to objects and objects always created with new.
1:17:26
Even if you don't see me like in the case of a string literal or the array brackets sensation Neal,
1:17:30
the constructor of an object is being invoked behind the scenes, whereas with primitives you use literals like one,
1:17:36
two, three, etc. and with reference types you call methods on them,
1:17:41
whereas with primitives you use built in operates that plus times, and in Java you don't have operator overload.
1:17:47
In some programming languages, you have operator overloading where you can say for my data type, I to define plus means you can't do that in Java.
1:17:53
And you might not be surprised to hear me say,
1:18:02
I think that's a good thing because I sort of maybe said that a few things about convenience features, not always, but not always being good.
1:18:04
I quite like the way Java doesn't have that many convenience just because it makes you actually write down what you're doing.
1:18:11
Someone can read your code and they go, OK, I can see that there's a method called this doing some sort of addition and just look
1:18:17
at it as you cross and mistakenly think that those things are numbers and then go,
1:18:22
hang on a minute. Oh no, they're not numbers. Oh, maybe they've maybe they've overloaded this operator.
1:18:26
So if you ever look at kind of optimised C++ code written by experts, it can be very,
1:18:31
very difficult to know what's going on because operators have been overloaded all over the place and there are some big, big upsides to that.
1:18:36
But I think from readability and maintain a bit maintainability point of view, it could be a payment.
1:18:42
This text writes, I want to conclude just by doing a coding example.
1:18:50
Well, I've got here is some slides for you to read about in your own time, about immutable objects.
1:18:54
So let you go through those. And then I've got some slides to help you write simple into interactive programmes reminding you how you can look at
1:18:59
command line arguments of your programme and how you can use a buffered reader to read in some data from standard input.
1:19:09
Why wouldn't you, rather than going to these slides if I just forward to the end?
1:19:16
Then there's an exercise here to write a circle course represented by centre and radius
1:19:23
and then by a programme that's going to read any circles from standard input into a list.
1:19:29
Print details of those circles to the council and then remove all the circles with the radius smaller than
1:19:34
10 from the list and then either report the list was empty or report how many circles remain in the list.
1:19:39
So I think I will just quickly go through coding up this example and intelligent
1:19:46
party because I want to give you brief exposure to how exceptions work in Java.
1:19:52
Because when Nick teaches you concurrency, he's going to depend on you having basic knowledge of how exceptions work.
1:19:57
OK. So what I'm going to do is.
1:20:05
In here and a comment I'll paste from my PowerPoint slides. This is quite cool.
1:20:12
A programme that zip this is just a guy used to do what the slide said.
1:20:17
OK, so what I'm going to do here is going to make a class called circle.
1:20:24
And I'm going to say string colour.
1:20:31
Radius, what's wrong? No private, right, was that violating?
1:20:37
Encapsulation. What's arguably also wrong?
1:20:46
If I know what's that violating? Immutability. Why is the co-pilot complaining?
1:20:52
Yeah, I said that this is immutable, but I said it to something because I can't said it to something later.
1:21:01
So let me make a constructor. So what I can do is if I do enter an intelligent gives me ad construct parameters or initialise and construct this ad,
1:21:07
construct the parameters, both parameters, then it gives me the obvious constructor.
1:21:20
So this if you're confident you want the obvious constructor, that could be a nice way to avoid a bit of typing from your friends.
1:21:26
OK, why don't we provide for our. Let's provide guesses for colour because we need those.
1:21:32
If we're going to show the world radius for the bit, the question that says filter all the circles that radius less than 10, right?
1:21:39
So its catch radius. Return radius.
1:21:47
Now, there was nothing in the question that suggested we needed a way of getting the kind of have to show the circle.
1:21:53
All right. Well, we're going to do that by overriding its two string method,
1:21:59
and we don't need a way of getting the US to provide a getter just because I provide it if you really need it.
1:22:03
So let's provide a way of turning a circle into a string by overriding the two string method of the cost object.
1:22:08
So the idea is created a method public string to string, and by providing this method, it means we can use a circle in a string context.
1:22:16
And this string method will be implicitly invoked on it. The override annotation we're going to come to you in the next lecture,
1:22:27
so we're supposed to talk about that until Thursday and is given as a possible to for our circle.
1:22:35
But I would prefer just to say colour.
1:22:42
Radius. I tell it like this at all.
1:22:48
Radius there. Close.
1:23:00
OK, so that's a sacrifice. No, the question was to re encircle some standard input into a list.
1:23:07
OK, so why don't we do something like this will make a. Get rid of this.
1:23:17
This is our standard name. So let's get the number of circles we like from the command line.
1:23:23
So what we could do is, you could say if OG's is not equal to one.
1:23:29
Then. Sorry. It's not like there's no retirement system out of print, Alan.
1:23:36
Expected one argument. The number of circles.
1:23:46
And then what we could do is, say systems. Exit one.
1:23:52
So that would actually stop the programme in its tracks completely stop the programme, that's appropriate.
1:23:59
If you're writing the entry points to a programme, if you're writing a library that other people are going to call.
1:24:03
Never, ever, ever, ever, ever, ever use system to exit because it will kill the whole programme, right?
1:24:09
I experienced this when I did an internship for my company. The Glasgow I grew up and.
1:24:15
I was writing some prototype code to do some gesture recognition, and I had it, and they weren't using very good version control back then.
1:24:22
So my code was all checked into their code base, but it was in a special directory like Charlie's internship project.
1:24:32
I'd read a bunch of tests. They really encouraged agile development, so everyone to write test cases.
1:24:38
I'd written all these tests and despite did a Ph.D. at the time, I was quite naive programmer.
1:24:42
And in my test cases, I had a whole lot of system to exit one.
1:24:48
I realise that they were going to run all the company's tests every weekend to get like a test report,
1:24:52
but I came in on a Monday and there were these people who really,
1:24:58
really angry because my system to actually want to just stop the tests so that we kept running and they just stopped.
1:25:01
They got to my one and the whole test process had stopped. So they didn't have any test eddy test data for the next week, which is quite big company.
1:25:06
It's quite bad for them. I think it really was, but I do think anything actually happened. But yeah, that's how I left my system to exit one.
1:25:15
I said, OK, so we wanted the number of circles it would be more traditional to write system thought or write the epicentres of standard error.
1:25:20
The standard so error messages typically need to standard error. OK, so we're going to say the number of circles equals args zero.
1:25:29
Can't do that because OD zero is a string. We want an integer.
1:25:41
So let's use integer. The Pies.
1:25:45
August zero. OK, so now what we want to do is make a list of circles, so why don't we say something like list circle?
1:25:50
Circles, because new. ArrayList saying, so what I've done here is remember if I just said list circles here, I wouldn't have created any object.
1:26:02
I would have simply made space on the stack to refer to an object.
1:26:14
But by saying equals new ArrayList,
1:26:19
I've made an ArrayList object on the heap and circles needs to be able to point to some list object and an ArrayList object is a list object.
1:26:21
So that's fine.
1:26:31
OK, and now what I'm going to do is I'm going to loop a number of times, so four I zero I less than numb circles, I post boss on a red circle.
1:26:33
From standard inputs, how do we reach the standard?
1:26:45
One way is to use a buffered reader, so I can say here buffered reader buffer reader because new buffer reader.
1:26:49
New input stream, reader. System got into really simple to make tweaks in the command line just to write like three different objects.
1:26:58
So what this is doing is system in. Is a static.
1:27:09
Field of the system class is an input stream.
1:27:16
And an input stream reader is made from an input stream,
1:27:22
so I've said I want an input screen reader that can read from standard inputs and then a buffered reader is a special kind of reader is efficient.
1:27:26
It reads like chunks of data at a time and gives you lines of data so you can read a line from a buffer reader.
1:27:34
Sarah, I've made a bucket reader from the industry and I what I could do is I could say something like this.
1:27:41
I'm going to go, Well, we're going to read, say, the coloured and the radius so I could do string colour equals PR story line.
1:27:47
And string radius equals offered, Rita Leave nine.
1:27:59
OK. A couple of things have gone wrong here. One thing that's going wrong is that Red Line can for an Io exception.
1:28:05
What that means is when one of you reading from standard input, something could go wrong. It could be that the keyboard could malfunction.
1:28:12
As a result, read operation is occurring, so it's possible that the read operation might not work,
1:28:17
in which case an Iowa exception will get thrown out, and we're going to cover exceptions in detail later.
1:28:22
But benign with exceptions. You got two choices you can either throw the exception upwards to whoever called you.
1:28:27
So in the case of Maine, you could do a throw here. We could say throws either exception.
1:28:34
That means that if one of those exceptions does occur, the programme will exit and you'll get the exception message credited to the console.
1:28:41
An alternative is to catch the exception, so we could put this in a try statement.
1:28:48
OK, and then we can say here, catch, I have exception.
1:28:56
Exception that means that if one of these exceptions occur, then control will end up here, we could deal with the exception.
1:29:02
And in this programme, I'm going to. Be lazy and say.
1:29:10
Something went wrong. Giving up. And then I'm going to do the dreaded system, the exit one.
1:29:18
OK, now the other thing that I said, there were two things said.
1:29:30
So that's all I have say about exceptions. And the reason I mentioned this is when you study concurrency,
1:29:34
there's something called an interrupted exception that you need to be aware of and is going to get it briefly.
1:29:39
Touch on that. So I want to make sure you've seen exceptions before you get into that.
1:29:45
I said, there's something else.
1:29:49
I'm actually not yet, but if I do introduce because I need an integer radius, this isn't going to work because I need to have an ambassador.
1:29:50
You just read line returns, a string. So again, I could use integer. Deposit.
1:30:00
Yeah. OK, and then what I could do is I could say circles or add a new circle kind of radius.
1:30:07
All right. So if you managed to get through this loop, you've got all our circles.
1:30:21
So here we could do for each circle. See in circles in Google Drive, a style single letter, a variable names are not allowed in most contexts,
1:30:31
but they're fine for leakage rates, is going through a collection fine to use a single letter variable name.
1:30:41
So I could say system out of print and see how can I see?
1:30:47
Why is it OK just to see interpret a string?
1:30:54
Well, using a circle as a string is going to implicitly lead to the two string method of the circle being cold.
1:30:58
So that's going to lead to that two string that we implemented. Here being invoked, so we should get a nice, strong representation of the circle.
1:31:05
OK. And then why don't we also do the business of going through the circles and
1:31:15
removing all these ones that don't satisfy the predicate of having their radius?
1:31:24
What do we want in the sides? We move the circus with radius smaller than 10 from the list.
1:31:30
So rather than removing them from the list, well, I think I'm going to do is say.
1:31:34
List circle. Larger circles equals and maybe will do circles stream.
1:31:39
Senator, we're going to keep a circle. If its radius is what do we want, so we keep it, this radius is greater than or equal to 10.
1:31:51
That I could do list. OK, then maybe here to say.
1:32:07
Larger circles are. Maybe I'll just Chuck in a new line here to separate.
1:32:26
It's a separate report. All right. So let's run that programme, and then I'll call on refills of things that I don't like about the content.
1:32:32
And you are also very welcome to comment. Right.
1:32:39
So let's run it, run it. And we get an error saying we expected one argument.
1:32:46
The number of circles. OK, so we could run this programme from the.
1:32:52
From Intel AIG by going ammo edit configurations.
1:32:58
And here we can provide programme arguments there.
1:33:03
So why did we do that first, let's say three, three circles.
1:33:07
So if I run a programme is waiting for input from me, so I could say read for the 22 green 36.
1:33:11
We got an exception and no for exception to the input string green.
1:33:25
Thirty six. So the problem here is that I didn't do new lines there.
1:33:29
OK? I actually thought I had to be weird, but it's like I did it.
1:33:34
So let's try that again. You can see the number format except for the card, because the buffered reader got a whole line.
1:33:38
Twenty two. So if I was making a circle with the colour blue 22 and the radius green 36,
1:33:45
and the no format exception has been thrown with green 36 as the text that was not really a number.
1:33:51
So let me run it again. What was I really trying to do?
1:34:01
Reds return for return. Green twenty two, the thirty six.
1:34:06
OK, so here we go, we've got red for green, 22 blue, 36 of the largest circles.
1:34:14
I've ridden 22 36. So the main point of that, not that the code was particularly interesting to write,
1:34:21
but I just wanted to show you a little bit about exceptions to prepare you for concurrency and
1:34:26
also just go over how you can use the command line arguments and I can use a buffer 3D object.
1:34:31
So a couple of quick things that I don't think a very nice about this coast. First of all, no circles.
1:34:38
Is. Something that actually I'm only using down here.
1:34:45
Okay. That's the first time I use it, so I would prefer to declare it.
1:34:51
It's close to where I use it as possible. First of all, second, I really shouldn't update numb circles again.
1:34:56
So I'd like to make it final so that I can't accidentally do no circles plus plus.
1:35:04
OK. Sorry, Bacon's final whenever you can. And this bluff agree to object.
1:35:10
It does make sense for that to live, I. It has to live in outside the loop, so that seems like a reasonably good place for it.
1:35:16
It could be fine, although that doesn't mean that the object he refers to as a beautiful what it means.
1:35:26
I'm not obliged to redirect buffered reader to point to a different buffer to you, my programme.
1:35:31
Similarly, this list of circles is no good reason for that not to be final, making it final.
1:35:38
It doesn't mean that the list is immutable. It doesn't mean I can't put things into the list.
1:35:44
What it means is that that circles could only refer to the lists that it was initialised referring to.
1:35:49
So the beginning of time, it's referring to an empty list and that list can grow.
1:35:56
That's fine. But I can't halfway through the programme be like it or not, isn't that?
1:36:00
OK. And then I would say that really similarly, it would be good to make these things final because there's no reason not to be final.
1:36:05
And then something I'm undecided on is whether I'd want these temporaries at all.
1:36:15
So I think there's something sort of clear about saying, read the colour and be the radius and then pass colour and radius into this constructor.
1:36:18
But I would actually be tempted to do the following right?
1:36:28
Right? OK.
1:36:32
So I made this a one liner.
1:36:42
So I've avoided this temporaries, avoiding temporaries is typically a good idea because you can't misuse a temporary if it doesn't exist.
1:36:49
So let's just check this programme still works, doesn't work because it's a compilation error.
1:36:57
So. What I'm going to do is I'm going to be lazy and I'm just going to say A to B three, C four.
1:37:04
OK, so the programme work, that was fine, but a problem with this programme now is, let's suppose I decide to change the constructive circle.
1:37:15
For some reason, I get the urge to change this so that radius becomes the first argument and colour becomes the second document.
1:37:26
And then actually, this is going to be OK because I'm going to be because these things different types,
1:37:36
I'm going to be forced to reverse the order of these arguments. OK. Let's imagine that maybe I went completely crazy and decided that this is going to
1:37:43
take a string radius and I'm going to move the integer because it's code in here.
1:37:51
And I don't do this, this is horrible, I'm not proposing you do this, but just as illustration.
1:37:58
No, there's a string and a string taken in here. OK. And now I don't do.
1:38:02
Integer top prise in I do the story line right now,
1:38:10
changing those parameters is not going to require any sort of change to my code, and it's really difficult to see here, am I?
1:38:16
Which one of these is the colour? Which one of these is the radius?
1:38:24
And you when I run the programme, if I do a three, oh, now I get an exception, right?
1:38:26
Because it's tried to process the colour as the integer radius.
1:38:34
So if I had reverted my change to Demmer, so that if instead.
1:38:39
I reintroduced this temporaries, oops. Yeah.
1:38:45
And if I'd done string radius. And.
1:38:55
I've heard I'm still going to be subject to the same bug. OK, I'm parsing colour.
1:39:03
It's the first documented radius. This is second when they got changed, so the bug isn't going away.
1:39:08
But it's a bit easier, maybe, to see what the problem is.
1:39:13
I can look at this and go, Oh, it's colour radius should be red is not offered you a red line and buffered.
1:39:15
Read it A read line. So temporaries is a bit of a mixed bag,
1:39:21
but I would say eliminate temporaries when you can unless you think that having the temporary reading, Mexico's more readable.
1:39:24
Very briefly. And then we've got stop for the next. But we could we could catch a no fly exception.
1:39:29
We could deal with that and say, please try again as an exercise, why don't you try and adapt the programme to do that?
1:39:40
Wait a minute. Oh yeah, that's a good question.
1:39:48
We'll come to that when we study exceptions. The question is why do we have to deal with oh, exception for the number format, something is optional.
1:39:54
Great question. And we'll come to that, actually, of course. OK, see you on the Thursday. That's up.
1:40:01
But.
1:40:10