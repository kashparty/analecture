ID: 41900e5f-4369-4402-84d4-ade400fac996
Title: Advanced programming - Functors
Category: Haskell
Lecturer: Anthony Field
Date: 18/11/2021
Q, can you see my desktop? Yeah.
0:04
Excellent. Okay, just make sure that people can read the fonts. It's going to say so.
0:09
I turn the syntax off what to do if you're not monitoring the chat?
0:14
Well, they will of looks at the hands up and poses a question that you haven't spotted.
0:20
I'll just stop you. But yeah, I will. People just shout, if you can't see, if you can't see, will screen, just shout.
0:24
I'll try and flip back periodically to the top.
0:32
But yeah, feel free to interrupt me, either yourselves or if Tony spots something he will do will interrupt me.
0:34
I'm sure. Then you make the phone, think it will be really quite small. Now is it got?
0:40
So when so all right, people should show up, that's getting on the best about right, I think.
0:48
Cool. All right, we'll try that. If people and people are struggling to say it, just just put your hand up and we'll get will increase the chances.
0:55
Cool. So yeah, as Tony said, I'll be delving into in a, I guess, a couple of more top classes that you may or may not see today.
1:05
So as I understand it, you've spent a bit of time looking at the mono or mono, depending how you pronounce it type class,
1:13
which sort of powers some of the coolest stuff in high school,
1:21
like the sort of do notation where you can do, you know, things can't be a good example.
1:23
You know, and you can do things like this, I suppose.
1:29
Hello. And if I do something, then it prints out, hello, so that's like kind of Mona,
1:36
it's turned out to be a really useful tool for kind of capturing imperative looking behaviour in a language like Haskell that's actually functional.
1:42
But it turns out that there are actually a few other type classes that play into what makes a moan, which I don't think you've covered just yet.
1:50
So I'm going to try and whiz through some of those today. But yeah, just to recap, what I expect you'll have seen is this class blue note,
1:58
which has some type parameter, and I'll talk a bit about it as we go through.
2:07
But is it a type? I say it's what we call a type constructor.
2:11
It's something that yields other types. So you'll have seen something like Io is an instance of mono.
2:14
I don't want to say a constructor. I mean, something that takes an argument.
2:21
So you know you have things of type Io, but you can't say like instance monad int because it isn't the right shape.
2:24
It doesn't take another type as an argument. And this is something that isn't common in most programming languages,
2:32
like this ability to abstract over things that construct other types, like lots of languages.
2:42
I think you've just started Kotlin, you know, and Colin sort of related to a family of languages like Java.
2:49
They have things called generics, which let you abstract over like concrete types.
2:54
So this, you know, you've encountered lists that a list could have. Well, here I've got a list of names, right?
2:59
And List can have a list of strings.
3:04
But you know, list, as we say, polymorphic, you can have lots of different things inside a list, so lots of languages let you do that.
3:05
But not all of them let you do this kind of abstraction where you could talk about like the containers or the shapes of things.
3:12
So when you talk a little bit about other type classes in high school, let you do it today.
3:18
They start off with a list of names, so we've got like some strings here Frankie Morgan,
3:22
Robin Taylor, and suppose I want to get a list of all the lengths of those names, right?
3:27
So that's not too hard. You say?
3:35
So do name lengths, and I'll call it L, just because I'm going to do it a few different things,
3:44
and this is going to take a list of strings and give me a list of ends.
3:51
And we know the the function length will give me the list of a single string.
3:55
So it's not too hard to infer that if I Batfleck over a List X is say or, as you say, if it's strings, then I end up with a list of lengths, right?
3:59
And if I do that, indeed, I can do name lengths out of name list and I get a call the write function and I get seven six five six,
4:10
which looks about right. Frankly, seven and six Robert's five total of six.
4:22
So that's all well and good. Of you might be screaming that I should clean this up.
4:27
So we know that if f of X equals G of X, then F equals G.
4:32
And since this can be bracketed like this, we've got names like us as equals mob length as so we can get rid of that argument.
4:36
So that's not bad stuff. So we've got a function that sort of mapped length over a list of strings and it's all well and good.
4:44
And there may be, you know, at some point the list of strings gets really, really large.
4:52
And you want this this list to be ordered, say alphabetically.
4:58
So I've sort of tactfully done that for the list above, and you realise that maybe list isn't the greatest data structure for storing things,
5:01
excuse me and like an ordered manner, so you decide to use something more appropriate, like a binary tree.
5:09
So again, you've probably seen a tree in your time studying Haskell, so a tree can either be empty and this is a binary one,
5:13
or it can be a branch with two sub trees and some elements in the middle.
5:22
And I will make it so that we can print these trees by driving show.
5:27
And if I do this, then we just get this and I can do names Tree.
5:32
I think, yeah. Here's one I made earlier, which is the tree of strings and the still in alphabetical order.
5:40
But this kind of looks like you've got Morgan Newtok mortgage that how broken my brain has become.
5:48
Roberts Slash has proven over a bit. Frankie and then Rob the sailor.
5:59
So this is what the tree looks like, and you can see that if you traverse that tree in order, which is to say left root right,
6:13
that you will see Frankie Walker, Rob Taylor so that tree is sorted in order traversal, as we say.
6:20
I'll leave that there in case that's of interest, but that's what the branch constructors represent.
6:28
A branch is is this good structure. This is the left up tree and this is the rise of tree, so I could do that.
6:33
And that's all well and good. I've got, you know, I could sort of see that now so I could do names Tree and it all prints out lovely.
6:41
A great, but I can't call. They, like, sell a neighbour's tree because it's juicy.
6:47
Quite happily tells me they like sell only works on a list of strings that I could match that with the tree of strings.
6:52
So you say no problem? Well, how did I write name length?
6:59
So I'll write name Lex Tee. And again, let's get up some cut paste here.
7:03
And you go to write that function.
7:10
And you think, well, OK, well, before I just obviously, I want to use the leg, should I just sort of mapped over the tree, right?
7:14
But I can't do that because map only works on lists and you say, OK, fine, I'll write a map tree function.
7:19
That's that's clearly the smart plate, right?
7:26
So, Matt Tree, if we remember that map has the type, it's a B list of A to list of B, the map tres Typekit could be very similar.
7:29
But instead of looking your lists work on trees. So what does battery look like?
7:40
So take some folks. F are those two cases right? What is the tree is empty, but what is the tree is a branch to the left of tree.
7:44
Some value x and a bright sap tree, so the trees empty.
7:51
What do we do? Well, there's no data to process, so we just need to return.
7:56
The Tree of Bees and the empty tree of bees will do just fine.
8:00
Let's be the latter, not be the insect, but it may not be quite as pleasant.
8:04
And if you've got a branch, then you've got left some tree, an Element X in the middle and a right sap tree.
8:10
And we need to apply to all these elements. So we're going to apply f to X. That definitely makes sense.
8:16
And what do we do with the rest of it while we rehearse, right?
8:22
So we recursively play Map Tree F over owl and treat f over.
8:25
And if we do that, then this function name like City should work.
8:31
And hopefully it does, so we can now do name lengths, T of name story, and we get the tree with the lengths in the same place as the name.
8:37
So seven, six five six. Which is great.
8:49
Um, you know, maybe I don't know, maybe you're selling this wonderful length function as a service business isn't going so well,
8:55
but perhaps predictable reasons. And so the database of names you end up collecting massively reduced it.
9:03
So that only contains zero or one names. Then you might end up using like, maybe it's dead, right?
9:08
So maybe you could think of maybe I'll just recap the definition of maybe.
9:13
As a value of media is either nothing. Or it's just some may.
9:18
So perhaps we've just got one name here, and we will say it's just Frankie.
9:25
And you want to write the same book should it get right? You all right? Like em, say, Oh no, this should be names.
9:32
Maybe shouldn't. And this is going to take maybe a string to a maybe.
9:37
And. And the same thing happens again, you know, you want to use the link function that you need a map focus of the work, so babies.
9:42
So you write one. And again, we know that maths has this type, so we get to write a function that maybe.
9:52
That has a similar type to shop this a long one.
10:01
It's to be something like maybe a two, maybe. Right.
10:06
So it takes function, the 10 days intervenes and tells you how to apply that function to a maybe to get to maybe.
10:10
And again, this two cases. One is you've got nothing.
10:18
One is you've got just X. So if you've got nothing. Well, again, there's nothing to apply that function to.
10:22
The best you can do is return nothing. And if you've got just an X, well, you know you want to apply after the X, but that's not a value of time.
10:28
Maybe it's a B, but that's fine because we can just stick it inside a just right.
10:36
If you do all that, then. We could do nameplates on names, maybe, or, you know, some other name.
10:42
And all works, and that's great. Congratulations to us.
10:52
We've just solved the same problem three times with three different data structures.
10:57
But. While changing the data structure may make sense, changing the rest of the programme, it's just an inconvenience, right?
11:02
Like changing the data structure to get different performance characteristics or to exploit particular storage properties,
11:11
properties like a sensible thing to want to do, right? You know, programmes evolve data structures, a particular change.
11:18
But ideally,
11:26
you ought to be able to do this in a way that doesn't mean you have to rewrite the entire programme every time they graduate the entire programme.
11:27
Here's just what folks did, but still rewriting that is tedious. And so.
11:31
You know, there's a famous saying which is often employed in jest, but here it genuinely applies,
11:39
which is, you know, every problem could be solved with what more layer of obstruction?
11:43
And that's kind of what we want here, right? We want to obstruct the data structure that we're using, which right now doesn't happen, right?
11:47
And for those who've programme before, maybe in like object oriented languages or other sort of imperative languages,
11:56
you might have encountered different kinds of abstraction like interface or, you know, different design patterns.
12:00
Haskell SQL abstraction, too. You've seen some of it already, like length length works on a list of Type A for NEA.
12:07
And so you can think of that as a kind of abstraction, right? Because if you put in here, that would be like limiting the power of 80,
12:14
but by abstracting the way you've made the length function more general, which is great.
12:21
And that's kind of true here. Like, except the thing that's stopping the abstraction isn't string or not, it's its list, right?
12:27
Its tree. It's the fact that these these bits have been fixed in sort of the type signatures.
12:34
So we want to try and.
12:41
Loosen that, so if we line up all the time so far, we've got Matt, Matt, Tre again, let's get some guns here, which is a list today to be.
12:45
We've got Matt, may be. These are all take list of databases, and then they are the only thing they differ in.
12:59
Is the structure they operate on, right? So they look very, very similar, but.
13:11
These bits are where the difference is happened, and I'm going to play a trick here,
13:22
which is you may be familiar with the fact that there's nothing super special about operators in high school, like if you wrote two plus four.
13:26
That's just sugar for writing plus two for. And the same is actually true of lists when you write list.
13:34
If you like that, that's just sugar for writing that. It turns out so.
13:40
Thanks, Haskell. So let's change that. And then they really look similar.
13:45
So if you do that, then you could see the.
13:54
This is the problem like, oh, brother, this is the thing that's changing, but the rest of the time signature is constant.
13:57
So the question is, can we obstruct over that thing? And the answer is yes, we can, and there's a class in high school that does it.
14:04
It's called to which harkens back to sort of the mathematical roots of this concept.
14:11
But what function does? Is it so generally, it is the map operation, and it's called map of funked a map, and it has this type.
14:18
It says if you give me a function that turns those into B's, a funk to F is a type that allows you to map that function over an f of these.
14:27
To give you an f of BS. And there are some instances already in the prelude for list, so if map equals map.
14:37
There's an instance for maybe as well. Well, it looks a lot like the may maybe function we wrote,
14:48
and I'll write the instance for every now and again notice I'm not putting instance to tree A. or tree and or tree string here.
14:56
The thing that func to take is a type constructor write something that takes another type like end of string and gives you a type like tree.
15:04
And so. If map on trees is map tree.
15:11
And if I write that. Well, what if I achieved?
15:21
Well, you know, I had name lengths to stay on names tree and that was implemented using Map Tree of Length, right?
15:25
But what I've just said is the I've made TRIA [INAUDIBLE] her by saying that if map equals map tree, so that means in theory,
15:39
now that I can do f map length names, tree and I get the same answer, which is great, but if not length.
15:48
Is more powerful.
15:56
The map tree writes a map, tree says, Give me an A to B and I'll give you your tree a tree B but f map, which is the type of map tree.
15:58
So map tree length and says, Oh, that's very ugly.
16:08
Goddammit. Let's do let my legs.
16:12
So if you map the length function using Map Tree, it turns the Tree of Life stages,
16:22
which is a string here, I'm just going to do this even more on a morphic.
16:30
So I say I'll turn a tray of strings into a tree events, and similarly, you know, if I make that map, it does lists.
16:39
But if Map says I'll work on any funk to.
16:45
And that's useful, because if we do that, then all of these implementations can be replaced with mouth length.
16:51
Right. Which on the surface doesn't seem too great, but the thing to realise now is that, well,
17:03
if all three implementations have the same art, the same implementation, then you don't need all three of them, right?
17:11
You just get rid of them. And you replace them with a single.
17:16
Name lengths, FSA that says if you give me a tariff full of strings, I'll give you a tariff full events.
17:25
But that is just not length. Oh.
17:33
And that name, Lexus now looks on names list. It looks on names tree, and it works on names, maybe as well.
17:41
So I question my hair. No, no, I don't see what I'll shout out for civil.
17:51
So that's the funk type plus now of whirlwind it quite a bit, because I know you've already seen opponents.
18:03
But how does this fit together with my own right might be the next logical question. So let's bring the Moon definition down here.
18:10
So, well, it turns out that any monad is a factor.
18:21
OK. And in high school terms, that means you can think of Sumpter as being a super class instance.
18:26
And it's a kind of, you know, an example you might be already familiar with is, you know,
18:33
the AQ class where you can define equal, say, just gives two A's and takes a ball.
18:36
And there's the odd class which tells you about order. It ordered things which has like less than or equal to and so on.
18:42
And IQ is a super class of AWD. Right.
18:49
And then you can't be ordered without being comparable for a quality.
18:53
But another way of thinking about it is that if you're ordered, you're definitely comparable for equality, right?
18:57
Because if I've got greater than and less than or equal to, I can implement equals, right?
19:02
Because I can ask, well, is it less than or equal to it and so on? Well, there's a question from Katherine if you want to take that now.
19:10
Yes, I can do the shout out.
19:17
Yes. Can you hear me? Yep. So with the functional class, don't we just move the problem like behind the scenes?
19:21
So we still have to programme what mapping means for each like functional type?
19:33
Yeah, that's a fantastic question.
19:42
So the question is kind of about, well, have we actually reduced the work rate because we still have to implement a map for all of our types?
19:44
And that is true.
19:51
But the I guess the the principle you're betting on that does turn out in quite a lot of cases in engineering to be true is that that cost is one off.
19:52
Right. You have to specify how to map a tree once, but the number of potential applications is much greater.
20:02
So, you know, I've just talked about a very, you know, trivial, pointless example of like just computing the length of everything in a tree.
20:10
But we might imagine there are lots of other applications where mapping over a tree is useful, right?
20:17
Like, I don't know, counting up the marks in a big database or this sort of thing.
20:21
And in all those operations, you get to use the map function. You're you're not really trying to save yourself the work of defining your programme,
20:27
you're trying to minimise the risk of having to change it when the logic hasn't changed, if that makes sense.
20:36
So for instance, here the logic is computing the length of an item.
20:42
And beyond that, the logic is computing the length of all the items I have and that programme, ideally,
20:46
you would write in a way that doesn't care about the underlying data structure, and that's what Font gives you here.
20:52
It's true that for every different data structure you invent, you have to, you know, teach Haskell how to map over it.
20:57
But you're kind of betting that the number of instances where you want to map over a type is far greater than that.
21:07
So here it's kind of yeah, it's a good point. I'm giving you like one problem and one map instance of the ratio doesn't seem great.
21:12
But in practise, and maybe, you know, if you think about all the time, see views map already just on lists.
21:19
If you think about that ratio and take it up to the scale of like, you know, maybe working on a production code base,
21:25
you're probably going to end up with many more instances of using the abstraction, the defining it.
21:31
So you hope in that sense that the cost pays off. Does that answer your question?
21:35
Yes, thank you. Cool.
21:40
And I just remembered something, but I forgot it again. So.
21:45
We won't worry about it.
21:52
So, yeah, factors turn out to be a superclass of monad, because it turns out that if something is a monad, you can implement an estimate.
21:56
So let's say you've got, you know, the aim is a moment,
22:04
then you can implement a function that turns and moves into an M if bees using the fact that it's a mono,
22:07
so you can you can basically make a map for any moment. And how does that work?
22:15
Well, you get given a function x f and some may. And what are you going to do?
22:20
Well, the moaner class gives you bind and returns, so let's try sticking me into a bind.
22:25
And then that's going to take some function. I'm going to write an anonymous function here, which is called a lambda.
22:33
If you haven't seen Lambda, I will give you a quick tour.
22:40
That's leaders. That's coming up. So you might know that you can't run this well, if it doesn't, you've done them.
22:46
OK, well, the quick highlight is that, you know, you can create an anonymous function by putting a backslash and naming the arguments.
22:53
So if I do Backslash X Lambda X X Plus Ten here, then that's the function.
22:59
That's 10 to everything. So I'm just going to use that notation now.
23:03
So I'm going to say, if you give me some memory, I will bind it to a function that takes the day and calls F on it.
23:09
So I know that then that will have f turn these into B. So this thing is of type B, but I need a type m b.
23:15
However, that is exactly what the return function gives me, and so I can do this.
23:23
And so if any monad it turns out that bind and return are powerful enough to implement f map.
23:30
So in that way, all miRNA functions.
23:37
And so if you can think of it also as saying, if you can only be a minute if you are up to the kind of the both ring true.
23:40
So funked actually sets, we say, sort of above the hierarchy above monad, not all functions.
23:47
Opponents for all moments are functions in the same way that not all types are auditable.
23:54
But any audible type is comparable for a quality. So that's that now.
24:02
If you think about. When we when we think about things in a hierarchy like you and order,
24:11
one way of looking at them is kind of what we refer to as like expressive power, like what kinds of programmes can you write?
24:17
So with AQ, for instance, you can write programmes that talk about whether two things are equal.
24:25
And you can talk about whether they're not equal, but you can't you can't order them, right?
24:29
Or is it or you can order things and with ordering, you can sort things.
24:34
And so orders, we say it's more expressive, right? Gives you more power, but it also is more constraining.
24:38
Like it's harder to be audible than to just be comparable for equality, right?
24:44
You have to. Usually, it's a strict constraint, and the same is true of doctors emanates, right?
24:49
Like if you think about lists, I've just shown you in lists. If Map is map.
24:56
So if you do map two plus of a one plus 10, you could do that now.
25:03
I think when you did doughnuts, maybe you were given sort of an exercise.
25:09
Think about what the doughnut instance for lists is because lists are monad as well as factors.
25:12
And you can see this by asking GHC for some info on the list constructor and it says, Hey, look at all this stuff that lists.
25:18
And sure enough, you can say it's it's a factor and it's a monad, and the monad instance for list is very powerful.
25:26
So if this map just gives you the ability to change each element individually,
25:32
so if you map over a list, you always end up with the same number of items, right?
25:37
Because all you can do is change the items. You can't change the structure of the list.
25:41
But if you think about the Moon at instance for list, what's the type of bind it says,
25:45
If you give me M as a moon, I'll take an m a vase, which for lists is a list of these.
25:52
And I'll take a function that turns AIDS into movies, which for lists is list peace and I'll give you a list of B's.
25:59
So if we clear that up a bit, has the type list A. To A to less B to list B.
26:07
And. I'm going to flip that type quickly, because you probably recognise it then.
26:18
I'm just going to flip the first argument. So it looks like this and you might recognise that type.
26:28
It's the type of man that would have been sweet if they lined up this type of cap map, which again, thanks to Haskell, stupidity is going.
26:32
To have some crazy foldable constraints now.
26:47
But the type of Kong come up is if you give me a function that turns one way into a list of buys and a list of A's.
26:50
I will map that function over each settlement in the list.
26:58
So if I do, let's have a function that takes X and turns into X minus one x plus one, so it turns 100.
27:01
I think people are just desperate and desperate to ask you what that little that symbol means.
27:08
Would you like to just tell them, Thank you, Tony. Uh, this lecture just became a two hour lecture.
27:15
I think so. I'm in. So let's take an example of something.
27:21
Oh, let's just do concrete map, basically, like all things in life, the good folk at high school.
27:28
And they said, you know what would make all of this type even cooler as if we just generalised them to [INAUDIBLE]?
27:36
And so there was a time when Kong Map only worked on lists surveys, and it was a glorious time.
27:43
People were happy. It was gold in the streets. But it turns out as I'm sort of.
27:49
Evangelising today that often you want to run functions on lots of different data structures and they all kind of have the same properties.
27:56
And in this case, it turns out the contract map works on lots of types that aren't lists that we call those the foldable types.
28:04
And so contact maps type is actually if you give me any foldable T of A's, I will work on it.
28:10
Now that's annoying when you're in my position trying to trying to convince people
28:18
that concatenate works on lists because this type is kind of impenetrable.
28:22
And luckily, Gizzi gained a neat trick, which is, I can tell it what type I want to use a function at.
28:28
So here I don't want to use come up for any foldable T.
28:36
I want to use it for the T, where T is the list type constructor.
28:40
And so. I can use this notation, which is called a type application to say apply can't come up to the type,
28:45
and then I'm going to give it a type that fits the shape, which is list. And this works for everything.
28:54
So if you've got what's the type of IQ, it will say, Well, IQ works on any a that is a member of the classic.
28:58
You know, it'll take two days and give you a ball.
29:04
But if I want to say what's the type of equals at integers, then that way it works in the order of the type parameters get specialised.
29:07
So I'm using this to specialise the type effectively, which is handy for lots of reasons.
29:15
But here it's handy to make the explanation maybe a little more palatable.
29:21
So in this case, concept map, then I'm going to use to turn a list of single items.
29:24
So if I do like one, two five, that's the map. And then if I out that, that's the concrete map.
29:30
And obviously, as you might expect, that's exactly what matters.
29:36
And so, you know, if map very oh, you know, this is just to be clear, this is what bind for the list not does.
29:41
All right. So you've got the list monad very powerful lets you splice entire lists into other lists and then you've got on the other side,
29:53
if map not very powerful lets you take a list of elements and only change the elements that you always end up with an element.
30:01
So the expressive the gap between the expressive power of ceremonies is quite large, and for a while everyone was kind of happy with that,
30:11
but then some people got suspicious and they asked, Well,
30:19
maybe there's something in the middle that kind of has some of the power of the owner, but not all of the power of the moment.
30:22
And it turns out they were right.
30:28
There is there was mathematics and various guidance to help them, and there is a thing in the middle that kind of has a bit of both.
30:29
And you've already seen it, right?
30:38
As if this you've probably already reached for certain functions that give you a bit more power when it comes to working with lists.
30:39
And what is the power? Well, the power is why if you have a list of functions?
30:46
Okay, so. You know, you might have had that great aha moment where you think, Oh, my only works on functions that take one argument, right?
30:52
Like two plus takes, one argument constitutes something great, but it's not true.
31:00
Is it not actually works on functions that take any numbers of arguments?
31:04
Because if I would just plus the pluses are to argument function, if I'm might, plus into that list, I end up with again, let's.
31:10
No, that's fine. We don't care. We'll pretend.
31:20
We'll meet these events because I'm sick of GHB being clever, that works fine, you just get a list of functions, right?
31:25
I can't print it because there's no show instance functions, but I can. I could make it, you know, it works fine.
31:37
But I guess the question is, what good is a list of functions? It's not very useful, is it?
31:43
Well, what good is a function? Well, the function is only in the use if you can apply it to something.
31:48
So I guess a list of functions is only in use if I can apply them to something.
31:52
And even though there is a function that does this for you with lists, right, it's all zip with you don't really think of Map Plus,
31:58
but you definitely think of Zip with plus, right where I give it one two five one two five, say, and it adds them all up.
32:05
You know, and if you've got a third list, you just reach for zip with three and so on up to the highest number, which in Haskell is seven.
32:14
To be honest, if you're using with seven, you should probably reconsider.
32:22
And if you're asking why there isn't a zip with eight, then you should probably just quit while you're ahead.
32:25
But those factors are nice, but their convenience is right.
32:30
The general pattern is you've got a list of functions and you need to apply it.
32:34
You need to apply all the functions in the list. And if you've got a bonus, you can do that.
32:38
But it turns out you can do it with slightly less power than a monad. And the thing you want really is the ability.
32:42
If I've got a list of functions like +1 times to, I want to apply those to some arguments, right, like three and four, and I want that to give.
32:47
What's that for eight? OK.
33:00
So. The question is like, well, what's the Typekit, the function I want, so I've got a list of functions,
33:08
it's a b c and I've got a list of arguments for them a and I want a list of B's and so I need some function that does that.
33:16
Now, we already know a function that takes two lists and gives you a third list, right, it zip with.
33:26
Typekit says if you give me a function that takes an owner B and gives Missy and give me a list of ideas, a list of BS, I'll give you a C.
33:37
So the question here is. What function do we want?
33:42
So A. Here is this is annoying because I'm silly.
33:46
So that's sip with and I've got a list of, call it, X toys and a list of X's, and I want a list of that.
33:51
So I need to get a to line up with X to y b to line up with X.
33:58
And seats alone, it would set. So what's the function of Typekit?
34:09
X to Y to X to Y. Well.
34:17
Well, yes, that's an excellent answer, so someone has posted Dollar, which you might know dollar is a great little function.
34:26
It basically says, give me a function and an argument and I'll give you the answer. So if I do plus two dollar three, I get five.
34:33
But dollar is actually another function in disguise, right?
34:40
Because if you've got a function that takes an eight to be two and a to be well, function types bracket to the right.
34:42
So this is also the same as this.
34:49
So that's a function that takes something of so sexy to something of Typekit sex, which, as we all know, is just exactly what it does.
34:52
So it turns out the zip with I.D. is the function we want.
35:00
If you zip with I.D., you're basically saying, give me a list of functions, a list of arguments.
35:04
I'll give you a list of answers. And indeed, it works.
35:08
So if I do it with I.D. map plus over one to five and I do that over one two five, then end it with what I wanted.
35:10
And so we can call this operation. I tend to call this zap like zap with I.D., and you can think of using it in fixed rates.
35:22
You can sort of say Map Plus. One to five, zap one, two five.
35:31
And it's quite cool because because it's imperfect, you can just chain indefinitely, right?
35:37
So if I did five to 10 and I changed this to be some three argument functions, so.
35:40
Mark, take an axe and give me X Plus. I mean, you need to produce a three argument.
35:50
No need to produce a two argument function here. So I'm going to do X Plus Y Plus said.
35:58
Exactly. And so it's kind of this operator that lets you take.
36:05
If you think how this is working, the first stop turns. So this map turns this list one two five into the list of functions that will add one to
36:11
whatever two arguments come next that will add two to whatever two arguments come next.
36:19
The second zap fills in the second documents of all those functions.
36:22
So now you've got a list of single argument functions. And finally, the last up computes the answer, and so you can successively pass arguments in.
36:26
You can apply functions inside data structures. And so.
36:34
This is great for lists, right, because you could implement Zap using Zip with.
36:40
But what about trees? And maybe, well, you need zip with four trees and is it worth the maybes?
36:46
And you also need one other piece which is here.
36:51
I've use Map to make this function, but what I really want is the ability to take this function and turn it into a list,
36:54
right, so that I can stop it there.
37:02
Six seven eight nine 10. I don't even know how many numbers I need, let's just say 11.
37:06
I need a phone. And so how do I do that? Well.
37:14
Recall that zip with if you've got two lists, the different lengths you, you end up only getting the shorter lengths back right.
37:18
So I need a list of functions that's long enough to zap with whatever argument you give me.
37:26
And but I don't know how long the argument you give me is going to be. So I need to cheat.
37:32
And so the key is to give you an infinite list of functions, right? Because it'll always be long enough.
37:36
So if I use repeat to repeat this function infinitely, then I zap it multiple times.
37:40
I end up with the right answer. So, so with lists, if I've got repeat and this zip with I.D., I can apply lists of functions to lists of arguments.
37:46
And that's the essence of zipping, right? That's what it does.
37:57
And it turns out that that is not quite as useful as a monad, which lets you splice whole list in elsewhere.
38:01
I still can't change the length of the lists, right?
38:07
The lists always have to be the same length, like the functions applied point wise, but I can do something I couldn't do with a map.
38:09
And this structure we call in a collective and it sits between amount and a function.
38:16
And it turns out that if you can implement repeats, which we usually call pure and zap,
38:22
which we usually pronounce like this funky operator I call Apple, then you can implement Zip with for any type as well.
38:28
So I'll do that now quickly. So the class applicator looks like this.
38:35
So you've got to be a factor to be an objective, and I'll show you in a sec.
38:43
And if you are an effective you can implement app which says If you give me, well, I set a list of functions and a list of arguments.
38:47
So when we generalise that we get an f of a two BS and F A's and B's and then this pure,
38:56
which says, if you give me an A., I'll give you an F. full of A's. If we do that, then we can make trees, Aplicativos.
39:06
And how do we do that? Well, it's kind of easy because I've got a branch with some functions on the left,
39:18
a function in the middle of some functions on the right and a branch with some
39:24
arguments on the left and argument in the middle and an argument in the right. So this this tree is of type tree a to be.
39:29
And this is of tree a right, so all these Alexie's, that's a tree of a that's a that's a treaty.
39:38
What's the answer? Well, the answer is a tree of bees.
39:44
How do we get the bees on the left while I play all the functions to all the arguments I play
39:48
have to x and then I apply all the functions on the right to all the arguments on the right.
39:53
Anything else? His empty.
39:58
Why is that? Well, think about it, if I've got two empties, then the answer has to be empty.
40:05
If I've got a branch on the left full of functions but nothing to apply it to, it has to be empty.
40:11
And similarly, if I had a branch on the right full of full of arguments but nothing to apply to those arguments, then the answer's empty.
40:20
So it turns out that just like lists, right, the only way you can do it with is when the lists match or as long as the lists match.
40:29
And so that's how UP works on trees and then pure for trees.
40:36
Well, people are going to have to type a tree and it's a bit like lists, right?
40:40
You need to try to be as big as possible to handle every possible tree someone could throw at you.
40:45
So here I'm going to do Pure X is the infinite tree where it's X, and then the two sub trees are also the infinite tree.
40:50
And if you do that, it turns out, then you can implement this function called lift data,
40:57
which I've imported here I left it to is basically zip with if you see a lift in Aplicativos, but it works on any F. That's a collective.
41:05
And so in the same way, like Zip with Plus works on one two five six two 11, I don't know.
41:14
And whatever lift a two does exactly.
41:20
Oh God damn you lists. OK, let's do stupid butt lift. I too should do the same.
41:25
But if I have a tree, I need to make a tree now.
41:31
But let's just say I do branch branch empty one empty to branch to three empty.
41:35
And let's just copy paste because this is going to take forever, then end it with two four six.
41:47
So I get zip with on trees as well. And again, to the question, it's early.
41:54
I have to implement the instance, but those zips now just let you find zips useful all the time.
41:58
Work all the time. Yes, as Jamie says that the this is where things get interesting, right,
42:03
like there isn't necessarily one instance of a collective for a given type and the list type has to and the default one does a Cartesian product,
42:12
which looks a bit like this list. You may be familiar with.
42:20
So when I did this left data instead of getting the zips, I get OnePlus six, OnePlus seven, OnePlus eight, OnePlus nine, OnePlus 10, 2+ six.
42:29
I get all the possible additions, which is this long list here and that is also a valid, for instance, I would go into a valid means, but.
42:39
And so, yeah, it turns out that we've got this nice hierarchy in high school of factors,
42:48
Aplicativos and moonshots, and they all have different levels of power and they're all useful in their own way.
42:53
But the key thing to think about is the obstruction. And and again, you know, you've learnt Mona is known for building stateful programmes.
43:01
I think Tony showed you how to build a but the key power, why is it useful to call it a monad at all?
43:06
Like why not just write programmes normally like a normal person in a normal language? It's because it gives you an abstraction benefit, right?
43:11
Like, for instance, you can write a pro, you can write your own control flow, right?
43:18
So if you were, you know that in a moment you could do like,
43:22
we can write anything that was going to do block row so we can write our own do all right.
43:27
So if you've programmed an imperative language, you might have seen the dual loop.
43:32
You know, and and this will always execute once and then if this condition is true,
43:38
it'll execute again and it will keep executing until that condition is not true and hospital doesn't have to do well.
43:43
But it's pretty easy to make one. And I wonder what the type is in a minute.
43:48
But if you give me some monastic thing and what do I do the syntax do there is a coincidence.
43:53
Don't worry about it. Well, I'm going to do. And once I need some predicate and then if he then do while PM again else, well, don't do anything.
43:58
So I just I'm going to return an empty value, which is called unit, which will come back to in a bit.
44:11
But if we do that, then I think that what we're going to compile on the base wants to talk with it.
44:17
Yeah. And so do I. It's just a function of high school. But this is why the obstruction is useful.
44:23
It works for any monad. So it says if you give me some condition, which is a boolean and can block of code to execute,
44:28
I will execute a block of code once and then as long as that condition is true, now you need other stuff like steaks.
44:35
Otherwise the conditions are never going to change, right? But, you know, if I do like do well, I mean, this will run forever.
44:41
But print. It because true is always true.
44:46
It will run forever, but you know, that's how like do all works in the language you're used to, right?
44:55
Where the things happening are like statements like print but modern still have to be statements, right?
44:59
If I put one two here, then it's actually never going to.
45:03
What's happening behind the scenes is it's building a huge list is running, can't come up over and over again until it crashes.
45:08
Just try to think there's a neat way to get, let's say, Oh, let's tweak it.
45:14
I mean, this is going to get hairy, I want a way to have this condition. It's fine.
45:23
OK, so I've tweaked do while now, so it's a bit fancier, it says if you give me the Nordic thing that returns a T and a way to test that T,
45:31
I will terminate when this test returns false so I can do something like do while.
45:39
Next is less than 10, and I'll do a computation.
45:46
I mean, this is still a terrible idea, what happens here?
45:52
I wish I could. I still don't. It doesn't matter. It's fine. But the point is like this function.
46:00
Works for any not. And that's why the obstruction is useful.
46:08
You know, you can use it on Ohio State, all kinds of things.
46:11
So, yeah, that's why these things are type classes in high school, and it turns out there's a lot of other stuff like,
46:20
you know, people often start with an intuition for these things as containers like lists are maybe.
46:25
And people often start with an intuition for it is for monotonous things like, Oh yo, state.
46:29
But when you find out they're all connected, it turns out that a lot of that intuition is is useful, but not necessarily complete.
46:34
And there are lots of interesting structures that fall into these classes that aren't necessarily containers or light imperative coding.
46:41
And just kind of maybe leave you a little taste of what that idea looks like in practise.
46:50
I said at the start that you can't write something like funky to any stripe. You can write something like funk to maybe.
46:56
And the question is like, how does Haskell know that you can't write funk to it, right?
47:01
Like if I tried, for instance, funk to it, so we can't do that.
47:05
And how does it know? Well, the reason is the same way it knows that you can't run length on an end.
47:11
And if you try to run like something, what happens? Well, you get a type error. Same thing is true here, like you get a type error effectively.
47:16
And the reason that works is because Typekit in high school also have types we
47:25
call those types kinds so that we don't totally get confused by talking about the
47:31
types of types of types of types and the kind of a type represents kind of it's
47:35
charity like how many arguments that Typekit takes in order to become saturated.
47:42
So maybe has kind type to type.
47:49
It takes the type and it gives you a tote bag. So if you, you know, maybe has kind type to type.
47:53
So maybe it has kind type into the type.
47:59
So if I play, maybe it's int I get a type.
48:02
And so funked is a class that takes any kind of type two type, and that's how she like, how her school knows what can be passed to function.
48:05
And so you've seen some of these types, like tree is a type constructeur has kind, type to type, maybe.
48:16
I know there's loads of them, but I guess one thing to leave you with is.
48:24
How many? One argument functions other in high school. Right?
48:32
Well, there are the obvious ones like length and to upper and Ord and Max the not max's maximum.
48:36
I'm sorry. And all these ones. But there are also like less obvious ones, right?
48:47
Like there's two plus and there's three minus and there's mods to and and so on and so forth because Haskell supports partial application.
48:50
You can partially apply function and arguments to produce a carried application that has organs.
49:02
It turns out. Same is true of types, so you may know the type either either looks like this either A or B is either an A,
49:08
which we say is on the left or it's a B on the right.
49:17
And so either takes two arguments two types like you could say Left hello is a type either string it and so is right.
49:20
42. So either takes two types, but does that mean if I give it one type, I have a one type thing?
49:30
Well, it does, actually. So if I do, either is a type kind, type two, type two type and either string is of kind.
49:40
Type two type and either string in is a kind type.
49:49
And so it turns out that the things in the middle can be partially applied.
49:53
So there's an instance factor, for instance, of either or any ear, turns out.
49:56
And what does that look like?
50:07
Well, if Map has the type A-to-B to either e a tip, either A B and we can get rid of these brackets because they don't do anything.
50:07
And so basically, what that says is that if you've got a left l, then just return as it is.
50:21
But if you've got a right x, then that's going to be of type A. And you've got a function that translates into B's so you can do right.
50:28
And so it turns out that you can do f map two plus on left foo and nothing happens.
50:36
But if you do it on right, 40, 50 to 54 and so partial application works for type two.
50:43
And so there actually are loads more factors than you think. So I'm going to leave you with one last kind of fun two arguments type constructs.
50:50
So either as a two argument type constructor, but there's one that you've probably been using.
50:59
We've definitely been using since day one, and you might think of it as sort of special syntax, but it's not.
51:03
It's actually especially in a way, but it's kind of also normal like everything else.
51:08
And that's arrow, right? So when you write a ruby, that's actually the same as writing Araby.
51:13
And if Arrow, you can see for the kind of a type using code OK and star means type here.
51:22
Can I disable that? Wow, no state had closed for you anyway.
51:30
And so it takes two types arrow and gives you a function Typekit between those types, right?
51:39
So the question is. Well, I'm telling you, there's a focussed instance, pharaoh.
51:43
Where has this type? And there's also an Aplicativo instance, Farrow, where has this type?
51:51
What if I don't there? That's wrong. And Pure has this type A to A and there's also a mounted instance for it.
52:21
Where Bynes has, sorry, a to a two.
52:42
And those all look like absolutely horrific, so I'm going to give you one hidden, which is that you can turn this obviously into each way, right?
52:57
Because. X Z is the same as.
53:04
X Y, which is the same as Exxaro Y, so you can make all these things look neater and that when the types look a bit nita,
53:12
hopefully you'll be able to see what the implementations are. But it turns out the arrow is also a monad, and it's a really useful one as well.
53:19
It's not like some just arbitrary abstract piece of mathematics that happens to be useful and interesting, but not practical is very practical.
53:26
And yeah, it's kind of nothing special, but all these abstractions combine to create a very beautiful environment in which to create you very yeah,
53:35
like complicated programmes for doing useful things like state like Ohio and yeah,
53:42
like mapping over large data sites, which again, it's like the fundamentals of a lot of programmes out there.
53:47
Industry so conscious. I've run out of time. I don't have any more questions or general.
53:51
No star is Typekit. That's it. Thank you. Yeah.
53:57
So the question is what's false? Otherwise, thanks very much. Thank you very much.
54:02
Well, so I guess the challenge is for people to work out what the definitions of those complete those instances.
54:05
I will paste them in the in the team, I guess afterwards if people want the the starting point.
54:12
Yep. Greg, thanks very much. So I mean, that's on.
54:18
I've got students waiting outside my office, so we'll have to stop that assignment very much with the time when you will see what it can
54:23
be between now and the end of the day at the end of this term or beginning of next year.
54:30
Sure, thank you. People, people have questions. Drop them in the team and I'll try and pick them up over the coming weeks.
54:35
Thank you very much. Thanks very much. Good to see you. I have enjoyed it.
54:41