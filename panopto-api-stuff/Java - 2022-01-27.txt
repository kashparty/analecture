Category: Java
Lecturer: Alastair Donaldson
Right.
0:02
So it's lovely to see you all again, a bit of a no on the structure of the course today is going to be my last day of teaching for for a little while.
0:03
Next week, Nick is going to take over and teach concurrency, and it's going to be a little bit of flitting between myself and Nick.
0:11
We're going to try and try and minimise it because I think logically, it kind of makes sense for you to get my materials and then Nick's material.
0:16
The reason we do the flitting, though, is so that you're well equipped to do your labs.
0:23
Nick is going to teach you about concurrency next week. Concurrency is quite tricky.
0:27
So what we do in this course is we divide it into two parts easy concurrency, which isn't easy.
0:32
It's just easy for concurrency. It's going to be next week and then advanced concurrency a bit later in the term.
0:37
And we give you a chance to have a lab on easy concurrency and then a bit of a break and
0:44
then allow on advanced concurrency so that if you find easy concurrency kind of tough,
0:48
you get bit of time to learn from your session. Have a chance for that material to bed in before you're exposed to advanced concurrency.
0:53
So that's the logic for this back and forth.
1:01
You're going to experience what I want today to do today is to get through inheritance and then cover a little bit about generics in Java.
1:03
I might do a little bit less Q&A. I mean, please do ask questions, but I may get less detailed examples, including demos,
1:11
just so that I can definitely get to where I need to get to by the end of today.
1:17
So forgive me if I slightly rush your questions, but so that the deter you from asking them.
1:20
OK. So what we're going to do now is talk about inheritance and inheritance is what a lot of people think object oriented programming is all about.
1:26
I don't know whether this is still the impression people have if they're newcomers to object orientation,
1:35
but certainly when I was studying some years ago, you'd think, Oh yeah, object oriented programming, that's all about inheritance.
1:40
Actually, modern thinking on object oriented programming is that it's all about interfaces.
1:46
The idea that you have an interface,
1:51
whether a formal Java interface or rather a course that has an interface by a bunch of public methods that exposes some behaviour.
1:53
And then you may have multiple implementations of that space that allow you to swap in different implementations of that behaviour.
2:03
And you're going to learn in second year and the software engineer software engineering design course, how to use interfaces,
2:11
and the kind of interface based polymorphism that I've taught you to build high quality software and inheritance,
2:18
which is what we're going to cover today, can be a powerful technique, but actually can lead to code.
2:25
This is rather fragile and hard to maintain and should be used very sparingly.
2:31
So I'm not going to try to go into details of why inheritance can be a bad thing in this course.
2:36
I think that's better left to second year.
2:41
Once you've had quite a lot of programming experience and you're better equipped to think about the subtleties of different designs.
2:43
But it would be very wrong not to teach you about inheritance because it can be a powerful thing to use and for better or for worse,
2:49
you will come across code that makes heavy use of inheritance.
2:57
So even if even if it's not something you should be using that much yourself, you need to know what it is and what it means.
3:00
OK. So with that preamble aside, let's talk about what inheritance is.
3:08
Inheritance is the process of deriving a more specific cost from a more general clause.
3:13
So we have a cost to implement some functionality. And if we would like to have a special version of that functionality,
3:22
it's a bit more detailed than we might use inheritance to make what's called a subclass of the original class that adds that additional detail.
3:29
We talk about the subclass inheriting from the superclass or deriving from the superclass or being a subclass of the superclass.
3:38
All right, so one class can have a subclass or one class can have a super class.
3:51
And I'm going to use these terms deliberately, somewhat interchangeably to give you some exposure to one of them.
3:56
And we're going to go see the language constructs that Java includes to support inheritance.
4:02
And I'm going to make use of this notation, which comes from something called the unified modelling language,
4:08
which is a limitation for software modelling, which didn't really take off.
4:13
But this notation for saying that one class inherits from another is pretty standard.
4:17
So we're going to write B with an arrow towards A and the arrow is going to be hollow.
4:22
To mean that Class B inherits from a Class B is a subclass of a lower Class B is derived from class.
4:28
Those things, I said, they all mean the same thing as a trivial academic example.
4:37
Let's suppose that we had a class representing a core and then say we wanted to then have a cost representing an electric car.
4:44
Quite fashionable these days, we might say the electric car is a subclass of cost electric car.
4:53
He's got all of the properties of car.
5:00
But perhaps it's got some more properties of its own specific to electric cars, and that don't make sense because in general,
5:03
maybe we'd have a petrol car and a hydrogen car as other subclasses,
5:11
because each having their own features that distinguish them from each other and distinguish them from plain old cars.
5:15
OK, so that's the kind of simple example. Or as another example, a polygon is a kind of shape,
5:25
so you might be building an application that works with shapes and you might have
5:31
a class to represent shapes and a subclass specifically to represent polygons.
5:34
And then it might be the case that you want to regard a rectangle as a special kind of polygon,
5:40
and you might want to have a subclass rectangle inherits from Polygon.
5:45
OK. Just as a little aside, this design might be potentially rather bad.
5:51
OK. Because maybe a polygon is quite a general class represented by a whole load of vertices in order.
5:58
And the polygon is going to be the shape you get when you connect up all these vertices and then you have a problem where
6:07
what if you define a polygon with the vertices zero zero one zero zero one and one one zero zero one zero one one zero one,
6:13
say that way. So should that be a polygon or should it be a rectangle, right?
6:27
It's a rectangular polygon. So you might get a horrible situation where you've got some objects that are polygons that happen to be rectangles,
6:32
but there are no instances of the rectangle class.
6:40
And you may have some other objects that are instances of the rectangle cost and then you run into difficulties,
6:43
like should these rectangular polygons be regarded as equivalent to these specifically rectangles?
6:48
So this might not actually be a very good way to use inheritance in practise,
6:56
but as an example, a rectangle is a kind of polygon that is a kind of shape.
7:00
OK. So to give you a couple more examples, a Ph.D. student, which perhaps some of you will go into be one day,
7:07
I hope some of you will be quite difficult in London with so many tech companies around to pay these amazing salaries to convince people to do PhDs.
7:13
But I can assure you it can be very fulfilling and exciting experience.
7:20
A student is a kind of student, but unlike other kinds of students,
7:24
a student writes a thesis and they have a Ph.D. supervisor and typically a Ph.D. student doesn't take courses.
7:29
OK, so they've got some things that make them specifically students. But like other courses, like other students, they've got to register.
7:37
They have a department, they have a log in.
7:45
So they have various things in common with all other students, and they've got some things that specifically make them students.
7:47
So we might if we were modelling a system which with various kinds of students might have a student class,
7:54
has got functionality like gets in getting the log in for a student or setting the log in for a student.
7:59
And then we might have a student subclass that's got functions,
8:06
methods related to having a supervisor, having a completion date, having a dissertation or whatever.
8:10
It's given a couple of examples here and then it might make sense for the student to be a subclass of student.
8:16
So what this means is that a Ph.D. student has a method get supervisor, get thesis title,
8:23
but it also has a method get log in and set log in because it inherits those methods from its superclass.
8:30
So when a when a class is a subclass of another class,
8:38
the cost has all or the methods and all of the fields of that super class, plus possibly some more of its own.
8:42
And then an undergraduate student in the Department of Computing has got a personal programming tutor,
8:50
a mathematics tutor and a personal tutor, which typically is one of the above.
8:55
So an undergraduate student in our department might be represented as a student.
9:00
So having get log in set Logan,
9:04
but also having these additional methods and relevant state internally by fields to record the fact that a student has got an MD and a tutor.
9:07
OK, that makes sense. So the real the real key thing here is that we regard.
9:19
Student as being part of undergraduate. Right, so the undergraduate course is like the student class with these extra things.
9:26
So if you have an object of type undergraduate, you can ask on that object, what is your log in?
9:38
But if you have an object of type student, just type student, you can't ask, what is your tutor?
9:44
OK. Right. So undergraduate and postgraduate, undergraduate and Ph.D. student, they inherit all the fields and methods of student.
9:51
OK, let's go through a few more examples, so say we had a car example, an electric car is a kind of car, but it runs with an electric engine.
10:07
So if we were to model this using inheritance, then car would be the superclass of electric car, a.k.a. the parents of electric car.
10:15
Electric car will be a child class or subclass of car.
10:24
We would say that car generalises electric car. So an electric car is a more specific kind of car.
10:29
A car is a generalisation of electric car. Conversely, electric cars a subclass of car, a.k.a. a derived class.
10:36
All right, it's a specialisation of car. And looking at this with some diagrams.
10:45
Let's say that a car has got fields, colour, model, mileage and then some methods to inspect the car.
10:50
Maybe start, stop, move to make the car, do some things, then an electric car.
10:56
If it subclass a car, it would have all of those fields and all of those methods.
11:01
But then it might have its own fields and methods, in addition. So, for example,
11:07
they might have a field representing its engine because it's specifically an electric engine and a petrol car might have its own engine.
11:11
It's got a different type, say, petrol engine. OK, so the key thing again is that petrol car, an electric car.
11:18
Here, they inherits all of the fields and all of the methods from that supercross car.
11:27
So we can look at some code soon, but this is just the general concept of inheritance.
11:36
And I wonder at this point, as everybody questions about the general conception for gasoline and electricity,
11:40
can an interface separate from another interface? Can an interface inherit from another interface?
11:45
That's a great question, and interface can extend another interface.
11:50
Yeah, we typically talk about an interface extending another interface rather than inherited from it,
11:53
although I'm sure people do use the term inherit as well. Yes, indeed.
11:57
And that's actually a much simpler concept than classes inheriting from each other.
12:00
And we're going to come to that, not today. So we'll come to that when I come back to teach you after you do concurrency.
12:05
Would that be any like and why inheritance might be required to re interfaces?
12:12
The reason inheritance? The question was, is there a reason why inheritance might be preferred over interfaces?
12:18
The reason is that in interfaces, you don't have any state recall that interfaces simply specify the signatures of methods.
12:23
They don't specify any fields, and they don't specify how methods should actually be implemented.
12:31
There's something called a default method that we're going to study a bit later,
12:38
which is an exception to what I just said, but it has a particular purpose in Java.
12:41
So if you recall from the the document manager example I used near the start of the term,
12:47
we had page element and then we had those different kinds of page elements.
12:54
And they all had an ID. They all had a width and they all had a height.
12:59
Well, in what I showed you so far. The page element interface, because it kind of feels it can capture the common field's width height,
13:03
and it still had to declare all those fields in each of the kinds of page elements, right with inheritance.
13:11
We could put all that common stuff in one place in a class and then have a particular page.
13:17
Elements extend that cost. And we will come back to that specific example later on.
13:22
So if you want to reuse functionality, if you want to reuse state that inheritance is one mechanism that lets you do that.
13:27
OK? There's another mechanism that's called composition, where you say the stuff I want to reuse.
13:36
I have a field of an object that has that stuff inside it, and that is typically preferred in modern development over inheritance.
13:42
And that's that's what you write more about in secondary schools. OK, any other questions tonight?
13:51
So, OK, so I'm going to go through an example here with alarm, right?
13:59
We're going to have a little cost to represent a lamp that could be turned on and off,
14:05
and then we're going to have a sub cost representing a lamp that can be dim so it can be turned on and off and it can also be dead.
14:09
OK, so our lamp example can be turned on or off by pressing a switch.
14:16
So the way we might model this cost is to have a Boolean field is on is on is going to be true if the lamp is on both,
14:21
if the lamp is off and then a couple of methods. Press switch, which is going to mutate the state of the lamp.
14:29
So it's going to toggle that field and to string what's going to show the lamp as a stream is going to turn into a string.
14:36
OK? And then an adjustable arm is one of these lamps.
14:44
There's going to be dimmable. If you come across as lamps, you can tap them and they dim and.
14:48
Those lines I find to be a lifesaver when I first had young children, because boy, if you've got a young child, a baby, get to sleep,
14:54
you put it down in the call and then you turn the lights off and it goes click and suddenly they're crying and you're back to square one.
15:01
Whereas if you've got an adjustable, I'm going to keep it and then the floor creaks and they wake up anyway.
15:10
But you got more. You got more chance of escaping with adjustable level.
15:16
OK, so an adjustable arm would need to have a field to represent its brightness, so it's still going to be on or off.
15:21
But if it's on,
15:29
then the brightness is going to say how bright the lamp is and then we need this ability to dim light so methods to make the brightness go down right?
15:30
So it might make sense, but adjustable up to be a subclass of Lamp, an adjustable arm has a switch to turn it globally on or off.
15:40
So press switch makes sense. It therefore makes sense for it to have an is on field that represents that state.
15:48
But in addition, it needs a brightness field so that if it is on how bright it is, we've got an extra capability.
15:56
It can be dimmed and we would like to be able to represent the adjustable as a string just in the same way we can represent the lamp as a strength.
16:02
But we'd probably want to show more information we'd like to show. Not just is it on or off, but if it's on, how bright is it?
16:10
OK, so let's write some Java code to to implement this.
16:17
And in this Java code, we're going to have a couple more key words and this protected key white and blue.
16:22
I'm going to explain the meaning of when we introduce adjustable lamp, so overprotective flag.
16:28
You could for now think of it as being private, which can be like fields to be private.
16:34
Normally so our lamp has got a field is on. We construct a lamp by saying whether it's on initially.
16:38
And Prestwick is going to Togo, is on, so is on gets updated to be not is on.
16:46
So it toggles and treat false to straight. We're going to return a string, so lamp open brackets and then on our off the closed brackets.
16:52
And this is when my favourite operators in any programming language, the if else operator see you a boolean question mark.
17:00
One value code on. Another value and you get the first value if the Boolean is true and the second value otherwise.
17:06
For some reason, I find it very pleasing, writing the operator think.
17:13
Often it's just because you can avoid having to have an if statement, which is quite nice.
17:16
OK, but that's not really relevant to inheritance. OK, so this is a simple class representing a lump.
17:21
So here's how we might implement adjustable as a subclass of lump.
17:28
The first thing we do is we say the cost adjustable extends lump.
17:33
So the extends keyword is how you say the one class is a subclass of another class name extends the superclass name.
17:39
Then you can give it more fields, so we want to get a brightness field, and we're going to make that be a private field.
17:51
We're not going to make it final because we know this field is going to change. A private practise.
17:57
And when we construct an adjustable arm, what do we need to do?
18:02
Well, we need to construct the lamp part of the adjustable lamp and then we need to fill in the details.
18:07
Of what makes a Plan B adjustable, so to construct the lounge part.
18:14
We use the super keyboard. So we say super is on, and what that does is it says to construct the lamp.
18:19
Part of me call the single argument constructor of Lamp that accepts a Boolean.
18:28
All right. So does Lamp have a single argument, constructor excepting oblivion? Yes, it does.
18:35
So you've got one constructor and that's the constructor.
18:39
So Super is on explains how the superclass part of this adjustable lamp part should be created.
18:42
You must always start your subclass constructor with a call to a super cost constructor.
18:52
So if you admitted to that line, if you commented that the code wouldn't compile,
18:59
the compiler would say You've not made a call to Super to explain how you want to construct the superclass part.
19:03
There's one exception to that if the super clause doesn't have a constructor, right?
19:10
So if we didn't have any constructor here,
19:15
that would mean that the clause would have a default constructor and the default constructor would set is on to false.
19:17
False is the default value for a Boolean.
19:24
And in that case, if my memory serves me correctly, we wouldn't need a Super Bowl here because there would be only one choice, right?
19:27
We could write super open parenthesis close parenthesis,
19:35
but I believe Java will let us get away with not writing anything because that's the only possible way to construct the superclass.
19:39
OK. But more generally, when you do have a non default constructor like we do here for lunch, we got to specify how that constructor should be called.
19:47
And if there were more than one, if there's more than one constructor,
19:56
we even more urgently need to say which one we want to use and then we can plug in the brightness field.
19:59
So here I set brightness becomes equal to 10.
20:05
If the lamp is on otherwise zero. OK, now the press switch methods.
20:09
Well, what did the press switch method do before it toggles is on field, so we'd still like it to do that.
20:15
But we'd like it to be that if you press the switch and the light was on, it goes off and vice versa.
20:21
But we'd also like to do something with the brightness. We don't really want to have an off lamp.
20:26
This got brightness six. It might not match that.
20:30
We might say, well, the brightness just doesn't mean anything if the lamps off,
20:34
but it might be a bit cleaner to say if the lamp is off, the brightness is zero.
20:36
So what we could do that is, we can say Super Dot press switch.
20:41
That means call the press switch method of lamp. So that will do the trick of toggling is on.
20:44
And then we can do whatever else we need to do in order to be an adjustable arm.
20:52
Specifically, we could say that if the lamp is now off, the brightness becomes zero.
20:58
OK, and if the light was just being turned on, the brightness becomes 10.
21:05
As a brief site, can someone remark on a couple of things that are potentially not very nice about this code over code quality,
21:10
but if you please using magic numbers, if that happens, I'm using magic numbers like 10 and zero in particular, 10 zero.
21:17
Normally, it's obvious why you use zero and it would be a waste of time to have a special constant zero meaning like off or no value.
21:26
But I think using a a constant max brightness instead of 10 would be much nicer than using 10.
21:36
The fact that repeated line of brightness is equal to is on.
21:43
Yeah. So this code here, the ship with the code, it would better to extract into a helper method and initialise brightness,
21:46
reset brightness and call out from both places. I know this is a rather trivial piece of code.
21:53
It's not like these two lines give us much of a maintenance burden,
21:58
but the general principle is if you've got functionality that logically is doing the same thing, it's not coincidentally coincidentally at the same.
22:01
It really is the same because it's doing the same thing,
22:10
trying to extract that into a single place so that if you need to change, it will fix a bug in it or optimise it.
22:12
You optimise it in that one place. No, go overboard. But if you see code that looks similar, doesn't have really much to do each other.
22:17
Don't try and make matters more complex. That just makes your programme become a mess.
22:24
OK? And then dim is something that doesn't exist in total.
22:29
It's a method. We're adding an adjustable up. So what did Mike do is say, well, if the lamp is not on, don't do anything right.
22:34
Dim alarm is off. That's a no OK.
22:42
But if I'm his own and if the brightness is positive or if the brightness is, say, go to the one, then decrement the brightness by one.
22:44
So what I've done here is I've said, you can't turn that I'm completely off by dimming it if it gets the one about 80 dimmer.
22:53
So that's not much use for my child care scenario mentioned earlier where you want it to be turned off.
23:00
You'd have to turn off the switch, but detail doesn't matter for the inheritance point.
23:05
I'm trying to make it. And then to string, we might say the lamp has an adjustable lamp.
23:11
We'd say whether it's on or off. And maybe we'd also have a comment. And then it's brightness.
23:18
So let's unpack what's going on a bit here. First of all, the key word is what allows us to reference is on here.
23:25
So this is on is not a field of this class.
23:34
It's not a parameter to to string. It's not a local variable declared in this method.
23:38
It refers to a field of the super class is on.
23:43
If we'd made that field public. It would be visible because it would be visible everywhere.
23:47
If we made it defaults, so we've not had any keyword for visibility here,
23:53
it would be visible if these courses are in the same package by making it protected.
23:58
What we're saying is this field is visible to any subclasses.
24:03
My clicker? By making it protected, we're saying iSone is available to any subclasses of.
24:08
They can all see this field, right, so that's why we're able to reference the field here.
24:20
The protected enables visibility in subclasses and as we noted, it would be better to extract this code into a common method.
24:26
OK, so a few things we learnt here. Then a derived object extends its superclass, specifically adjustable and extended in this example.
24:34
And if extended it with the brightness field and the dim method.
24:44
So it added a field out of the method. Subclasses derived classes inherit all of the fields and methods of their super classes,
24:48
so adjustable has a press switch method and it has and is on field because it extends down.
24:58
You can override a method of a supercar, so in particular the press switch method and adjustable,
25:08
and we overrode it and said we actually want some extra behaviour.
25:14
We want to do what was already done. Toggle the switch. In addition, we want to to reset the brightness.
25:18
So we overrode that method. And quite an important distinction is between overriding and overloading.
25:25
So just get this in your heads, then overloading,
25:34
which you're familiar with from high school and you familiar with it from Cortland and Java is where you just have multiple methods.
25:37
They've got the same name and they take different argument types. Overloading is quite simple.
25:42
Basically, you could remove overloading from your programme by renaming every version of the method with something to distinguish it right.
25:47
You could underscore one underscore to underscore three underscore four at the end of all those methods,
25:56
your and I look quite horrible, but now you wouldn't have any ambiguity about all the methods would be called different things.
26:01
So overloading is really just something to make life more convenient for programmers.
26:08
Overriding something completely different means when you are inheriting one class from another,
26:12
you would like to change the way a method from the super class behaves if it gets cold on the subclass.
26:19
Yes, in Java, when you override a function, you don't have to like. Mention anything which says, Oh, so the crash was in Java.
26:26
Do you need to say anything to explicitly note that you are overriding the function?
26:36
The answer is you do not strictly have to, but you always should write.
26:40
So in this code here, which goes to show you in the laws that I just had press which declared again in
26:45
industrial and I'm going to come a bit later to the act override annotation in Java,
26:51
which is a way of documenting your attempts to do that. And Java needs to be backwards compatible, so it's not possible to make that be a requirement.
26:55
In Java, it can only be optional, but that overrides when you write that that doesn't do anything.
27:05
That's just what you read when you write an override.
27:10
What it does is it stops your programme from compiling if you're not really overwriting anything else.
27:13
So if you misspelled press switch like press switch like an extra h say and you'd write an override above it, the co-pilot would say, Wait a minute.
27:19
There's no method called press switch in and you go, Oh, I see, I made a mistake.
27:26
Whereas if you don't use that override, it just looks like you're adding another method called press switch.
27:32
And when you call press, which it calls the one, it doesn't call one.
27:37
And it just does that make sense? And I'll give some more examples of that later.
27:40
OK. And you can access, as usual, public fields and public methods of your superclass,
27:46
but you can also access protected fields and methods of your supercars.
27:54
So protected gives a bit more nuance to visibility in a Java programme, and protected is available in various other programming languages, too.
27:58
OK. And yeah, we also looked at super.
28:07
That's the key word we can use in a constructor to explain which constructor of the super we want to invoke.
28:12
And it's a method we can invoke in a subclass method to say, I don't want to completely replace what the supergrass method did.
28:18
I want to call it maybe use its results and do something in addition.
28:25
So you can use super to the super method.
28:30
OK, now I want to talk about something extremely important, both with respect to clauses and with respect to interfaces,
28:35
which we covered informally a bit on Tuesday, which is the notion of actual types and apparent types.
28:45
And this is super important and. If you didn't follow those last examples, does it matter?
28:52
Switch on here, and this should should make sense.
29:00
So the apparent type of an object is the type you use when you declare the variable or the or the parameter of the field.
29:02
Yeah. So the question is, if you if you want to overwrite and completely replace the functionality, how would you do that?
29:13
So first of all, that's typically quite bad practise, just just to say, but if you did want to do it, just don't make a super call.
29:25
Right, so if we had.
29:32
And then you go back to this example here, suppose in dim, you know, sorry, supposing press switch, we didn't want to affect whether the lamp is on.
29:35
Which would be crazy, but I say that's what we wanted to do. Then we would just delete that line of code.
29:48
OK, and now we would press the switch on the lamp and it would change the brightness, but we would be unable to turn the lamp off.
29:54
And if that's for some reason what we wanted, that's how we achieve it. OK.
30:01
Right.
30:09
So the apparent type of an object is the type we use a declaration when we declare a variable, it's the type on the left hand side of the variable.
30:09
When we declare a parameter is the type of the parameter, when we declare a field that it's the type of the field.
30:17
That's the object's apparent Typekit.
30:22
And this is the type that's available to the compiler, to the compiler says, OK, I can trivially know that your declaration has that type.
30:25
I can see Lamp L equals potentially something quite complex.
30:33
And I knew immediately the owl has got type. That's what the apparent type is.
30:37
In contrast, the actual type of an object is the type that it really has when the programme is running.
30:44
So if I say that AL is a new adjustable lamp.
30:50
Then then when that call to new returns, the reference will point into the heat and object with type adjustable lump.
30:55
So its actual type will be adjustable up, but it's apparent tight when just looking at the text of the programme.
31:05
Looking at the way variables would be declared, its apparent type is lump.
31:11
And the rule here is that the apparent type has got to be a super type of the actual type.
31:16
So in the context of inheritance, if you've got costs as a hobby.
31:24
Then it would be fine for something to have actual Taipei, an apparent Taipei.
31:30
That would be fine. A is a subtype of itself. OK.
31:35
And B, if B extends a B is a subtype of AA,
31:39
so b fine to say that something of a parent type A is what actual type B was not OK is the other way round to say this looks like a B,
31:43
but really it's only in a.
31:53
And the problem is that if it looks like a B, we might try and do B ish things to it, but it's not really a B that would make any sense.
31:56
OK?
32:03
Whereas if it looks like an A and we want to do a ish things to it, but it's really a b because a b is it a we'll be able to do a ish things to it.
32:04
OK. Asian B issue, whereas I just invented.
32:14
So this would be wrong if we said adjustable up L is a new lump that wouldn't compile because
32:18
here we've tried to say the same thing with parent type adjustable arm as actual type lump.
32:25
And it makes sense for this not to compile because if we've got an adjustable amp, we should be able to dim it,
32:32
but we can't dim just the lamp dimming was something we could only do on an adjustable lamp.
32:38
And the reason this matters is that the methods and fields you're allowed to call or
32:46
look at on an object reference are based on the apparent type of that object reference.
32:52
This means that when the compiler is looking at your code,
32:58
when it sees you're trying to look and feel good for Mexican food, it says, OK, what's the apparent type of this thing?
33:01
Go to the declaration, look at its apparent type and then ask, Does that type have that field?
33:07
Have that method? And if it doesn't comply?
33:12
So this might look like it should work, declarer alam l an initialise it to a new adjustable lap and then try to delete it.
33:16
You might think, what's the problem there, al-Islam? And it isn't adjustable.
33:27
You can see. So why can't we did it? And the well, the fact is that illegal java, it would be illegal C++, it equivalent C++.
33:30
It would be illegal C-sharp. It's illegal in most statically typed programming languages.
33:41
And the there are two reasons why it's good for it to be illegal.
33:47
Reason number one is that although here it would be quite easy for some sort of programme analysis to work out, the URL is really only just for them.
33:54
If we made this a bit more complicated, what if we actually called a method the return in some length?
34:02
Would we go look at our method and work out what is retiring?
34:06
Or if that method called another method the code another method to code another method to code another method?
34:09
Like at what point should the compilers responsibility to determine what the type of that is really going to be?
34:13
When should that stop? So just saying you can call things based on their apparent types is a really simple rule.
34:21
That means the computer goes well. Then what's the apparent type of lamp?
34:27
Does Lam have a dim method? No complain. So that's nice and simple.
34:31
Makes it easy for the compiler. Easy for the programme to know what's going on.
34:35
The second reason is that, as discussed before with the list's example, the ArrayList, the linguists business we talked about last time,
34:40
it might be that actually we don't really want to commit to this always being an adjustable lamp.
34:47
It might be that we would really like some sort of lamp, and in the future, we might want to drop in a different kind of lamp.
34:54
And if we were allowed to call, given that if we change our mind here.
35:00
Our programme would break. All right. So that's the those are the kind of two reasons why it's quite good for this rule to be the way things are.
35:05
Java checks these rules at compile time. I think Nic, who's going to speak,
35:14
who's an expert in type theory and functional programming and the relationship between category theory and type theory,
35:18
he probably would scream at this next statement.
35:24
But I'm going to say here that Java as a strongly typed language in Java as a statically typed language.
35:27
Now, don't go near people who are in it type system and use these terms because they'll
35:33
basically just get into a big argument about what it means to be strongly typed,
35:36
what it means to be statically typed. But roughly speaking,
35:40
we say that a language is strongly typed if a programme that is a well typed well will be flagged up either at compile time or one time is bad.
35:43
So I think most people would agree that Java is a strongly type language. A lot of programmes that have typing problems would compile.
35:55
And then there are other kinds of typing problems that get checked when the programme runs. So Java, because it's designed to be secure,
36:02
doesn't have the property that if you get things wrong with your Typekit, your programme just might corrupt memory.
36:08
Java doesn't have that property. That's more in the realm of C++, and statically typed means that the type checking is all done at compile time.
36:14
And that's not really true for Java, but it's basically true.
36:23
So as you, I'm sure have experienced, the co-pilot will complain that you quite a lot until you get things right.
36:26
OK, so that's what I mean by being statically types.
36:32
However, there are some typing text I'd done when the programme runs, so it's not completely true to say it's a statically typed language, which.
36:34
OK, so before I come into this late biting side, are there any questions about what I mean by apparent type,
36:46
I mean by actual type or how they work together?
36:54
Quite an important concept, so perhaps spend a bit of time on it? Yes, I've seen examples of situations where wrong time?
36:57
Yeah. And after Nick teaches you concurrency, no, I think we're going to I think we're going to do today, going to talk about object casting,
37:05
which is where you say right at this point in the programme, I know that object is really going to be an adjustable lab.
37:14
It's got a parent type lamp.
37:21
But for some reason, based on the way I built the programme, I know when we reached that statement it's really going to be an adjustable lamp.
37:22
So I want to cast it to an adjustable lamp so I can dinette.
37:28
That casting operation, which will come to shorten, isn't something that the compiler can ascertain is safe or was unsafe until the programme runs.
37:34
Java will check at runtime when you do that cost. OK, OK. Is it actual type adjustable?
37:43
And if not, it'll throw an exception. So that's an example of dynamic Typekit.
37:48
OK. If you programme in Python, you might be familiar with the sort of situation where you programme trundles along until you use,
37:53
say, a field of objects that exist when you call a function that doesn't exist. And that's an example of extreme dynamic Typekit hope for the best.
38:00
When things don't work out, then complain.
38:06
That's why testing is super important in any programming language, but in language that Python really, really have to be testing everything.
38:10
Otherwise, you may have swathes of code that you just not been hitting for a while, and you may have introduced horrible type errors.
38:17
And until you then run an input, it hits that code. You don't know whether languages like Haskell or, to a lesser extent, Java.
38:22
The type system gets rid of a lot of stupid mistakes that you may have made stupid mistakes.
38:30
Just mistakes that we make because we humans gets rid of a lot of them by the type system.
38:34
OK, so the next concept I want to go to is called late binding, and the idea of late binding is that when we've got inheritance,
38:41
we don't actually know until runtime which version of a method we'll get called by a particular method call.
38:49
So I have a little example here, and these examples are just kind of. Toy examples to get points across.
38:58
You know, you don't really write code about rooms with lamps in them. But let's say we had a room with a lamp with it, costs could room.
39:04
We've got that rooms got a lamp. And when we construct the room, we pass in a reference to a lamp.
39:14
Now all that's required is that we pass in some object that is a lamp.
39:20
It could be a lamp. It could be an adjustable arm. It could be a fancy adjustable.
39:27
And it could be a really special adjustable lamp. It could be a digital lamp.
39:31
It could be an analogue lamp. It could be any subclass of Lamp.
39:35
So all this is saying is I need a lamp, and this lamp field is capable of referring to any object that is a lamp.
39:40
OK, then this room is a funny, strange room and it has a strobe it uses.
39:49
The lamp is a strobe. So when we call strobe, it's got a pulse from a certain number of times.
39:53
It's going to loop lots of times and we're going to simulate pulsing the lamp by printing the string representation of the lamp.
39:59
Pressing the lamp switch, printing it again and parts of the switch again. So this lamp is going to be flashing on and off.
40:07
OK, now, if we have a method example, what that method can do is it can make a new room object and to make a new room object,
40:14
it's got to pass in some sort of lamp. But if you want, it could pass in an adjustable lamp that's initially off doesn't have to pass in a lamp.
40:23
And then it could strobe in the room. OK, so if you think about it when pressed Switch gets cold here,
40:34
is it going to be the version of press which we overrode in adjustable lamp or is it
40:43
going to be the plain old version of press switch that we wrote in the lamp costs?
40:49
So imagine the compiler is compiling this class, is it?
40:55
No, we're going to do this, it's not seen this code, it's just trying to compile that class into Java bytecode to be to run and this slump.
40:59
It's got to issue a method called what methods should it cohere?
41:10
And it is the original left, the original, and it's white because it's not the only KASEI telling the compiler that it's a pipeline.
41:19
OK, so you might say, well, because because we've said, I'm here, you should call the lamp version of the message.
41:32
So that could be one way we could implement the which is not how it works in Java for that could could be in theory.
41:39
And that would be like a consistent rule for a language to have.
41:44
Yeah. And so if the octreotide has override the function?
41:48
Right. I spoke with. OK.
41:53
The answer that was if the actual type runtime is a type that overrides that function, it should call the ovaries original version of the function.
42:01
Otherwise, it should call the known over it enmeshment functions. And that's exactly the case.
42:09
This is going to lead to binding the bind between the name of the method press switch and the
42:14
actual method that gets cold is made at runtime based on knowing what Lamp actually refers to.
42:21
So you can imagine the compiler issuing some code saying if the real type if the actual type of lamp is lamp code lamps press,
42:30
which if the actual type of lamp is adjustable lamp kohl adjustable lamps press,
42:38
which would have to do that for all the possible kind of versions of LAMP.
42:43
It's not quite how a compiler works, but that's a reasonably good mental model as to think,
42:48
OK, what kind of object do I really have when I'm executing this line of code here?
42:52
What kind of object is Lamp? Depending on the kind of object it is, then invoke the correct version of the method.
42:57
So this is called late binding,
43:05
and the Java virtual machine that runs the programme after it's been compiled will decide based on the actual type of the lamp,
43:07
whether to call adjustable lamps, press switch or lamps press switch.
43:17
Why is it the case that that will exist? A suitable method to call?
43:23
Yes, because if we don't avoid it, it would just use the punch from the original left. Exactly.
43:29
If we don't overwrite it, it will use the original function.
43:33
So because the available methods are determined based on apparent type, because LAMP as a parent type lamp press,
43:36
which is guaranteed to be a method of lamp or a method of one of lamp super classes, you have super classes.
43:47
So there is going to be a method.
43:54
It will either be an overwritten version of the method or non overridden version of the method, but it won't just be no method.
43:56
If we think about the. Example.
44:02
And I want to give you. OK, if you think about this example here, adjustable up L equals new lamp say we had gone on to L Dim.
44:13
The reason this is nonsense is if we allowed it to, if we tried to make it non nonsense.
44:28
When the programme got to Elgin, the Java virtual machine would say, OK, let's find out what then is so I can call it.
44:34
And then it would go, well, hang on a minute. Lam doesn't have a dead method. There's nothing I can do.
44:40
So that wouldn't make any sense. OK. Good.
44:44
So what I'll do before we take a break is go through this slide on some examples of binding and typing issues.
44:50
So I'm going to go through this line by line and we'll show what the programme would print. OK, so we've got a declaration here.
44:58
Lamp L equals new lamp. So just show to me if you try to draw a line as well.
45:04
What is the apparent type about, OK? After we execute that line of code, what will the actual type of that'll be a bit lighter, please?
45:07
Lamp. OK, great. So when we print out, remember when we print out the two string method of is going to get cold,
45:17
so we would say Lamp, all right y on because we pass through into the constructor.
45:24
Then we press switch and print out. And we see landfall.
45:29
OK. Why does this line of code not compile? Method someone someone say it, realising he was not on the set, there was none.
45:34
That's not really likely. But thank you, breadstick.
45:47
The trouble is with the mask the countries used, we're going to say that is it because the method is not defined on the left?
45:50
The dead method is not the final. The lamp. Very good. So could you spell out for me more precisely that?
45:58
Could you try and articulate it using the terms apparent type and actual type four and or.
46:03
So this is the actual type.
46:11
This is due to the method not being found on the actual Typekit. No, quite OK.
46:17
Yeah, that is it. Is it the apparent type of Al doesn't have a dime?
46:22
That's correct. The apparent type about doesn't have them. So we got what if this wasn't common today?
46:29
The Car2Go? What is El Al? Is this declaration what's it's a power type lamp?
46:33
What am I trying to call them? Look through the methods of I don't see them.
46:37
That makes sense. Good. OK, so then here we print adjustable.
46:42
Now we're going to say adjustable. I'm agile is a new adjustable out false.
46:49
So what is the apparent Typekit? Yeah.
46:53
After we execute that, what will its actual Typekit also of? Yeah.
46:57
OK. So then we print this bump and we see of zero for the brightness.
47:01
OK, then we press the switch. We didn't, and we print it again.
47:06
So we do see that a lamp is on. It's so bright is nine because we did it once.
47:10
OK, now we're going to do an assignment. We're going to say all becomes equal to new adjustable lamp false.
47:14
So after we do that assignment, what is the apparent Typekit l?
47:21
Yeah. Good. OK. So the apparent type about never changes,
47:28
some things apparent Typekit change LS apparent type is and will always be lump because that's what the text of the programme says.
47:32
OK, after we execute this, what will the actual type of lump be adjustable so we can think in memory?
47:42
And let me use the whiteboard preset for the folks on right.
47:51
We can think in memory that we have on our programme stack, we had Al, but that's happened in my back.
48:03
OK, so the programmes stuck. You've got Al, OK.
48:19
And the tight the apparent hype about Islam. So Al is allowed to refer to anything of Hydra.
48:26
And then in the programmes heat. From this first line of code.
48:33
We made a lamp object. And is on.
48:40
What is true? OK, what do we do to that?
48:49
We turned it off. So we use it again.
48:53
Well, that's what we did with it. So is on became false.
48:58
L was referring to this lamp object. So when we execute that statement,
49:05
our company put a new adjustable and false because someone wanted to talk me through what's going to actually happen.
49:10
It would be great. You don't need a new object gets created.
49:19
Which is itself an adjustable lap. And then the reference on the stack is changed to point to this new object.
49:25
Very good. So a new object to create an adjustable lamp? So is is that going to have what feels is adjustable?
49:33
I'm going to have inside apps is on shelves and then its brightness will be good.
49:39
Why does it have it on? Because it inherits from Lamp, so it has to have its own.
49:46
It still has to be done right.
49:54
So it inherits from mom, so it still goes on. And it's also got brightness.
49:59
So now when we do, the assignment all becomes equal to that new object.
50:02
It's like this pointer gets swung down to point to this different object.
50:07
Does that object that exists? When is it likely to exist a millisecond after a microsecond after?
50:12
That's garbage collectors. So that object will there will be there will be a period of time,
50:21
a non-zero period of time during which the object still exists, but is garbage is garbage because it's not possible for any.
50:26
Part of the programme to reach that object in this simple bit of code, be right here, right?
50:35
We could have written something more complicated where it would have been another variable on the stack pointing to it.
50:39
And then at some point in the future, it might get garbage collected. The garbage patch runs periodically.
50:45
It's not guaranteed to run before your programme terminates.
50:50
If your programme terminates, everything gets collected, so there's no need for the garbage collector to run.
50:52
OK, that's carry on with the example of the preview to show the secretary.
50:57
OK, so. Yes. Now, Alice still got a parent type lump, but it's got actual type adjustable lump.
51:07
So then when we print through Elle, we will see something completely different. So I'm here.
51:15
We printed through print it out and we saw a lamp off. Now we print out and we see adjustable lamppost.
51:20
And that's because before printing this objects appear on the board and now we're printing that object here on the board.
51:26
So it's just a reference to an object, and it refers to a completely different object.
51:33
OK. Let me press the switch. And then if we try to demo, we get a compile error.
51:38
Why do we get a compile error? It's.
51:44
Sorry. It was some time it still matters because the apparent hype is still on.
51:50
Excellent. So the co-pilot says, What's the apparent hype about Islam?
51:55
Does mom have them? No compiler. So this album is just as illegal as that l got them.
51:59
Even though in theory, that could work because actually, Ali Al is referring to an adjustable arm, so in theory, that could work.
52:06
Whereas this one could never work, but neither neither of them compile because the language has nice,
52:14
simple rules saying you're allowed to call methods if they're available when you look at the current text.
52:19
All right, any questions? OK, let's take a 10 minute break and then we'll get back to it.
52:25
Yes, there's no doubt about it. I did it last night and I come back to school.
52:33
I'm going. Can I just check?
52:56
I'm suspicious because the horrible Zoom thing is gone, which is great, but can I check that the folks on Zoom can see my screen?
53:08
No, we can't see a scroll see making sure I just saw the screen check.
53:17
And it's back. OK. It's even too good to be true.
53:27
And it was right.
53:31
So I've introduced the idea of inheritance and appearance and actual types.
53:35
What I'm going to do now is I'm going to finish the studies about inheritance and then I'm going to switch to the next stack
53:41
of sites and go through some stuff about object costing and generics that I really want to teach you before Nick takes over.
53:47
And then there's some other stuff in these slides on interfaces that we probably won't have time to get through today on our revisit.
53:54
That is kind of reinforcement revising what what we've already learnt.
53:59
I think I'll come back to that when I come back to teach you in a couple of weeks. So I want to talk a bit about private members and visibility.
54:04
So just get rid of this thing at the bottom second.
54:17
So if you've got a private member in a subclass, so if you recall, Adjustable had a brightness field,
54:22
if we then made another subclass of adjustable lamp, it wouldn't be able to see that member explicitly.
54:29
It wouldn't be able to refer to it by name because it's private. And the supergrass.
54:35
So nevertheless, if you had a cheap adjustable lump say that was a subclass of adjustable AMP, it would have a brightness field inside it.
54:40
Every instance about object would have a private feel with brightness because of the super cost adjustable lamp,
54:48
but it wouldn't be possible for the code inside that subclass to explicitly refer to that part of the field.
54:57
So private members are not visible in some classes, even though subclasses inherit them.
55:04
A student last year actually pointed out to me that if you read the Java language specification to form a document that describes the language,
55:11
it says that private members are not inherited by their subclasses.
55:17
So when I say inherited, what I mean here is that.
55:23
A subclass does have those members as part of its memory.
55:28
If you would go and inspect the object, it would have all those members. So in that sense, it does inherit them.
55:32
They are there internally. It doesn't inherit them in the sense that you can't access them from the programme text.
55:37
So if in a subclass you tried to use a private field of a superclass by name, you got to compile it.
55:44
You're not allowed to explicitly refer to it, but it is there.
55:51
And if you call methods, if the superclass the manipulate that field, you'll see the effects of that manipulation.
55:53
So it's kind of a of exactly what you mean by inherits.
55:59
OK, so the example I gave you that is if this cheap, adjustable arm subclasses adjustable arm that it can't directly access brightness,
56:03
but it does have a brightness field, and if you didn't need your cheap adjustable lamp, it's brightness will change.
56:12
So the field is that.
56:19
We discussed a bit with super keyboards, which can be used to call constructors, and it can also be used to call a method of the superclass.
56:22
You saw the example of saying Super Dot pressed switch.
56:31
The common use case is super is that in an overridden methods you call the super version of the method of overwriting.
56:35
But that's not actually what super is limited to in an overwritten version of food you could call Super Dot Bar.
56:43
You could call other methods of the super cost. That's pretty unusual and not good style, but it's legal.
56:51
Java. Let's go through one more example of inheritance.
56:56
Let's say you have a Costco to watch. It's got a price. It's a double precision floating point, number doubles on a model.
57:01
That's a string. And let's say we construct a watch from a string on a double.
57:08
We give the price and the model. And then maybe we've got a method that says if we were to have a sale, we might say, actually,
57:13
we're going to change the price of the watch in the event that sale is on, make the watch cheaper.
57:21
So in our cost watch,
57:26
then we might have protected Field's pricing model if we want these to be accessible to subclasses and maybe a method set sale price,
57:28
which is going to decrease the price slightly.
57:37
And I need a magic number here because I've been kind of trying to show excellence or just trying to make a point about inheritance.
57:40
OK. If we then had a Costco luxury watch. So maybe luxury watch actually doesn't add any more fields to watch.
57:49
It's just a more expensive kind of watch. And when we say a sale is on, we want to reduce the prices of our watches,
57:58
but maybe we don't want to reduce the prices of our luxury watches quite as much.
58:05
Then we could do something like this, right? We could say that actually a luxury watch has got a premium.
58:10
So after we reduce its price, we're going to add on this premium.
58:16
And then when we get the sale price, we're going to use the super methods to reduce the price, but then we're going to add this premium on as well.
58:20
So this is a little example of how we might do something a bit different in a subclass in this instance,
58:31
as we would like these these luxury watches to not be made quite as cheap if the same as a.
58:38
OK. And this is the use of super to call the constructor of watch.
58:46
And here we've got a use of super to call this the set sale price method in the Watch Super cost.
58:52
Now, let's talk about visibility again, so near the start of the course, we talked about public and private visibility.
59:02
And I briefly noted that not specifying any visibility gives package level visibility and we've introduced another visibility modify protected.
59:08
So let's just recap how that fits in if a class has got a protected field or a protected method.
59:17
This has a slightly unfortunate meaning, in my opinion. Fortunately, it means that the field or method is available in subclasses.
59:25
That's kind of the point of protecting you. Say this field or this method should be visible in subclasses of the class to in the field,
59:33
but also the field or method is available anywhere in the same package as that class.
59:42
And that's what I think is undesirable. I think it's nice to have a mechanism for saying this thing should be available in subclasses.
59:49
It's nice to have a mechanism for saying this thing should be available in the whole package. I don't like the idea that they just bundle together.
59:56
I think that seems slightly unnatural, but that is the way it is in Java.
1:00:02
And so yet protected is more restrictive than public, but less restrictive.
1:00:07
They need a private, full package.
1:00:12
So a nice property is that we go private package protects its public increasing visibility, so it's nice to have this strict increase of visibility.
1:00:15
What isn't really nice is that it isn't a way of saying this is visible in subclasses only not arbitrary.
1:00:26
Other cost is in the same packages me.
1:00:33
I mean, in practise, it's not that big a deal, but it seems like not a terribly nice language design feature to me.
1:00:36
Yes, please. Is it a best practise to make Garfield feel private or protected?
1:00:43
It's best practise make if you're private. So what I said earlier that you should never have known private deals despite me showing me these examples,
1:00:48
which are important to understand the mechanics. It's best practise to always make fields private.
1:00:55
The reason it's best practise is just the same, just the same argument as I never make if he goes public.
1:01:01
If you would like to give some class in your application, whether that cost is in the same package or not,
1:01:07
or whether it's a subclass, if you'd like to get access to all of your fields, you can provide a better method.
1:01:14
Provided you get cement, it has two advantages. What advantages if you're debugging your programme and you want to know who's getting this field,
1:01:20
you can have breakpoint in the a method which avoids you having to do things like set a watch point on a field.
1:01:27
But more important advantages that using a get a method doesn't commit you to representing that part of your object using that field.
1:01:33
You could change the representation and getting that property of the object
1:01:40
might still make sense and you might compute it from your new representation.
1:01:45
Whereas if you if you expose the field,
1:01:50
you're really saying this particular aspect of my object is represented by an integer or is represented by a string.
1:01:52
If you want to change your mind about that, you'd have to change all the code that uses it. You see what I mean.
1:01:59
So whenever you whenever you might think you need a protected field, there would be no problem instead having a protected getter.
1:02:03
If you want to say, I want to make this aspect of my object available to my subclasses,
1:02:13
but not to everyone else, you could use a protected getter method instead of a protected field.
1:02:18
There was a question on I. OK, well, if it comes back to you, then please ask.
1:02:24
So I've shown you examples of using protective gear to give you the mechanics of how they works,
1:02:35
but I stand by the argument that really, unless there's an extremely good reason, just make fields private.
1:02:39
Reading it, like apart from a bit of extra Typekit at the beginning of time, there's really no downside to doing that.
1:02:46
OK. Right, so subclasses of adjustable arms, they can't access brightness because it was private,
1:02:53
but they can't access is on because that was a protected field of lamp so adjustable and can access it, and so could any other surprises.
1:03:00
Well, unfortunately, other cost is in the same package that access is on.
1:03:10
So if this lamp and this if this lamp was part of a package of other causes,
1:03:14
then if any cost in that package is a lamp reference, they've got access to the is on method and they can directly write to it.
1:03:20
So that's what I don't like about protective, OK? The cost is in just five, unless they also extend them.
1:03:26
Here's a matrix then showing you a summary of visibility in Java. If something is public.
1:03:39
This applies both to fields of methods that is visible everywhere, everywhere you programme.
1:03:44
If something is private, then at other extreme, it's only visible within the same class.
1:03:50
It's not visible to code in different classes, even if they're in the same package, even if they're subclasses.
1:03:54
And then the default visibility, which is package means that the field method is available anywhere in the same package,
1:04:01
but not in a subclass unless that subclass is in the same package and protected is the missing piece of the puzzle, right?
1:04:08
A protected field or method is available within the subclass, no matter where the subclass resides.
1:04:15
Within the package, regardless of whether or not the class is a subclass and of course, in the class itself.
1:04:22
OK. As I mentioned at the beginning of today's session, you should use inheritance rather sparingly.
1:04:31
Complex inheritance hierarchies where some clause extends across DH that extends across see that extends Cosby,
1:04:38
that extends across a that can be very hard to read. They can be very hard to maintain.
1:04:44
You may make modelling errors early in your application design, but you think every scene should be a b.
1:04:49
And then you've now got this big hierarchy, and then maybe you change your mind later on.
1:04:56
You realise that was a bad decision, but is extremely hard to unpick things and change them.
1:05:00
So inheritance can lead to quite complicated code. If you say that B extends aid, you're really saying everybody is an A.
1:05:04
So if Cross has got some code you wanted to reuse. But in Class B.
1:05:17
But if it's not true to say that everybody is at a stone using heritage to reuse that code instead,
1:05:24
have your Class B hold a reference to something of Taipei that it can use to get that job done.
1:05:30
But don't pretend that your OBE is a special version of an A. Just because it's wants to reuse some code from.
1:05:36
And then also ask, is this a relationship you expect? Do you mind repeating the last point?
1:05:44
He knew this would be the last one. Oh, you can't see laptop anymore.
1:05:49
Can you repeat repeat your last point? Oh, the last point. Yes.
1:05:54
I kind of remember the last flight, OK? I think I said that if you said that everybody is in a if you said B extends it,
1:06:00
you really need everything of type B is actually a thing of Taipei, right?
1:06:09
So every station is a student makes sense, right?
1:06:15
But if it turns out you've got a cause, a that's got some functionality inside it and you want to reuse that functionality in another class.
1:06:19
But if those classes don't have an obvious, is our relationship.
1:06:27
If the Subclause B, what if the Cosby doesn't naturally make sense to consider as a special case today that it would
1:06:31
be inappropriate to reuse the code from a by extending a it would be more appropriate to,
1:06:39
for example, make objects for type B, hold a reference to an object of Taipei,
1:06:45
or maybe take that common code and put it in a new special helper class.
1:06:51
Or maybe take that common code and make it be a static method if it doesn't really make sense for it to belong to any cost.
1:06:55
So using inheritance as a way of reusing code is not a good thing to do.
1:07:01
You should use inheritance where it really makes sense to say I want an object that's got specialised capabilities,
1:07:07
but conceptually is what are the things? It's specialised? Yes, this is showing some complex needs, but that's not enough.
1:07:14
You mean if you wanted to extract, have some common functionality? Yeah, OK, I could do a quick example of that.
1:07:28
I mean, what I'm going to do for the example, because I'm a bit short on time is some stuff I want to get through.
1:07:35
I'll just do a kind of contrived example rather than a realistic example.
1:07:40
OK. So let's say I've got a.
1:07:45
And that's a has got a very useful function.
1:07:50
So they're attempting to do it, and it's going to be something extremely useful.
1:08:01
Yeah. No, let's say, and I'm going to just say it's easier to see this.
1:08:09
I'm going to put multiple classes in the same file, which you shouldn't do violates the Google Java style,
1:08:16
but it's just a bit easier so we can see all at the same time. When I say Cosby.
1:08:22
He's going to implement some algorithm. So it's going to be something.
1:08:27
Are at this point in the algorithm, we want to do the very useful thing for some reason.
1:08:47
So we go, OK, well, that students do very useful function. That doesn't compile.
1:08:52
Right? Oh, but if he was a subclass today, it would work.
1:08:58
Yeah. So let's make be some crossover, but actually, maybe as a shark.
1:09:03
It's not a B and maybe a is a banana. And I oh, I can't, I can't.
1:09:08
A public cost has got to match the name of the file you provided. So let me make this not be public.
1:09:18
OK, the company is not happy with me because I called this day.
1:09:26
But anyway, let's just say this close banana. So Banana has got a very useful function, and Ashok wants to use every useful function.
1:09:29
So this would work if we just said that shot extends banana. It's great.
1:09:38
You can call it a very useful function right now later on.
1:09:44
OK, that's working. That's fine. Maybe we later got a class called piano.
1:09:48
In Kano, we've got some functionality. And we want the very useful function.
1:09:55
So we go, Oh, OK, maybe let's say that piano is a shark.
1:10:03
No, maybe 10 is a banana. And I.
1:10:09
Oh, great, we can call the very useful function. And then it turns out that I was in shock, we got maybe I know that useful function.
1:10:12
This form retains 52. And actually in our plan, and we want to do that to want to do another useful thing.
1:10:24
That's not going to work because China is a banana is not short. Oh, OK, let's fix that.
1:10:40
Then let's make a counter can just be a shark then. Right? You can see this is just becoming a total mess.
1:10:43
It does allow us to reuse those functions, but it's a completely inappropriate use of inheritance because Okinawa is not a shark.
1:10:49
Shark is not a banana, at least not in the world I live in. All right. But what we might do is we might say.
1:10:56
Plus, a very useful function, functions we might in here have some static functions.
1:11:04
In the United States, multiple losses can extend multiple losses for the classics that multiple bosses know they can't write in C++, but not in Java.
1:11:29
And I'll talk about that a bit later in the course and everybody, they're very useful function dos.
1:11:40
OK, well, we would get rid of all these relationships, so that might be more appropriate.
1:11:44
OK. But that would only work if they're useful functions, if I might misspell another useful.
1:11:54
Yeah, it's not very useful. It's just another useful function.
1:12:02
So this might work if those functions, if it makes sense for them to be static, they're not things you call or object state wide network beforehand.
1:12:06
One say package save packages. But why didn't it work before when what they did for you at this stage?
1:12:14
Yeah, I'd like to extend the programme.
1:12:22
Sorry. Let me go back to that a moment. Good question. And it might be that actually is very useful.
1:12:27
Function need some states it may be. That is like private int something.
1:12:32
Maybe we're going to be returning 40 to pass that something.
1:12:41
This doesn't work because this is static. You'd actually need to have, let's not call a very useful functions.
1:12:46
Maybe let's call it off right now, we need one of these ball objects.
1:12:51
So we need these methods to be non static. It's.
1:12:59
So now this doesn't work. So what we probably want to do is make our algorithm take up law.
1:13:06
OK. As a parameter. And then we could use that to call this very useful something.
1:13:13
So the point I'm making is that if there's some functionality that it does make sense to use from multiple places.
1:13:19
But if those places are in clauses that don't have any sensible relationship,
1:13:24
the right thing to do would be to put that functionality somewhere common.
1:13:28
Maybe some static methods or have a special a special clause that you can say it's that functionality and then cold air from all these couple places.
1:13:32
So put it in one of them and make the other ones extend from it.
1:13:39
That would be really nasty design to go back to your question that if I could josette my way back to the best we might.
1:13:42
So what, yeah, how far should I go? Was it all right?
1:13:53
So, yeah, here here. Yeah. So where you are, it's kind of cool.
1:13:57
Very useful function. Yeah. The error here is that I'm trying to call the method very useful function of piano here.
1:14:03
OK. Right. Because it's not used and appreciative of the coarsening.
1:14:11
So this entanglement is like, I've done this from here because I want to call a static method.
1:14:15
I would have to give the name of the boss and the function. Yeah, it's just syntax.
1:14:21
This is how you go static. OK.
1:14:26
I would love to talk about this all day actually manually which, but I need to get through the next day of material before into my teaching.
1:14:28
So, yeah, someone raise the question of can you have multiple inheritance in Java?
1:14:36
So a problem with inheritance is that it might make sense to say every B is it a?
1:14:44
So you might say B extends a good fine, fine fine with then later you might be like, Well, hang on a minute.
1:14:50
Every B is also a C. I've said B extends A and I can't say B extend C as well, and then things can get a little bit messy.
1:14:55
And if you just actually avoid using inheritance, full stop and instead use composition, which,
1:15:04
as I mentioned, you'll study more in second year and often you can have a more elegant, extensible design.
1:15:09
So I wouldn't get too hung up on this or not play with inheritance. Understand how it works.
1:15:15
Right? Some horrible code. I mean, you know, it's quite important to make mistakes and write code that you later regret.
1:15:19
That's how you end up with a feel for how you might be going down the wrong design path despite building something that functions OK.
1:15:24
And as you go through the degree, you'll learn more about good software engineering practises.
1:15:31
OK.
1:15:37
So as I said more this second year, so I'm going to skip for now the material on back to interfaces from this deck of slides, but I'll come back to.
1:15:37
All or at least some of it, when I return after Nick's stint,
1:15:47
I would like to go through some of this material in the next decade slides on the object class costing and generics.
1:15:53
OK, so first of all, there is this class called object, which is like the mother of all classes,
1:16:05
every class in a job programme is either direct or indirect subclass of object.
1:16:11
So when you write Class A Open-Carry bracket, you are implicitly saying Class A extends object.
1:16:18
You don't have to write it. You can write it.
1:16:26
You don't have to write it because it's not legal for you to have a class that doesn't either directly extend object or indirectly extend objects.
1:16:28
So I've drawn here object and then like a cloud of classes and then some other classes here.
1:16:37
In fact, String is actually a direct subtitle object. If you look at the string class, you'll see clustering extends object.
1:16:43
If you define your own class staff member that inherits from college member,
1:16:50
then eventually there will be a path up the inheritance hierarchy to object.
1:16:56
So everything is an object.
1:17:01
I'm excluding primitive types here, and it's not it's not a class type, so it doesn't extend the object, but it's not a class, OK?
1:17:04
And if you look at some of the built in classes in Java, that's like a nice example of a reasonable use of inheritance to have a class hierarchy.
1:17:14
So Object has got a subclass code number.
1:17:22
For instance, a number is extended by the various wrapper classes integer wrapper, the float wrapper, the long wrapper.
1:17:25
And you might want to have a look and see what's the role of number.
1:17:31
Is there anything useful that could be said about all of these different kinds of numbers in that class?
1:17:34
String is a direct subclass of object is actually a class code class as a subclass of object, and that's used in something called reflection.
1:17:40
But you can ask the programme about itself. You can say What courses do you have?
1:17:48
What methods are these classes? So there are methods methods called get method that returns a method object.
1:17:53
I mean, you can call that method object. I sometimes use this one to try to help me mock student tests.
1:17:59
I read written code that will crawl over the students solution and try and check whether.
1:18:05
Methods are aimed appropriately and that kind of thing.
1:18:12
It's quite fun to do ends up actually just requiring a lot more time than to go and look each one manually because it's quite complicated codes,
1:18:14
right? So I have a positive approach. OK.
1:18:20
Everything is an object. Just to illustrate that if we say object, my integer equals new integer.
1:18:25
This is fine because the apparent Typekit object, the actual type is integer.
1:18:33
An integer is a subclass of object because. Everything is right.
1:18:41
We can say object my point of new point one to three cabinet appointments.
1:18:49
Have you ever thought about system dos out systems? I mean, I showed this briefly in a previous session.
1:18:55
System dot out is just an object, something you maybe to think about.
1:19:00
You just don't. You just write System Dot Dot Print Island to print, maybe to think too much about what that means.
1:19:04
The system is a kiosk with a field called out. There's got type print stream, so we could say object.
1:19:09
My print stream becomes you could a system dot out, right?
1:19:15
And that is valid codes to write stupid codes, right?
1:19:19
But valid Coach writes, If we say my object set is a set of objects.
1:19:23
Then we can put things into that set, we can add system in to that sense because my object set is a set of objects and systems or in is an object.
1:19:31
We can add a new I o exception to my set of objects, because an Iowa exception is an object,
1:19:41
as we'll see later, every exception is an object so we can add an exception to a set of objects and.
1:19:48
Bertrand Russell might have been surprised to find that we can add my object set to itself.
1:19:57
We can say we're going to put my objects set into itself so we can have a set inside itself.
1:20:01
It's kind of strange, isn't it? Actually, we're not really putting that into itself because I'm being lazy and I'm saying that's.
1:20:08
My object set is an object. But that's not really true, is it?
1:20:21
What would be a more precise thing to say?
1:20:25
If you think about the last act, where I said it was going to be kind of annoying is a reference to an object very good.
1:20:32
I said my object is not an object, that thing there is the object.
1:20:37
This is just a reference to an object. So when I say my objects that don't add my objects sets, I'm saying, put the reference.
1:20:42
That's the that put the current value of my objects that into my objects that.
1:20:53
So the way you might draw this would be.
1:20:59
If you had my object set. It refers to some set on the heat type crash sets of objects so harsh that is implemented in terms of lots of other objects,
1:21:24
but let's not worry about that. It's just conceptually magic. It's a mathematical set right now when we say my objects that don't add my objects that,
1:21:41
well, actually, this is really at some location in memory, as you might recall.
1:21:52
So let's say it's at the address one two three four five.
1:22:00
So really, we've got one two three four five.
1:22:04
That doesn't really exist.
1:22:09
So when we're saying my objects that don't add my objects, that what we're really saying is put whatever value is stored in there in the set.
1:22:11
So we're putting one two three four five into this X because the set is a set of object references.
1:22:20
What that really means is that it's got a reference to itself.
1:22:29
OK. So we don't really have like so infinite thing where the set contains the is that we just say the set contains a reference back to itself.
1:22:34
So actually quite Monday. OK, that makes sense.
1:22:43
Now, we've already seen that it's possible to use an object of one type as if it had a super type.
1:22:53
If, for example, we've got adjustable and it's a subclass of lamp and room uses lamp.
1:23:04
So in this example here we've got room having a lamp field taking a lamp as a parameter.
1:23:09
Then if we say have a nightclub methods that's going to make a new room and pass in a new adjustable lamp.
1:23:17
What we're doing here is we're up casting from adjustable lamp to lamp because it's constructed requires a lamp.
1:23:25
We provided something more specialised and adjustable lamp. And that's fine.
1:23:32
All right. We can always up cost to a more general Typekit. So using a subtype as if it were a super type is called up costing.
1:23:37
It always works, and you don't need to use any syntax to express the fact you're doing this.
1:23:47
You just use the expression of the more specific type in the context where the more general type is required.
1:23:52
So it's fine. We do it all the time. OK, there's up costs going on here, Daryn costing is a bit more controversial sometimes when you are programming.
1:23:58
You get to a point in the code where, as I mentioned last hour, you know, at this point in the programme, a certain.
1:24:10
Variable or field is going to have a particular actual type, and you need to exploit that.
1:24:18
And if the circumstances are right and you really know that, then what you can do is what's called a down cost.
1:24:25
You can actually specifically say, I would like in this example to.
1:24:31
Asserts that Al is an adjustable lap, so here I'm saying at this point of code,
1:24:37
I know Alan will be an adjustable line, so I'd like to have a new reference.
1:24:44
AGL is actually got the same value as AL, but I want to interpret that value as if it were an adjustable arm and then click on it.
1:24:48
So I think it's worth the quick illustration of this on the board because something somewhat subtle going on here.
1:24:58
OK. So in this example, we've got. Yes.
1:25:19
Well, we've got AGL and.
1:25:31
We've got a lamp in memory, and we're saying that agile.
1:25:39
It's got time adjustable arm. And Al has got type lamp.
1:25:46
And Al refers to this object here. So when we execute, this line of code will be introduced agile.
1:25:56
And we say agile is AL, but it's out as an adjustable and.
1:26:07
All we're doing here is saying. This variable also points to that object.
1:26:13
We're not introducing a new object. We're saying this variable reference is the same object as that field.
1:26:22
But we know that we're allowed to call them through agile, right, because it's got apparent tight adjustable lumbar.
1:26:30
OK. But what if? OK, so that's fine if if this object has got tight adjustable.
1:26:42
And it's got a brightness field. So this is all fine and good, but what if actually?
1:26:51
This was just a lamp. And what we do is we say, OK, I would like to pretend this thing is an adjustable I'm I'll call them.
1:27:02
What should now happen? Is there anything sensible that should not happen? No, right?
1:27:15
Well, sorry, you had no idea. Maybe there is an exception.
1:27:20
Yes. OK, so that's the sensible thing, right? So there's not there's not a kind of sensible way to proceed.
1:27:25
There's not a way we can actually call them.
1:27:29
You said I the programme, I promise you, at this point in code, you have an adjustable arm demand, please, and a runtime.
1:27:31
There isn't an adjustable arms that it's just a plain old lamp. There's no way that the dimming can occur.
1:27:37
So down costing can fail.
1:27:42
So when we say here that Islam, how? Will be an adjustable arm if it runs a sign that checks out.
1:27:47
That's fine. OK, but if it runs, it turns out not to be true and an exception will get thrown.
1:27:55
So let's go to an example say we have an alarm al that has got a parent type lamp, an actual type adjustable arm that in principle we'll see on 10.
1:28:01
We can turn it off. OK. We can't deny it.
1:28:13
As discussed before, Ali's got apparently a lump a lump doesn't have it didn't matter.
1:28:18
OK, but now what we can do is we can say we're going to down costs lump to an adjustable arm.
1:28:25
So here we've still only got one object. We did one new.
1:28:31
We've not made any more objects, but we made another reference agile that alias is the same object L refers to.
1:28:35
So our agile both point to the same object, but it's like.
1:28:43
It's like there were different kinds of glasses and is wearing lampp glasses that it can only see what a lamp can offer,
1:28:49
and Agile is wearing adjustable eyeglasses and it can see, Oh yeah, there's a demented I can see that.
1:28:56
OK, and now we are able to get a to the same lamp.
1:29:01
We can press the switch on adjustable,
1:29:06
but we can also deny that the reason we condemn it is that Agile has got a parent type adjustable arm and that does have a method.
1:29:08
So this is a way of saying I actually know what the apparent type is at this point of code.
1:29:16
I'm going to say trust me, camera, I know, and now I'm going to call Method.
1:29:21
All right. But if we go on a bit. If we now say that Al is a new lamp, this off, not an adjustable lamp.
1:29:27
And then we try down costs and say, I'm going to say, pretend al an adjustable.
1:29:37
I did it. So we're saying to the compiler, trust me at this point of the code, our really is an adjustable arm.
1:29:44
So dim it for me, please. The compiler will compile this code.
1:29:50
But it will not actually trust you, it will say you might be wrong, so a runtime I'm going to check and indeed at this point is not an adjustable.
1:29:54
And what will happen is you'll get a cloth cast exception to the attempt to cast from land down to adjustable.
1:30:03
Lamp has got it wrong and an exception has been thrown. Yes, please.
1:30:10
Is there a way to check whether a lump isn't adjustable? Yes, there is.
1:30:15
There's an operator called Instance Off, which we're going to come to the looming tower. OK, so we never get that so down casting.
1:30:20
Also known as narrowing is what we call an explicit type conversion,
1:30:27
and some down costs can't be verified at compile time, and they can produce runtime errors, cost cost, exceptions.
1:30:32
Actually, we're going to come to a bit later in, of course.
1:30:41
Yes, there is a there is a way of asking whether there is a way of querying the actual types of objects,
1:30:43
and you often use that in combination with cost. And you often say, if this thing has this extra type, then don't cost it.
1:30:49
It's typically always how you use it in practise. OK.
1:30:55
And the last bit of time today, I'm going to briefly go through basic generics in Java and then towards that label later on,
1:30:59
and then we're going to come back to some more advanced generics in Java.
1:31:07
So to motivate the idea of generics and Java, let's push that we need, for some reason, a string into Japan.
1:31:12
We've got a piece of code we're implementing and we'd like to have an object. There's a pack comprising a string and an integer.
1:31:19
So this is how we can implement it, right, we can have first and second fields, the obvious constructor,
1:31:26
we might want to have getters and setters if we if we'd like to make this be mutable. So this is a reasonable implementation of a packhorse.
1:31:32
Then later on, we need a person string path. So we write another class with a person field and a stringfield.
1:31:41
And this is also a kind of reasonable crime, but is quite similar back and forth, back and forth.
1:31:49
You can see the code is essentially the same. We just used slightly different names.
1:31:54
So what we'd rather have is a generic path, a pair that can store anything in its first field or anything second field.
1:32:01
We could use that as a string into Japan, who could use it as a person into Japan.
1:32:09
We could use it as a person. So that would be great.
1:32:14
And we've got this cost object and we know everything is an object, so we could have an object object path.
1:32:17
That would be good, right? Actually, what were the problems of an object object, happy,
1:32:24
so we'd lose all the specific functionality that it would use of specific functionality, right?
1:32:33
So we put something into an object object and get it again, and all we know about is it's an object.
1:32:39
Yeah. So indeed, that's a good example. The problems?
1:32:43
And I think, yeah, when you find that type of something like you wouldn't be able to when reading it, they wouldn't know what you want.
1:32:52
I couldn't quite make out what you said, but I think you were saying when you define the type of some variable,
1:33:02
you just say it's a pair your document, what kind of things are meant to store it?
1:33:07
Yeah. Right. And furthermore, there's nothing to stop you putting the wrong things in it by mistake.
1:33:11
OK, so we could make an object object just like this right to fields, object first,
1:33:18
object second, and I, we can use this to represent any power we like.
1:33:23
So this is totally workable. This will work fine if we are careful.
1:33:26
But there are some problems. For example, we can make a string in into Japan.
1:33:32
Hello. Four, That's fine. Okay, we can.
1:33:36
We can make it a person string part new person, Ali.
1:33:39
We can get the string from a string and into the right string an integer, get first, but we have to cast it down to a string.
1:33:44
We know because we made it that the object that comes out will be a string, but we have to downcast it.
1:33:51
And that's not very nice. So we've got to insert these down cross by hand if we wanted to get an integer from a string into Japan.
1:33:56
That's quite easy to string integer Japan. Don't get first down, cost it to an integer.
1:34:04
OK. I see some nodding where I shouldn't see some nodding, and I see this is knowing nodding because you've seen the mistake was the mistake here.
1:34:10
And second. And it was see if we get sick, she could get a second right.
1:34:19
I mean, my string into Japan actually should have a string as its first.
1:34:28
And indeed it does. If you look at it, string integer, we did Halo four.
1:34:32
If we get first, we're going to get. Hello. What? We cast that down to an integer.
1:34:37
What are we going to get the function of an exception of cost, cost, exception?
1:34:41
All right. So we'll get this wrong. So that's that's no good. And actually, if we do this person and string does upset first.
1:34:46
Mint tea and tea is one of my cats. If we do this, then.
1:34:55
Well, what's wrong here? Not the fact that cats got past that, I mean, that's irrelevant.
1:35:00
The programme doesn't know that it is a cat. But what's conceptually wrong here?
1:35:07
This second should be set second, right, because this is a person staying power.
1:35:12
We wanted a person object as the first, so we've tugged in the wrong thing here.
1:35:16
So what's going to go wrong when we do this, when when this erroneous line of code is executed, what will go wrong?
1:35:22
Nothing will go wrong, OK? And is that good? No, right.
1:35:30
Why is that actually terrible? What the fact that things go wrong, a runtime is generally worse,
1:35:35
but something went wrong to run time here and it was bad, but not as bad was particularly horrible here.
1:35:45
Yeah, we are all listed somewhere else. What exactly the error is going to appear later.
1:35:49
Let me try and get something out of this. Then there's going to be an error, but that's not where the bug this bug exists here.
1:35:54
All right. So bugs are never nice, but nice bugs and bugs where the fix is at the same line, the bug occurs.
1:36:00
Bugs are really hard to fix, but actually the fix is got something that at the surface has nothing to do with the line that goes wrong.
1:36:06
OK, so up costs never fail, even if that unintentional.
1:36:13
So things are going to go wrong here should have been set second. So object of jetpack we can make, we can make it work.
1:36:18
We just have to be really careful. But it's not very nice. It's not nicely Typekit.
1:36:24
OK. So there are Sindarius problems.
1:36:29
The Type Pad doesn't document the types of contents we're forced to use down, costing when we want to pull things out of the paper,
1:36:31
which is ugly, it makes the code hard as read, and it's easy to get it wrong.
1:36:38
If we get it wrong? Tough luck. The programme might crash at one time and up, costing always will work.
1:36:43
So if we plug the wrong things into our path, even though they're the wrong things,
1:36:50
conceptually they will be objects so they will be accepted and will only get problems later when we try and pull them out.
1:36:54
So luckily, quite a long time ago, this was actually the normal thing in Java.
1:37:01
Java didn't used to have generics, and you really did need use objects whenever you wanted to have some sort of generic collection generic container.
1:37:05
It just had objects inside it, and it was up to you to get things right. Casting was all over the place in most Java programmes.
1:37:13
OK, so Java's got generics, and we're going to study it in a bit more detail later on.
1:37:21
But just to conclude this lecture, we could easily write a true generic pair in Java by saying our cost pair is generic with respect to some types,
1:37:26
S.A. and in the code we can use S and T basically wherever we could use objects in the previous example or whatever,
1:37:36
we would have you string an integer in the string into Japan. This is an s t path where the point is that S&P R yeah, or whatever.
1:37:45
Right? So since you could be integer and string, it could be passing and double.
1:37:55
It could be whatever we need in space. We can make a generic from an asset, a T.
1:38:01
You can get first, which will give us, as you can set first, which requires and asks if we provide something.
1:38:07
Is it a type s? This will go wrong. OK. And similarly, we've got getters and setters fatigue so we can use them like they were normal Typekit.
1:38:13
And this is great. It means that, for example, if we make a new pair of a string, an integer, that's fine, right?
1:38:23
Because hello, it's a string and four is an integer. We can make a new person string pair that will be fine, too.
1:38:29
All right. Now, when we try and get a string from a string integer, we don't need a down cost because string integer,
1:38:38
because the pairs get first returns, something of the S-type, the first of the two types and for this declaration, S's string.
1:38:46
So that works with no down cost.
1:38:54
Even nicer if we make a mistake, if we try and get the first from our string into the past and put it into an integer,
1:38:57
we get a type error because get first returns something of type s and in the string integer case,
1:39:04
as is string, which doesn't match integer, so they get a type error.
1:39:11
And even better still, if you try put minty into the first element of this person, then string power because minty is a string, not a person.
1:39:15
We right there and then gets a type error. This code won't compile.
1:39:25
We don't have a horrible problem of the code compiling not going wrong there, but later on,
1:39:28
when we try and pull something out of this path, getting a cost cost exception.
1:39:34
OK, so that's a brief introduction to how you write basic generic classes in Java.
1:39:39
That's it for me for a couple of weeks. Looking forward to catching up with you again, and I hope you enjoy concurrency.
1:39:45
You know what that is, but I think I just.
1:39:50